<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="WaveForge DAW - Professionelle Audio-Aufnahmesoftware mit CrashGuard und Cloud-Synchronisation">
    <title>WaveForge DAW - Preview Edition</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="manifest" href="/manifest.json">
    <script src="/tailwind.min.js"></script>
    <link href="/fonts.css" rel="stylesheet">

    <style>
        :root {
            --neon-cyan: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-red: #ff3333;
            --neon-yellow: #ffd700;
            --bg-dark: #050510;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        body {
            background-color: var(--bg-dark);
            background-image:
                radial-gradient(circle at 50% 0%, #1a1a40 0%, transparent 50%),
                linear-gradient(0deg, rgba(0, 243, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 243, 255, 0.03) 1px, transparent 1px);
            background-size: 100% 100%, 40px 40px, 40px 40px;
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            overflow-x: hidden;
            padding-bottom: 120px;
        }

        .glass-panel {
            background: var(--glass);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        /* Player Dock Styles */
        #playerDock {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(150%);
            width: 90%;
            max-width: 820px;
            background: rgba(10, 10, 26, 0.95);
            border: 1px solid var(--neon-cyan);
            box-shadow: 0 0 40px rgba(0, 243, 255, 0.15);
            border-radius: 16px;
            padding: 15px 25px;
            z-index: 100;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.27);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #playerDock.active {
            transform: translateX(-50%) translateY(0);
        }

        /* Seek Slider */
        .seek-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .seek-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--neon-cyan);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--neon-cyan);
            cursor: pointer;
            transition: transform 0.1s;
        }

        .seek-slider::-webkit-slider-thumb:hover {
            transform: scale(1.3);
        }

        /* Control Buttons */
        .player-btn {
            background: transparent;
            border: 1px solid #444;
            color: #aaa;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            cursor: pointer;
        }

        .player-btn:hover {
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.3);
        }

        .player-btn.main-play {
            width: 50px;
            height: 50px;
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
            font-size: 1.2rem;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 150;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: #0a0a1a;
            border: 1px solid var(--neon-cyan);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.2);
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            transform: scale(0.9);
            transition: transform 0.2s;
        }

        .modal-open .modal-content {
            transform: scale(1);
        }

        /* RECOVERY MODAL SPECIFIC */
        .recovery-modal .modal-content {
            border-color: var(--neon-red);
            box-shadow: 0 0 40px rgba(255, 51, 51, 0.3);
        }

        .recovery-btn {
            background: rgba(255, 51, 51, 0.1);
            color: var(--neon-red);
            border: 1px solid var(--neon-red);
        }

        .recovery-btn:hover {
            background: var(--neon-red);
            color: black;
            box-shadow: 0 0 15px var(--neon-red);
        }

        /* LICENSE MODAL SPECIFIC */
        .license-modal .modal-content {
            max-width: 600px;
            border-color: #ffd700;
            /* Gold for premium/business feel */
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.15);
        }

        .license-header {
            color: #ffd700;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
        }

        /* DELETE MODAL SPECIFIC */
        .delete-modal .modal-content {
            border-color: var(--neon-red);
            box-shadow: 0 0 40px rgba(255, 51, 51, 0.25);
            max-width: 400px;
        }

        .delete-btn {
            background: rgba(255, 51, 51, 0.1);
            color: var(--neon-red);
            border: 1px solid var(--neon-red);
            padding: 0.5rem 1.5rem;
            border-radius: 6px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .delete-btn:hover {
            background: var(--neon-red);
            color: black;
            box-shadow: 0 0 15px var(--neon-red);
        }

        .cancel-btn {
            background: transparent;
            color: #9ca3af;
            border: 1px solid #4b5563;
            padding: 0.5rem 1.5rem;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .cancel-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        /* UPLOAD STATUS STYLES (NEW) */
        .upload-status-bar {
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
            display: none;
        }

        .upload-status-fill {
            height: 100%;
            background: var(--neon-cyan);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Upload Icon Status Indicators */
        .upload-icon {
            color: var(--neon-cyan);
            border-color: var(--neon-cyan);
            transition: all 0.3s ease;
        }

        .upload-icon:hover {
            background: rgba(0, 243, 255, 0.1);
        }

        .upload-icon.status-uploading {
            color: #3b82f6;
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.15);
            animation: blink-upload 1s ease-in-out infinite;
        }

        .upload-icon.status-pending {
            color: #f59e0b;
            border-color: #f59e0b;
            opacity: 0.8;
        }

        .upload-icon.status-success {
            color: #10b981;
            border-color: #10b981;
            animation: successPop 0.4s ease-out;
        }

        .upload-icon.status-error {
            color: #ef4444;
            border-color: #ef4444;
            animation: shake 0.5s ease-in-out;
        }
        
        .upload-icon.status-fatal {
            color: #dc2626;
            border-color: #dc2626;
            background: rgba(220, 38, 38, 0.2);
        }
        
        /* Expanded upload status container */
        .upload-status-expanded {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            padding: 0;
            margin-top: 0;
        }
        
        .upload-status-expanded.active {
            max-height: 80px;
            padding: 8px 0;
            margin-top: 8px;
        }
        
        .upload-progress-info {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 12px;
            background: rgba(59, 130, 246, 0.08);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 6px;
        }
        
        .upload-progress-info.paused {
            background: rgba(245, 158, 11, 0.08);
            border-color: rgba(245, 158, 11, 0.2);
        }
        
        .upload-progress-info.fatal {
            background: rgba(220, 38, 38, 0.08);
            border-color: rgba(220, 38, 38, 0.2);
        }
        
        .upload-icon-large {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 18px;
            border: 2px solid;
        }
        
        .upload-icon-large.uploading {
            color: #3b82f6;
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
            animation: blink-upload 1s ease-in-out infinite;
        }
        
        .upload-icon-large.paused {
            color: #f59e0b;
            border-color: #f59e0b;
            background: rgba(245, 158, 11, 0.1);
        }
        
        .upload-icon-large.fatal {
            color: #dc2626;
            border-color: #dc2626;
            background: rgba(220, 38, 38, 0.15);
            cursor: pointer;
        }
        
        .upload-icon-large.fatal:hover {
            background: rgba(220, 38, 38, 0.25);
            transform: scale(1.05);
        }
        
        .upload-progress-text {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0;
        }
        
        .upload-progress-label {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            line-height: 1.2;
            color: #d1d5db;
        }
        
        .upload-progress-details {
            font-size: 11px;
            opacity: 0.8;
            font-family: 'Share Tech Mono', monospace;
            line-height: 1.3;
            color: #9ca3af;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        @keyframes pulse-upload {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.7;
                transform: scale(1.05);
            }
        }
        
        @keyframes blink-upload {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.4;
            }
        }

        @keyframes successPop {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-3px);
            }

            75% {
                transform: translateX(3px);
            }
        }

        /* Faders & Ranges */
        .fader-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            height: 200px;
        }

        input[type=range][orient=vertical] {
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
            width: 8px;
            height: 120px;
            padding: 0 5px;
            background: transparent;
            cursor: pointer;
        }

        .range-wrapper {
            position: relative;
            width: 40px;
            height: 150px;
            display: flex;
            justify-content: center;
        }

        .custom-range {
            -webkit-appearance: none;
            width: 150px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
            transform: rotate(-90deg);
            transform-origin: center;
            position: absolute;
            top: 70px;
        }

        .custom-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 10px;
            background: var(--neon-cyan);
            box-shadow: 0 0 10px var(--neon-cyan);
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.1s ease;
        }

        .custom-range.pink::-webkit-slider-thumb {
            background: var(--neon-pink);
            box-shadow: 0 0 10px var(--neon-pink);
        }

        #visualizer {
            width: 100%;
            height: 120px;
            border-bottom: 1px solid var(--neon-cyan);
            mask-image: linear-gradient(to bottom, black 50%, transparent 100%);
        }

        .digital-text {
            font-family: 'Share Tech Mono', monospace;
        }

        /* Screen reader only - BITV 2.0 compliance */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Focus visible for keyboard navigation - BITV 2.0 compliance */
        button:focus-visible,
        input:focus-visible,
        select:focus-visible,
        a:focus-visible {
            outline: 2px solid var(--neon-cyan);
            outline-offset: 2px;
        }

        /* Skip to content link - BITV 2.0 compliance */
        .skip-to-content {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--neon-cyan);
            color: var(--bg-dark);
            padding: 8px 16px;
            text-decoration: none;
            font-weight: bold;
            z-index: 10000;
        }

        .skip-to-content:focus {
            top: 0;
        }

        @keyframes pulse-rec {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(255, 0, 0, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
            }
        }

        .recording-active {
            animation: pulse-rec 1.5s infinite;
            background-color: #ff0055 !important;
            border-color: #ff0055 !important;
            color: white !important;
        }

        /* Select */
        .cyber-select {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            color: var(--neon-cyan);
            padding: 5px 10px;
            font-family: 'Share Tech Mono', monospace;
            border-radius: 4px;
            outline: none;
        }

        .cyber-select:focus {
            border-color: var(--neon-cyan);
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #050510;
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--neon-cyan);
        }

        /* Upload Status Badges */
        .upload-status-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
            font-family: 'Share Tech Mono', monospace;
            vertical-align: middle;
            white-space: nowrap;
        }

        .status-uploading {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            border: 1px solid rgba(59, 130, 246, 0.3);
            animation: pulse-upload 2s infinite;
        }

        .status-paused {
            background: rgba(251, 191, 36, 0.2);
            color: #f59e0b;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .status-synced {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .status-failed {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
            cursor: help;
        }

        @keyframes pulse-upload {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.7;
                transform: scale(0.98);
            }
        }

        /* Live Upload Indicator (during recording) */
        /* Live Upload Indicator - Redesigned with 4 States */
        .live-upload-active {
            background: rgba(0, 243, 255, 0.1);
            border-color: rgba(0, 243, 255, 0.5);
            color: #00f3ff;
            animation: pulse-upload 2s infinite;
        }

        .live-upload-paused {
            background: rgba(234, 179, 8, 0.1);
            border-color: rgba(234, 179, 8, 0.5);
            color: #eab308;
        }

        .live-upload-offline {
            background: rgba(156, 163, 175, 0.1);
            border-color: rgba(156, 163, 175, 0.5);
            color: #9ca3af;
        }

        .live-upload-disabled {
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.5);
            color: #ef4444;
            opacity: 0.5;
            cursor: not-allowed;
        }

        @keyframes pulse-upload {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.7;
                transform: scale(0.95);
            }
        }
    </style>
</head>

<body class="min-h-screen flex flex-col items-center p-4">
    <!-- BITV 2.0: Skip to content link for keyboard navigation -->
    <a href="#main-content" class="skip-to-content" data-i18n="ui.skipToContent">Zum Hauptinhalt springen</a>

    <!-- Header & Visualizer -->
    <header class="w-full max-w-5xl mb-6 glass-panel overflow-hidden relative" role="banner">
        <div
            class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-cyan-500 to-transparent opacity-50">
        </div>
        <div class="p-4 flex justify-between items-end relative z-10 bg-black/20">
            <div>
                <h1 class="text-3xl font-bold tracking-widest uppercase text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-600"
                    style="text-shadow: 0 0 20px rgba(0,243,255,0.3);">
                    WAVE<span class="text-white">FORGE</span>
                </h1>
                <p class="text-xs text-gray-400 tracking-[0.2em] mt-1" data-i18n="ui.crashguard">CRASHGUARD // RAID
                    PROTECTED SYSTEM</p>
            </div>
            <div class="flex flex-col items-end gap-1">
                <div class="flex items-center gap-2 mb-1">
                    <!-- Language Selector -->
                    <label for="languageSelector" class="sr-only" data-i18n="aria.selectLanguage">Sprache
                        auswÃ¤hlen</label>
                    <select id="languageSelector" onchange="switchLanguage(this.value)"
                        class="cyber-select text-[10px] px-2 py-1 border-gray-700 hover:border-cyan-500/50"
                        aria-label="Sprache auswÃ¤hlen">
                        <option value="de">ðŸ‡©ðŸ‡ª DE</option>
                        <option value="en">ðŸ‡¬ðŸ‡§ EN</option>
                    </select>
                    <!-- Info Button -->
                    <button onclick="openInfoModal()"
                        class="text-[10px] text-gray-500 hover:text-cyan-400 transition-colors flex items-center gap-1 border border-gray-800 rounded px-2 py-0.5 hover:border-cyan-500/50"
                        aria-label="Informationen und Compliance anzeigen" data-i18n-attr="aria-label:aria.info"
                        type="button">
                        <span class="text-cyan-400" aria-hidden="true">â„¹</span> <span data-i18n="ui.info">INFO</span>
                    </button>
                    <!-- Upload Settings Button -->
                    <button onclick="openUploadSettingsModal()"
                        class="text-[10px] text-gray-500 hover:text-cyan-400 transition-colors flex items-center gap-1 border border-gray-800 rounded px-2 py-0.5 hover:border-cyan-500/50"
                        aria-label="Upload-Einstellungen Ã¤ndern" data-i18n-attr="aria-label:aria.uploadSettings"
                        type="button">
                        <span class="text-cyan-400" aria-hidden="true">âš™</span> <span
                            data-i18n="ui.uploadSettings">UPLOAD</span>
                    </button>
                </div>
                <div id="statusIndicator" class="text-xs digital-text text-cyan-400" role="status" aria-live="polite"
                    data-i18n="status.ready">SYSTEM READY</div>
                <div id="timerDisplay" class="text-2xl digital-text font-bold text-white" role="timer" aria-live="off"
                    aria-label="Aufnahmedauer" data-i18n-attr="aria-label:aria.recordingDuration">00:00:00</div>
            </div>
        </div>
        <canvas id="visualizer" aria-label="Audio-Visualisierung"></canvas>
    </header>

    <main id="main-content" class="w-full max-w-5xl grid grid-cols-1 lg:grid-cols-12 gap-6" role="main">

        <!-- LEFT: Controls & EQ -->
        <div class="lg:col-span-7 space-y-6">

            <!-- Recording / Input Section -->
            <section class="glass-panel p-6 relative overflow-hidden" aria-label="Eingangsstufe"
                data-i18n-attr="aria-label:aria.inputSection">
                <div class="absolute top-0 right-0 p-2 text-[10px] text-gray-500 font-mono border-l border-b border-gray-800"
                    data-i18n="ui.inputStage">INPUT STAGE</div>

                <div class="flex items-center justify-between mb-6 flex-wrap gap-4">
                    <h2 class="text-xl font-bold flex items-center gap-2">
                        <span class="w-2 h-2 bg-cyan-500 rounded-full shadow-[0_0_10px_#00f3ff]"></span>
                        <span data-i18n="ui.input">INPUT</span>
                    </h2>

                    <div class="flex flex-col gap-1">
                        <div class="flex items-center gap-2 bg-black/30 p-1 rounded border border-gray-800">
                            <label class="text-[10px] text-gray-400 pl-2" data-i18n="ui.format">FORMAT:</label>
                            <label for="recordingFormat" class="sr-only">Aufnahmeformat</label>
                            <select id="recordingFormat" onchange="updateFormatWarning()"
                                class="cyber-select text-xs border-none bg-transparent"
                                aria-label="Aufnahmeformat auswÃ¤hlen">
                                <option value="webm">WEBM (Opus Codec)</option>
                                <option value="wav">WAV</option>
                                <option value="mp3">MP3</option>
                            </select>
                        </div>
                        <div id="ramWarning" class="text-[9px] font-mono text-green-400 pl-1">
                            âœ“ LOW RAM MODE (Safe for 8h+)
                        </div>
                    </div>

                    <div class="flex gap-3">
                        <button id="recordButton"
                            class="px-6 py-2 rounded border border-red-500/50 text-red-400 hover:bg-red-500/10 hover:text-white transition-all font-mono tracking-wider text-sm uppercase flex items-center gap-2"
                            aria-label="Aufnahme starten" data-i18n-attr="aria-label:aria.startRecording" type="button">
                            <span class="w-2 h-2 rounded-full bg-current" aria-hidden="true"></span> <span
                                data-i18n="ui.rec">REC</span>
                        </button>
                        <button id="stopButton"
                            class="px-6 py-2 rounded border border-gray-600 text-gray-400 hover:bg-white/10 transition-all font-mono tracking-wider text-sm uppercase"
                            disabled aria-label="Aufnahme stoppen" aria-disabled="true"
                            data-i18n-attr="aria-label:aria.stopRecording" type="button">
                            <span data-i18n="ui.stop">STOP</span>
                        </button>
                    </div>
                </div>

                <div class="grid grid-cols-4 gap-2">
                    <!-- Faders -->
                    <div class="fader-group">
                        <div class="range-wrapper">
                            <label for="inputLowShelf" class="sr-only">Eingangs-Low-Shelf EQ</label>
                            <input type="range" id="inputLowShelf" min="-20" max="20" step="1" value="0"
                                class="custom-range" aria-label="Eingangs-Low-Shelf: 0 dB" aria-valuemin="-20"
                                aria-valuemax="20" aria-valuenow="0" aria-valuetext="0 Dezibel">
                        </div>
                        <span class="text-xs text-cyan-300 font-mono mt-[-20px]" data-i18n="ui.low">LOW</span>
                        <span id="val-inputLow" class="text-[10px] text-gray-500">0dB</span>
                    </div>
                    <div class="fader-group">
                        <div class="range-wrapper">
                            <label for="inputPeaking" class="sr-only">Eingangs-Peaking EQ</label>
                            <input type="range" id="inputPeaking" min="-20" max="20" step="1" value="0"
                                class="custom-range" aria-label="Eingangs-Peaking: 0 dB" aria-valuemin="-20"
                                aria-valuemax="20" aria-valuenow="0" aria-valuetext="0 Dezibel">
                        </div>
                        <span class="text-xs text-cyan-300 font-mono mt-[-20px]" data-i18n="ui.mid">MID</span>
                        <span id="val-inputMid" class="text-[10px] text-gray-500">0dB</span>
                    </div>
                    <div class="fader-group">
                        <div class="range-wrapper">
                            <label for="inputHighShelf" class="sr-only">Eingangs-High-Shelf EQ</label>
                            <input type="range" id="inputHighShelf" min="-20" max="20" step="1" value="0"
                                class="custom-range" aria-label="Eingangs-High-Shelf: 0 dB" aria-valuemin="-20"
                                aria-valuemax="20" aria-valuenow="0" aria-valuetext="0 Dezibel">
                        </div>
                        <span class="text-xs text-cyan-300 font-mono mt-[-20px]" data-i18n="ui.high">HIGH</span>
                        <span id="val-inputHigh" class="text-[10px] text-gray-500">0dB</span>
                    </div>
                    <div class="fader-group">
                        <div class="range-wrapper">
                            <label for="inputGain" class="sr-only">EingangsverstÃ¤rkung</label>
                            <input type="range" id="inputGain" min="0" max="2" step="0.1" value="1"
                                class="custom-range pink" aria-label="EingangsverstÃ¤rkung: 1.0x" aria-valuemin="0"
                                aria-valuemax="2" aria-valuenow="1" aria-valuetext="1.0 fache VerstÃ¤rkung">
                        </div>
                        <span class="text-xs text-pink-400 font-mono mt-[-20px]" data-i18n="ui.gain">GAIN</span>
                        <span id="val-inputGain" class="text-[10px] text-gray-500">100%</span>
                    </div>
                </div>
            </section>

            <!-- Playback EQ Section -->
            <section class="glass-panel p-6 relative overflow-hidden" aria-label="Ausgangsstufe"
                data-i18n-attr="aria-label:aria.outputSection">
                <div class="absolute top-0 right-0 p-2 text-[10px] text-gray-500 font-mono border-l border-b border-gray-800"
                    data-i18n="ui.outputStage">OUTPUT STAGE</div>
                <h2 class="text-xl font-bold flex items-center gap-2 mb-6">
                    <span class="w-2 h-2 bg-pink-500 rounded-full shadow-[0_0_10px_#ff00ff]"></span>
                    <span data-i18n="ui.output">OUTPUT</span>
                </h2>
                <div class="grid grid-cols-4 gap-2">
                    <div class="fader-group">
                        <div class="range-wrapper">
                            <label for="outputLowShelf" class="sr-only">Ausgangs-Low-Shelf EQ</label>
                            <input type="range" id="outputLowShelf" min="-20" max="20" step="1" value="0"
                                class="custom-range pink" aria-label="Ausgangs-Low-Shelf: 0 dB" aria-valuemin="-20"
                                aria-valuemax="20" aria-valuenow="0" aria-valuetext="0 Dezibel">
                        </div>
                        <span class="text-xs text-pink-300 font-mono mt-[-20px]">LOW</span>
                        <span id="val-outputLow" class="text-[10px] text-gray-500">0dB</span>
                    </div>
                    <div class="fader-group">
                        <div class="range-wrapper">
                            <label for="outputPeaking" class="sr-only">Ausgangs-Peaking EQ</label>
                            <input type="range" id="outputPeaking" min="-20" max="20" step="1" value="0"
                                class="custom-range pink" aria-label="Ausgangs-Peaking: 0 dB" aria-valuemin="-20"
                                aria-valuemax="20" aria-valuenow="0" aria-valuetext="0 Dezibel">
                        </div>
                        <span class="text-xs text-pink-300 font-mono mt-[-20px]">MID</span>
                        <span id="val-outputMid" class="text-[10px] text-gray-500">0dB</span>
                    </div>
                    <div class="fader-group">
                        <div class="range-wrapper">
                            <label for="outputHighShelf" class="sr-only">Ausgangs-High-Shelf EQ</label>
                            <input type="range" id="outputHighShelf" min="-20" max="20" step="1" value="0"
                                class="custom-range pink" aria-label="Ausgangs-High-Shelf: 0 dB" aria-valuemin="-20"
                                aria-valuemax="20" aria-valuenow="0" aria-valuetext="0 Dezibel">
                        </div>
                        <span class="text-xs text-pink-300 font-mono mt-[-20px]">HIGH</span>
                        <span id="val-outputHigh" class="text-[10px] text-gray-500">0dB</span>
                    </div>
                    <div class="fader-group">
                        <div class="range-wrapper">
                            <label for="outputGain" class="sr-only">AusgangslautstÃ¤rke</label>
                            <input type="range" id="outputGain" min="0" max="2" step="0.1" value="1"
                                class="custom-range" aria-label="AusgangslautstÃ¤rke: 1.0x" aria-valuemin="0"
                                aria-valuemax="2" aria-valuenow="1" aria-valuetext="1.0 fache LautstÃ¤rke">
                        </div>
                        <span class="text-xs text-cyan-400 font-mono mt-[-20px]">VOL</span>
                        <span id="val-outputGain" class="text-[10px] text-gray-500">100%</span>
                    </div>
                </div>
            </section>
        </div>

        <!-- RIGHT: Library / Playlist -->
        <div class="lg:col-span-5 flex flex-col h-full">
            <div class="glass-panel p-6 flex-grow flex flex-col h-[600px] lg:h-auto" role="region"
                aria-label="Aufnahmedatenbank">
                <div class="flex justify-between items-center mb-4 pb-4 border-b border-gray-800">
                    <div>
                        <h2 class="text-xl font-bold font-mono text-gray-200" data-i18n="playlist.title">RECORDINGS</h2>
                        <div class="text-[10px] text-gray-500" id="formatInfo" aria-live="polite"
                            data-i18n="format.detecting">FORMAT: DETECTING...</div>
                    </div>
                    <div class="flex items-center gap-2">
                        <!-- Live Upload Indicator: Replaces UPLOADING text -->
                        <button id="liveUploadIndicator" 
                            class="text-[10px] px-2 py-1 rounded border cursor-pointer transition-all hover:opacity-80 hidden"
                            role="button" 
                            aria-label="Upload status"
                            tabindex="0"
                            style="min-width: 70px;">
                            <span class="font-mono">UPLOAD</span>
                        </button>
                        <span id="dbStatus"
                            class="text-[10px] bg-green-900/30 text-green-400 px-2 py-1 rounded border border-green-900">DB
                            ONLINE</span>
                    </div>
                </div>

                <div id="playlist" class="flex-grow overflow-y-auto space-y-2 pr-2">
                    <div class="text-center text-gray-600 mt-10 digital-text">LOADING DATA...</div>
                </div>

                <div id="storageInfo"
                    class="mt-4 pt-4 border-t border-gray-800 text-xs text-gray-500 font-mono flex justify-between">
                    <span>LOCAL STORAGE</span>
                    <span id="trackCount">0 TRACKS</span>
                </div>
            </div>
        </div>
    </main>

    <!-- FLOATING PLAYER DOCK -->
    <div id="playerDock">
        <div class="flex items-center justify-between mb-2">
            <div class="flex items-center gap-2">
                <label for="playbackSpeed" class="text-[10px] text-gray-500 font-mono">SPEED:</label>
                <select id="playbackSpeed" onchange="changePlaybackSpeed(this.value)"
                    class="cyber-select text-xs px-2 py-1 border-gray-700" aria-label="Wiedergabegeschwindigkeit">
                    <option value="0.25">0.25x</option>
                    <option value="0.5">0.5x</option>
                    <option value="0.75">0.75x</option>
                    <option value="1" selected>1x</option>
                    <option value="1.25">1.25x</option>
                    <option value="1.5">1.5x</option>
                    <option value="1.75">1.75x</option>
                    <option value="2">2x</option>
                </select>
            </div>
            <button onclick="closeDock()" class="player-btn text-xs w-6 h-6" aria-label="Player schlieÃŸen"
                type="button">Ã—</button>
        </div>
        <div class="flex items-center gap-3 w-full mb-1">
            <span id="currentTime" class="text-xs font-mono text-cyan-400 w-12 text-right"
                aria-label="Aktuelle Zeit">00:00</span>
            <div class="flex-grow relative">
                <label for="seekSlider" class="sr-only">Wiedergabeposition</label>
                <input type="range" id="seekSlider" class="seek-slider" min="0" max="100" value="0" step="0.01"
                    oninput="playerSeek(this.value)" onmousedown="window.isSeekDragging=true"
                    onmouseup="window.isSeekDragging=false" ontouchstart="window.isSeekDragging=true"
                    ontouchend="window.isSeekDragging=false" aria-label="Wiedergabeposition" aria-valuemin="0"
                    aria-valuemax="100" aria-valuenow="0" aria-valuetext="0 Prozent">
            </div>
            <span id="totalTime" class="text-xs font-mono text-gray-400 w-12" aria-label="Gesamtdauer">00:00</span>
        </div>
        <div class="flex justify-center items-center gap-4">
            <button onclick="playerSeekStart()" class="player-btn text-xs" aria-label="Zum Anfang springen"
                type="button">|&lt;&lt;</button>
                    <button onclick="playerSkip(-10)" class="player-btn text-xs" aria-label="10 Sekunden zurÃ¼ck"
                        type="button">-10s</button>
                    <button id="dockPlayBtn" onclick="togglePlayPause()" class="player-btn main-play"
                        aria-label="Abspielen" type="button">â–¶</button>
                    <button onclick="playerSkip(10)" class="player-btn text-xs" aria-label="10 Sekunden vorwÃ¤rts"
                        type="button">+10s</button>
                    <button onclick="playerSeekEnd()" class="player-btn text-xs" aria-label="Zum Ende springen"
                        type="button">&gt;&gt;|</button>
        </div>
        <div class="text-center">
            <div id="nowPlayingText" class="text-[10px] text-gray-400 tracking-wider font-mono truncate">NO TRACK
                SELECTED</div>
        </div>
    </div>

    <!-- SAVE MODAL -->
    <div id="saveModal" class="modal-overlay" aria-hidden="true">
        <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="saveModalTitle" aria-describedby="saveModalDesc">
            <h2 id="saveModalTitle" class="text-xl font-bold text-white mb-4 border-b border-gray-700 pb-2" tabindex="0">SAVE
                SEQUENCE</h2>
            <p id="saveModalDesc" class="sr-only">Geben Sie einen Namen fÃ¼r Ihre Aufnahme ein und speichern Sie diese in der lokalen Datenbank.</p>
            <div class="mb-4">
                <label for="saveNameInput" class="block text-gray-400 text-xs mb-1">NAME</label>
                <input type="text" id="saveNameInput"
                    class="w-full bg-black/50 border border-gray-700 rounded p-2 text-white focus:border-cyan-400 outline-none"
                    placeholder="Enter sequence name..." aria-label="Sequenzname eingeben" aria-required="true" tabindex="0">
            </div>
            <div class="mb-6">
                <label class="block text-gray-400 text-xs mb-1">SELECTED FORMAT</label>
                <div id="saveFormatDisplay" class="text-cyan-400 font-mono text-sm">WEBM</div>
                <div id="processingWarning" class="text-[10px] text-yellow-500 mt-1 hidden">âš  Converting large files may
                    require high RAM.</div>
            </div>
            <div class="flex gap-3 justify-end">
                <button onclick="closeSaveModal()" class="px-4 py-2 rounded text-gray-400 hover:bg-white/10 text-sm"
                    aria-label="Verwerfen und schlieÃŸen" type="button" tabindex="0">DISCARD</button>
                <button onclick="confirmSave()"
                    class="px-6 py-2 rounded bg-cyan-600 hover:bg-cyan-500 text-white font-bold text-sm shadow-[0_0_15px_rgba(0,243,255,0.4)]"
                    aria-label="In Datenbank speichern" type="button" tabindex="0">SAVE TO DB</button>
            </div>
            <div id="processingIndicator" class="hidden mt-4 text-center text-xs text-pink-400 animate-pulse">PROCESSING
                AUDIO... PLEASE WAIT</div>
        </div>
    </div>

    <!-- RECOVERY MODAL -->
    <div id="recoveryModal" class="modal-overlay recovery-modal" aria-hidden="true">
        <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="recoveryModalTitle" aria-describedby="recoveryModalDesc">
            <h2 id="recoveryModalTitle"
                class="text-xl font-bold text-red-500 mb-4 border-b border-red-900 pb-2 flex items-center gap-2" tabindex="0">
                <span class="animate-pulse" aria-hidden="true">âš </span> SYSTEM ALERT
            </h2>
            <p id="recoveryModalDesc" class="text-sm text-gray-300 mb-4">
                The system detected a crash or unexpected closure during an active recording session. RAID fragments
                have been recovered.
            </p>

            <div class="bg-red-900/20 border border-red-900/50 p-3 rounded mb-6">
                <div class="text-[10px] text-red-400 font-mono mb-1">RECOVERED SESSION ID:</div>
                <div id="recoveryId" class="text-xs font-mono text-white truncate">...</div>
                <div class="flex justify-between mt-2">
                    <span class="text-[10px] text-gray-400">CHUNKS: <span id="recoveryChunks"
                            class="text-white">0</span></span>
                    <span class="text-[10px] text-gray-400">SIZE: <span id="recoverySize" class="text-white">0
                            MB</span></span>
                </div>
            </div>

            <div class="flex gap-3 justify-end">
                <button onclick="CrashGuard.discardSession()"
                    class="px-4 py-2 rounded text-gray-400 hover:text-red-400 hover:bg-red-900/20 text-sm"
                    aria-label="Wiederherstellungsdaten lÃ¶schen" type="button" tabindex="0">PURGE DATA</button>
                <button onclick="CrashGuard.assembleSession(null, true)"
                    class="recovery-btn px-6 py-2 rounded font-bold text-sm shadow-[0_0_15px_rgba(255,51,51,0.4)]"
                    aria-label="Sitzung wiederherstellen und speichern" type="button" tabindex="0">RESTORE & SAVE</button>
            </div>
        </div>
    </div>

    <!-- UPLOAD SETTINGS MODAL -->
    <div id="uploadSettingsModal" class="modal-overlay license-modal" aria-hidden="true" style="display: none;">
        <div class="modal-content text-gray-200 font-sans max-w-md w-full" role="dialog" aria-modal="true"
            aria-labelledby="uploadSettingsModalTitle" aria-describedby="uploadSettingsDesc">
            <div class="flex justify-between items-start mb-6 pb-3 border-b border-gray-700">
                <h2 id="uploadSettingsModalTitle" class="text-xl font-bold font-mono tracking-widest text-cyan-400"
                    data-i18n="modal.uploadSettings" tabindex="0">
                    UPLOAD SETTINGS
                </h2>
                <button onclick="closeUploadSettingsModal()"
                    class="text-gray-500 hover:text-white text-2xl leading-none" aria-label="SchlieÃŸen"
                    data-i18n-attr="aria-label:ui.close" type="button" tabindex="0">&times;</button>
            </div>

            <div class="mb-6">
                <p id="uploadSettingsDesc" class="sr-only">WÃ¤hlen Sie die Upload-Methode fÃ¼r Ihre Aufnahmen. TUS unterstÃ¼tzt das Fortsetzen unterbrochener Uploads.</p>
                <h3 class="font-bold text-gray-200 mb-3" data-i18n="upload.method">Transfer Method</h3>
                <p class="text-sm text-gray-400 mb-4" data-i18n="upload.desc">
                    Choose the file upload method. TUS allows resuming interrupted uploads.
                </p>

                <div class="space-y-3">
                    <label
                        class="flex items-center p-3 border border-gray-700 rounded hover:bg-gray-800 cursor-pointer transition-colors">
                        <input type="radio" name="uploadMethod" value="tus" class="form-radio text-cyan-400 h-5 w-5"
                            checked>
                        <div class="ml-3">
                            <span class="block text-sm font-bold text-gray-200" data-i18n="upload.tus">TUS (Resumable,
                                Recommended)</span>
                        </div>
                    </label>

                    <label
                        class="flex items-center p-3 border border-gray-700 rounded hover:bg-gray-800 cursor-pointer transition-colors">
                        <input type="radio" name="uploadMethod" value="legacy" class="form-radio text-pink-500 h-5 w-5">
                        <div class="ml-3">
                            <span class="block text-sm font-bold text-gray-200" data-i18n="upload.legacy">Legacy
                                (Standard POST)</span>
                        </div>
                    </label>
                </div>
            </div>

            <div class="flex justify-end gap-3 pt-3 border-t border-gray-700">
                <button onclick="closeUploadSettingsModal()"
                    class="px-4 py-2 text-sm text-gray-400 hover:text-white transition-colors" data-i18n="ui.close" tabindex="0">
                    Close
                </button>
                <button onclick="saveUploadSettings()"
                    class="px-4 py-2 text-sm bg-cyan-600 hover:bg-cyan-500 text-white rounded font-bold transition-colors"
                    data-i18n="ui.save" tabindex="0">
                    Save
                </button>
            </div>
        </div>
    </div>

    <!-- INFO MODAL -->
    <div id="infoModal" class="modal-overlay license-modal" aria-hidden="true">
        <div class="modal-content text-gray-200 font-sans max-h-[90vh] overflow-y-auto" role="dialog" aria-modal="true"
            aria-labelledby="infoModalTitle">
            <div class="flex justify-between items-start mb-6 license-header pb-3 sticky top-0 bg-gray-900 z-10">
                <h2 id="infoModalTitle" class="text-xl font-bold font-mono tracking-widest text-cyan-400">WAVEFORGE PRO
                    - INFO</h2>
                <button onclick="closeInfoModal()" class="text-gray-500 hover:text-white text-2xl leading-none"
                    aria-label="Informationen schlieÃŸen" type="button">&times;</button>
            </div>

            <!-- INTRODUCTION -->
            <div class="bg-gradient-to-r from-cyan-900/20 to-blue-900/20 border border-cyan-800/40 p-5 rounded-lg mb-6">
                <h3 class="font-bold text-cyan-400 text-lg mb-3">Professionelle Audio-Workstation fÃ¼r Browser</h3>
                <p class="text-sm text-gray-300 leading-relaxed mb-3">
                    WaveForge Pro ist eine hochmoderne Digital Audio Workstation (DAW), die vollstÃ¤ndig im Browser lÃ¤uft
                    - OFFLINE!.
                    Mit fortschrittlicher CrashGuard-Technologie ermÃ¶glicht sie unterbrechungsfreie Langzeitaufnahmen
                    von Ã¼ber 8 Stunden
                    und bietet dabei professionelle Features wie Echtzeit-EQ, Cloud-Synchronisation und automatische
                    Wiederherstellung.
                </p>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs">
                    <div class="bg-black/40 p-2 rounded border border-gray-700">
                        <span class="text-cyan-400">âœ“</span> <strong class="text-white">Offline-fÃ¤hig</strong>
                    </div>
                    <div class="bg-black/40 p-2 rounded border border-gray-700">
                        <span class="text-cyan-400">âœ“</span> <strong class="text-white">Multi-Browser</strong>
                    </div>
                    <div class="bg-black/40 p-2 rounded border border-gray-700">
                        <span class="text-cyan-400">âœ“</span> <strong class="text-white">Speicher-optimiert</strong>
                    </div>
                    <div class="bg-black/40 p-2 rounded border border-gray-700">
                        <span class="text-cyan-400">âœ“</span> <strong class="text-white">Lokaler Download</strong>
                    </div>
                </div>
            </div>

            <!-- COMPLIANCE CERTIFICATIONS -->
            <div class="bg-gray-800/30 border border-gray-700 p-4 rounded mb-6">
                <h3 class="font-bold text-gray-200 mb-3 text-sm uppercase tracking-wide">
                    Compliance & Zertifizierungen
                </h3>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                    <div class="bg-black/30 p-3 rounded border border-gray-700">
                        <div class="text-gray-200 font-bold text-sm mb-1">WCAG 2.1</div>
                        <div class="text-xs text-gray-400">Level AA</div>
                        <div class="text-[10px] text-cyan-400 mt-1">âœ“ Compliant</div>
                    </div>
                    <div class="bg-black/30 p-3 rounded border border-gray-700">
                        <div class="text-gray-200 font-bold text-sm mb-1">BITV 2.0</div>
                        <div class="text-xs text-gray-400">DE Accessibility</div>
                        <div class="text-[10px] text-cyan-400 mt-1">âœ“ Compliant</div>
                    </div>
                    <div class="bg-black/30 p-3 rounded border border-gray-700">
                        <div class="text-gray-200 font-bold text-sm mb-1">EN 301 549</div>
                        <div class="text-xs text-gray-400">EU Standard</div>
                        <div class="text-[10px] text-cyan-400 mt-1">âœ“ Compliant</div>
                    </div>
                </div>
                <p class="text-xs text-gray-400 mt-3">VollstÃ¤ndige Barrierefreiheit fÃ¼r Screenreader, Tastaturnavigation
                    und assistive Technologien.</p>
            </div>

            <!-- FEATURES -->
            <div class="space-y-4 text-sm leading-relaxed">
                <h3 class="font-bold text-gray-200 uppercase tracking-wide text-sm border-b border-gray-700 pb-2">
                    Hauptfunktionen</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div class="bg-gray-800/30 border border-gray-700 p-3 rounded">
                        <h4 class="font-bold text-gray-200 text-xs mb-2">ðŸŽ™ Aufnahme & Produktion</h4>
                        <ul class="text-xs text-gray-400 space-y-1">
                            <li>â€¢ 8+ Stunden Langzeitaufnahme</li>
                            <li>â€¢ WEBM, WAV, MP3 Format-Support</li>
                            <li>â€¢ Echtzeit-Wellenform-Visualisierung</li>
                            <li>â€¢ 3-Band EQ (Low/Mid/High)</li>
                            <li>â€¢ Lokaler Download als Audio-Datei</li>
                        </ul>
                    </div>
                    <div class="bg-gray-800/30 border border-gray-700 p-3 rounded">
                        <h4 class="font-bold text-gray-200 text-xs mb-2">ðŸ›¡ CrashGuard System</h4>
                        <ul class="text-xs text-gray-400 space-y-1">
                            <li>â€¢ Automatische Crash-Wiederherstellung</li>
                            <li>â€¢ RAID-Ã¤hnliche Chunk-Sicherung</li>
                            <li>â€¢ Atomare Schreiboperationen (fsync)</li>
                            <li>â€¢ LÃ¼ckenlose DatenintegritÃ¤t</li>
                            <li>â€¢ Session-Recovery bei Absturz</li>
                        </ul>
                    </div>
                    <div class="bg-gray-800/30 border border-gray-700 p-3 rounded">
                        <h4 class="font-bold text-gray-200 text-xs mb-2">â˜ Cloud-Synchronisation</h4>
                        <ul class="text-xs text-gray-400 space-y-1">
                            <li>â€¢ Service Worker Background-Upload</li>
                            <li>â€¢ Intelligenter Retry-Mechanismus</li>
                            <li>â€¢ Offline-Queue mit Persistenz</li>
                            <li>â€¢ Automatische Netzwerk-Erkennung</li>
                            <li>â€¢ Hash-basiertes Sharding (Skalierbar)</li>
                        </ul>
                    </div>
                    <div class="bg-gray-800/30 border border-gray-700 p-3 rounded">
                        <h4 class="font-bold text-gray-200 text-xs mb-2">â™¿ Barrierefreiheit</h4>
                        <ul class="text-xs text-gray-400 space-y-1">
                            <li>â€¢ ARIA Labels & Semantic HTML</li>
                            <li>â€¢ VollstÃ¤ndige Tastatur-Navigation</li>
                            <li>â€¢ Screen Reader UnterstÃ¼tzung</li>
                            <li>â€¢ Focus Management & Skip Links</li>
                            <li>â€¢ BITV 2.0 / WCAG 2.1 AA konform</li>
                        </ul>
                    </div>
                    <div class="bg-gray-800/30 border border-gray-700 p-3 rounded">
                        <h4 class="font-bold text-gray-200 text-xs mb-2">ðŸ“± Offline & Multi-Browser</h4>
                        <ul class="text-xs text-gray-400 space-y-1">
                            <li>â€¢ <strong>Offline First:</strong> Volle FunktionalitÃ¤t ohne Internet</li>
                            <li>â€¢ IndexedDB fÃ¼r lokale Speicherung</li>
                            <li>â€¢ <strong>Browser-Support:</strong> Chrome, Firefox, Edge</li>
                            <li>â€¢ Safari, Brave, Opera kompatibel</li>
                            <li>â€¢ Progressive Web App (PWA) Ready</li>
                        </ul>
                    </div>
                    <div class="bg-gray-800/30 border border-gray-700 p-3 rounded">
                        <h4 class="font-bold text-gray-200 text-xs mb-2">âš¡ Performance & Speicher</h4>
                        <ul class="text-xs text-gray-400 space-y-1">
                            <li>â€¢ Speicheroptimiert (< 100 MB RAM)</li>
                            <li>â€¢ Streaming-basierte Verarbeitung</li>
                            <li>â€¢ Chunk-basierte Aufnahme (10 Sek.)</li>
                            <li>â€¢ Lazy Loading von Audio-Daten</li>
                            <li>â€¢ Effiziente IndexedDB-Nutzung</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- TECHNICAL SPECS -->
            <div class="mt-6 space-y-3">
                <h3 class="font-bold text-gray-200 uppercase tracking-wide text-sm border-b border-gray-700 pb-2">
                    Technische Spezifikationen</h3>
                <div class="grid grid-cols-2 gap-2 text-xs">
                    <div class="bg-gray-800/30 p-2 rounded border border-gray-700">
                        <span class="text-gray-400">Frontend:</span>
                        <span class="text-gray-200 ml-2">HTML5, Tailwind CSS</span>
                    </div>
                    <div class="bg-gray-800/30 p-2 rounded border border-gray-700">
                        <span class="text-gray-400">Backend:</span>
                        <span class="text-gray-200 ml-2">Python 3.13+, FastAPI</span>
                    </div>
                    <div class="bg-gray-800/30 p-2 rounded border border-gray-700">
                        <span class="text-gray-400">Storage:</span>
                        <span class="text-gray-200 ml-2">IndexedDB (Client)</span>
                    </div>
                    <div class="bg-gray-800/30 p-2 rounded border border-gray-700">
                        <span class="text-gray-400">Audio API:</span>
                        <span class="text-gray-200 ml-2">Web Audio API</span>
                    </div>
                    <div class="bg-gray-800/30 p-2 rounded border border-gray-700">
                        <span class="text-gray-400">Service Worker:</span>
                        <span class="text-gray-200 ml-2">Background Sync</span>
                    </div>
                    <div class="bg-gray-800/30 p-2 rounded border border-gray-700">
                        <span class="text-gray-400">Recorder:</span>
                        <span class="text-gray-200 ml-2">MediaRecorder API</span>
                    </div>
                </div>
            </div>

            <!-- PLANNED FEATURES -->
            <div class="mt-6 bg-gray-800/30 border border-gray-700 p-4 rounded">
                <h3 class="font-bold text-gray-200 mb-2 text-sm uppercase tracking-wide flex items-center gap-2">
                    <span aria-hidden="true">ðŸš€</span> Geplante Features (Roadmap)
                </h3>
                <ul class="space-y-2 text-xs text-gray-400">
                    <li class="flex items-start gap-2">
                        <span class="text-cyan-400 mt-0.5">â–¸</span>
                        <div><strong class="text-gray-200">WebComponent-Integration:</strong> Standalone Component fÃ¼r
                            Angular, React, Vue.js</div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-cyan-400 mt-0.5">â–¸</span>
                        <div><strong class="text-gray-200">Multi-Language Support:</strong> Deutsch, English, FranÃ§ais,
                            EspaÃ±ol, Italiano</div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-cyan-400 mt-0.5">â–¸</span>
                        <div><strong class="text-gray-200">Authentifizierung & Sicherheit:</strong> OAuth2, SAML, JWT,
                            End-to-End Encryption</div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-cyan-400 mt-0.5">â–¸</span>
                        <div><strong class="text-gray-200">Collaborative Recording:</strong> Multi-User Sessions,
                            Real-Time Collaboration</div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-cyan-400 mt-0.5">â–¸</span>
                        <div><strong class="text-gray-200">Theme Engine:</strong> Light/Dark Mode, Custom Color Schemes,
                            Skins</div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-cyan-400 mt-0.5">â–¸</span>
                        <div><strong class="text-gray-200">Advanced Effects:</strong> Reverb, Delay, Compressor,
                            Limiter, Noise Gate</div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-cyan-400 mt-0.5">â–¸</span>
                        <div><strong class="text-gray-200">Multi-Track Recording:</strong> Parallele Aufnahme mehrerer
                            Spuren</div>
                    </li>
                </ul>
            </div>

            <!-- PREVIEW WARNING -->
            <div class="mt-6 bg-gray-800/30 border border-gray-700 p-4 rounded">
                <h3 class="font-bold text-gray-200 mb-3 text-sm uppercase tracking-wide">
                    Preview Version - Limitations
                </h3>
                <p class="text-sm text-gray-300 mb-3">
                    This is a preview version to demonstrate core functionality. The following features are currently
                    <strong>not implemented</strong>:
                </p>
                <ul class="space-y-2 text-xs text-gray-400">
                    <li class="flex items-start gap-2">
                        <span class="text-gray-500 mt-0.5">â–¸</span>
                        <div><strong class="text-gray-200">Authentication:</strong> No login system, no user accounts
                        </div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-gray-500 mt-0.5">â–¸</span>
                        <div><strong class="text-gray-200">Authorization:</strong> No role or permission management
                        </div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-gray-500 mt-0.5">â–¸</span>
                        <div><strong class="text-gray-200">Encryption:</strong> Data transmission is per TLS/SSL
                            encrypted, however no encrypted contents in local browser databases</div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-gray-500 mt-0.5">â–¸</span>
                        <div><strong class="text-gray-200">Framework Integration:</strong> WebComponent for
                            Angular/React not yet available</div>
                    </li>
                </ul>
                <div class="mt-3 pt-3 border-t border-gray-700">
                    <p class="text-xs text-gray-400">âš  This version is exclusively for testing and demonstration
                        purposes and not suitable for production use.</p>
                </div>
            </div>

            <!-- LICENSE -->
            <div class="mt-6 bg-gray-800/30 border border-gray-700 p-4 rounded">
                <h3 class="font-bold text-gray-200 uppercase tracking-wide text-sm border-b border-gray-700 pb-2 mb-4">
                    Lizenz & Nutzungsrechte</h3>

                <div class="space-y-3 text-sm text-gray-300">
                    <div>
                        <h4 class="font-bold text-gray-200 mb-1">Herausgeber</h4>
                        <p class="text-xs">Nina Ennekes<br>
                            <a href="https://www.xing.com/profile/Nina_Ennekes" target="_blank"
                                rel="noopener noreferrer"
                                class="text-cyan-400 hover:underline">https://www.xing.com/profile/Nina_Ennekes</a><br>
                            <span class="text-gray-500">Â© 2025 All Rights Reserved</span>
                        </p>
                    </div>

                    <div class="pt-2 border-t border-gray-700">
                        <h4 class="font-bold text-gray-200 mb-2">Business Source License 1.1</h4>
                        <p class="text-xs text-gray-400 mb-3">Diese Software unterliegt der Business Source License 1.1
                            mit Dual-Lizenzierungsoptionen.</p>

                        <div class="space-y-2 text-xs">
                            <div>
                                <strong class="text-gray-150">A) Nicht-kommerzielle Nutzung â€“ Apache 2.0</strong>
                                <p class="text-gray-400 mt-1">Die Software darf fÃ¼r nicht-kommerzielle Zwecke (privat,
                                    Forschung, Bildung) unter der Apache License 2.0 genutzt werden.</p>
                            </div>

                            <div class="pt-2 border-t border-gray-700">
                                <strong class="text-gray-150">B) Kommerzielle Nutzung â€“ Business Source License
                                    1.1</strong>
                                <div class="space-y-1 text-gray-400 mt-1">
                                    <div><span class="text-gray-300">Unmodifiziert:</span> Die Software darf unverÃ¤ndert
                                        fÃ¼r kommerzielle Zwecke frei eingesetzt werden.</div>
                                    <div><span class="text-gray-300">Open-Source Umsetzung:</span> Neue Anforderungen
                                        und Pull-Requests kÃ¶nnen nach Ermessen des Autors kostenlos umgesetzt werden.
                                    </div>
                                    <div><span class="text-gray-300">Mit Modifikationen:</span> Jede externe Ã„nderung
                                        oder Anpassung erfordert die Zustimmung des Authors und ggf. eine separate,
                                        kommerzielle Lizenz zur freien Nutzung.</div>
                                </div>
                            </div>

                            <div class="pt-2 border-t border-gray-700">
                                <strong class="text-gray-150">Change Date & Change License</strong>
                                <p class="text-gray-400 mt-1">Vier Jahre nach der ersten Ã¶ffentlichen VerÃ¶ffentlichung
                                    werden die Rechte automatisch auf Apache License 2.0 Ã¼bergeleitet.</p>
                            </div>
                        </div>
                    </div>

                    <div class="pt-2 border-t border-gray-700">
                        <strong class="text-gray-150">Haftungsausschluss</strong>
                        <p class="text-xs text-gray-400 mt-1">Die Software wird â€žwie besehen" (AS-IS) ohne jegliche
                            GewÃ¤hrleistung bereitgestellt. Der Lizenzgeber haftet nicht fÃ¼r direkte, indirekte oder
                            FolgeschÃ¤den aus der Nutzung.</p>
                    </div>
                </div>
            </div>

            <!-- OPEN SOURCE DEPENDENCIES -->
            <div class="mt-6 bg-gray-800/30 border border-gray-700 p-4 rounded">
                <h3 class="font-bold text-gray-200 uppercase tracking-wide text-sm border-b border-gray-700 pb-2 mb-4">
                    Open Source AbhÃ¤ngigkeiten & Lizenzen</h3>
                
                <p class="text-xs text-gray-400 mb-4">WaveForge Pro verwendet die folgenden Open-Source-Bibliotheken und Komponenten:</p>
                
                <!-- Scrollable Dependencies List -->
                <div class="max-h-64 overflow-y-auto bg-black/30 border border-gray-700 rounded p-3 space-y-3">
                    
                    <!-- Frontend Libraries -->
                    <div class="border-b border-gray-700 pb-3">
                        <div class="flex justify-between items-start mb-1">
                            <h4 class="font-bold text-gray-200 text-xs">Tailwind CSS</h4>
                            <span class="text-[10px] px-2 py-0.5 bg-blue-900/30 text-blue-400 rounded border border-blue-700">MIT License</span>
                        </div>
                        <p class="text-[10px] text-gray-400 mb-1">Utility-first CSS framework</p>
                        <a href="https://tailwindcss.com/" target="_blank" rel="noopener noreferrer" 
                           class="text-[10px] text-cyan-400 hover:underline">https://tailwindcss.com/</a>
                    </div>
                    
                    <div class="border-b border-gray-700 pb-3">
                        <div class="flex justify-between items-start mb-1">
                            <h4 class="font-bold text-gray-200 text-xs">TUS JavaScript Client</h4>
                            <span class="text-[10px] px-2 py-0.5 bg-blue-900/30 text-blue-400 rounded border border-blue-700">MIT License</span>
                        </div>
                        <p class="text-[10px] text-gray-400 mb-1">Resumable file upload protocol</p>
                        <a href="https://github.com/tus/tus-js-client" target="_blank" rel="noopener noreferrer" 
                           class="text-[10px] text-cyan-400 hover:underline">https://github.com/tus/tus-js-client</a>
                    </div>

                    <!-- Backend Dependencies -->
                    <div class="border-b border-gray-700 pb-3">
                        <div class="flex justify-between items-start mb-1">
                            <h4 class="font-bold text-gray-200 text-xs">FastAPI</h4>
                            <span class="text-[10px] px-2 py-0.5 bg-blue-900/30 text-blue-400 rounded border border-blue-700">MIT License</span>
                        </div>
                        <p class="text-[10px] text-gray-400 mb-1">Modern, fast web framework for Python</p>
                        <a href="https://fastapi.tiangolo.com/" target="_blank" rel="noopener noreferrer" 
                           class="text-[10px] text-cyan-400 hover:underline">https://fastapi.tiangolo.com/</a>
                    </div>
                    
                    <div class="border-b border-gray-700 pb-3">
                        <div class="flex justify-between items-start mb-1">
                            <h4 class="font-bold text-gray-200 text-xs">Uvicorn</h4>
                            <span class="text-[10px] px-2 py-0.5 bg-blue-900/30 text-blue-400 rounded border border-blue-700">BSD-3-Clause</span>
                        </div>
                        <p class="text-[10px] text-gray-400 mb-1">ASGI web server implementation for Python</p>
                        <a href="https://www.uvicorn.org/" target="_blank" rel="noopener noreferrer" 
                           class="text-[10px] text-cyan-400 hover:underline">https://www.uvicorn.org/</a>
                    </div>
                    
                    <div class="border-b border-gray-700 pb-3">
                        <div class="flex justify-between items-start mb-1">
                            <h4 class="font-bold text-gray-200 text-xs">tusd (TUS Server)</h4>
                            <span class="text-[10px] px-2 py-0.5 bg-blue-900/30 text-blue-400 rounded border border-blue-700">MIT License</span>
                        </div>
                        <p class="text-[10px] text-gray-400 mb-1">Reference implementation of TUS protocol server</p>
                        <a href="https://github.com/tus/tusd" target="_blank" rel="noopener noreferrer" 
                           class="text-[10px] text-cyan-400 hover:underline">https://github.com/tus/tusd</a>
                    </div>

                    <!-- Web APIs -->
                    <div class="border-b border-gray-700 pb-3">
                        <div class="flex justify-between items-start mb-1">
                            <h4 class="font-bold text-gray-200 text-xs">Web Audio API</h4>
                            <span class="text-[10px] px-2 py-0.5 bg-green-900/30 text-green-400 rounded border border-green-700">W3C Standard</span>
                        </div>
                        <p class="text-[10px] text-gray-400 mb-1">Browser-native audio processing</p>
                        <a href="https://www.w3.org/TR/webaudio/" target="_blank" rel="noopener noreferrer" 
                           class="text-[10px] text-cyan-400 hover:underline">https://www.w3.org/TR/webaudio/</a>
                    </div>
                    
                    <div class="border-b border-gray-700 pb-3">
                        <div class="flex justify-between items-start mb-1">
                            <h4 class="font-bold text-gray-200 text-xs">MediaRecorder API</h4>
                            <span class="text-[10px] px-2 py-0.5 bg-green-900/30 text-green-400 rounded border border-green-700">W3C Standard</span>
                        </div>
                        <p class="text-[10px] text-gray-400 mb-1">Browser-native media recording</p>
                        <a href="https://www.w3.org/TR/mediastream-recording/" target="_blank" rel="noopener noreferrer" 
                           class="text-[10px] text-cyan-400 hover:underline">https://www.w3.org/TR/mediastream-recording/</a>
                    </div>
                    
                    <div class="border-b border-gray-700 pb-3">
                        <div class="flex justify-between items-start mb-1">
                            <h4 class="font-bold text-gray-200 text-xs">IndexedDB API</h4>
                            <span class="text-[10px] px-2 py-0.5 bg-green-900/30 text-green-400 rounded border border-green-700">W3C Standard</span>
                        </div>
                        <p class="text-[10px] text-gray-400 mb-1">Browser-native database for offline storage</p>
                        <a href="https://www.w3.org/TR/IndexedDB/" target="_blank" rel="noopener noreferrer" 
                           class="text-[10px] text-cyan-400 hover:underline">https://www.w3.org/TR/IndexedDB/</a>
                    </div>
                    
                    <div>
                        <div class="flex justify-between items-start mb-1">
                            <h4 class="font-bold text-gray-200 text-xs">Service Worker API</h4>
                            <span class="text-[10px] px-2 py-0.5 bg-green-900/30 text-green-400 rounded border border-green-700">W3C Standard</span>
                        </div>
                        <p class="text-[10px] text-gray-400 mb-1">Background sync and offline capabilities</p>
                        <a href="https://www.w3.org/TR/service-workers/" target="_blank" rel="noopener noreferrer" 
                           class="text-[10px] text-cyan-400 hover:underline">https://www.w3.org/TR/service-workers/</a>
                    </div>
                    
                </div>
                
                <div class="mt-3 pt-3 border-t border-gray-700">
                    <p class="text-[10px] text-gray-400">
                        <strong class="text-gray-300">Hinweis:</strong> Alle genannten Bibliotheken und Standards werden 
                        gemÃ¤ÃŸ ihren jeweiligen Lizenzbedingungen verwendet. VollstÃ¤ndige Lizenztexte finden Sie in den 
                        entsprechenden Repositories oder auf den verlinkten Websites.
                    </p>
                </div>
            </div>

            <!-- FOOTER -->
            <div class="mt-8 text-center pt-4 border-t border-gray-800">
                <p class="text-[10px] text-gray-500 font-mono mb-2">Â© 2025 Nina Ennekes. All Rights Reserved.</p>
                <p class="text-[9px] text-gray-600 mb-4">Version 1.0.0-preview | Build 2025.11.27</p>
                <button onclick="closeInfoModal()"
                    class="px-6 py-2 rounded border border-cyan-600/50 text-cyan-400 hover:bg-cyan-600/10 text-xs font-bold tracking-wider"
                    aria-label="Informationen schlieÃŸen" type="button">SCHLIESSEN</button>
            </div>
        </div>
    </div>

    <!-- DELETE CONFIRMATION MODAL -->
    <div id="deleteModal" class="modal-overlay delete-modal" aria-hidden="true">
        <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="deleteModalTitle" aria-describedby="deleteModalDesc">
            <h2 id="deleteModalTitle"
                class="text-xl font-bold text-red-500 mb-4 border-b border-red-900 pb-2 flex items-center gap-2" tabindex="0">
                <span aria-hidden="true">âš </span> DELETE RECORDING
            </h2>
            <p id="deleteModalDesc" class="text-sm text-gray-300 mb-4">
                Are you sure you want to delete this recording?
            </p>

            <div class="bg-red-900/20 border border-red-900/50 p-3 rounded mb-6">
                <div class="text-[10px] text-red-400 font-mono mb-1">RECORDING NAME:</div>
                <div id="deleteRecordingName" class="text-xs font-mono text-white truncate">...</div>
            </div>

            <div class="flex gap-3 justify-end">
                <button onclick="closeDeleteModal()" class="cancel-btn text-sm" aria-label="Abbrechen"
                    type="button" tabindex="0">CANCEL</button>
                <button onclick="confirmDelete()" class="delete-btn text-sm" aria-label="LÃ¶schen bestÃ¤tigen"
                    type="button" tabindex="0">DELETE</button>
            </div>
        </div>
    </div>

    <!-- Notification Toast -->
    <div id="toast"
        class="fixed bottom-10 left-1/2 transform -translate-x-1/2 bg-gray-900/90 border border-cyan-500 text-cyan-400 px-6 py-3 rounded-full shadow-[0_0_20px_rgba(0,243,255,0.2)] transition-all duration-300 opacity-0 translate-y-10 z-[200] font-mono text-sm pointer-events-none">
        Notification
    </div>

    <script>
        // --- 1. RUNTIME ENVIRONMENT DETECTION ---
        
        const RuntimeEnvironment = {
            isFileProtocol: location.protocol === 'file:',
            isLocalhost: ['localhost', '127.0.0.1', ''].includes(location.hostname),
            isHTTP: location.protocol.startsWith('http'),
            
            // Feature availability based on protocol
            features: {
                serviceWorker: false,
                backgroundSync: false,
                cloudUpload: false,
                serverFetch: false,
                localRecording: true,
                localPlayback: true,
                localStorage: true,
                downloadBlob: true
            },
            
            init: function() {
                // Detect available features based on protocol
                if (this.isHTTP) {
                    // Full feature set for HTTP(S)
                    this.features.serviceWorker = 'serviceWorker' in navigator;
                    this.features.backgroundSync = 'serviceWorker' in navigator && 'sync' in ServiceWorkerRegistration.prototype;
                    this.features.cloudUpload = true;
                    this.features.serverFetch = true;
                    console.log('ðŸŒ HTTP Mode: All features enabled');
                } else if (this.isFileProtocol) {
                    // Limited feature set for file://
                    console.warn('ðŸ“ FILE Mode: Running with limited features (no cloud sync)');
                    console.log('âœ… Available: Recording, Playback, EQ, Visualizer, Local Storage, Download');
                    console.log('âŒ Disabled: Service Worker, Background Sync, Cloud Upload');
                    this.showFileProtocolWarning();
                }
                
                return this.features;
            },
            
            showFileProtocolWarning: function() {
                // Show persistent warning banner for file:// mode
                const banner = document.createElement('div');
                banner.id = 'fileProtocolBanner';
                banner.className = 'fixed top-0 left-0 right-0 bg-yellow-900/90 border-b-2 border-yellow-500 text-yellow-200 px-4 py-2 z-[9999] text-center text-sm font-mono';
                banner.innerHTML = `
                    <span class="font-bold">âš  OFFLINE MODE:</span> 
                    Running from file:// - Cloud features disabled. 
                    <a href="#" onclick="RuntimeEnvironment.showOfflineModeHelp(); return false;" 
                       class="underline hover:text-yellow-100 ml-2">Learn more</a>
                `;
                document.body.insertBefore(banner, document.body.firstChild);
                
                // Adjust body padding to prevent content overlap
                document.body.style.paddingTop = '40px';
            },
            
            showOfflineModeHelp: function() {
                const modal = document.getElementById('infoModal');
                if (modal) {
                    openInfoModal();
                    // Scroll to offline mode section
                    setTimeout(() => {
                        const offlineSection = document.getElementById('offlineModeInfo');
                        if (offlineSection) {
                            offlineSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            offlineSection.classList.add('bg-yellow-900/20');
                            setTimeout(() => offlineSection.classList.remove('bg-yellow-900/20'), 2000);
                        }
                    }, 300);
                }
            },
            
            canUseFeature: function(featureName) {
                return this.features[featureName] === true;
            }
        };
        
        // Initialize environment detection immediately
        let ENV;
        try {
            ENV = RuntimeEnvironment.init();
            console.log('âœ… RuntimeEnvironment initialized:', ENV);
        } catch (err) {
            console.error('âŒ RuntimeEnvironment initialization failed:', err);
            // Fallback to HTTP mode if initialization fails
            ENV = {
                serviceWorker: true,
                backgroundSync: true,
                cloudUpload: true,
                serverFetch: true,
                localRecording: true,
                localPlayback: true,
                localStorage: true,
                downloadBlob: true
            };
        }

        // --- 2. FEATURE FLAGS ---
        
        const FeatureFlags = {
            // Show live upload progress during recording
            SHOW_LIVE_UPLOAD_PROGRESS: true, // â† Set to false to disable
            
            // Only show indicator after X chunks (reduces noise for short recordings)
            LIVE_UPLOAD_MIN_CHUNKS: 3,
            
            // Auto-hide details after X seconds of inactivity
            LIVE_UPLOAD_AUTO_HIDE_SECONDS: 5
        };

        // --- 2. UTILS & UI LOGIC ---

        // DELETE MODAL VARIABLES
        let deleteModal = null;
        let trackToDelete = null;
        let currentPlaybackRate = 1.0;
        let crossfadeGainNode = null; // For smooth speed transitions

        // EMBEDDED SERVICE WORKER CODE TO FIX BLOB URL ISSUES & UPLOAD LOGIC
        const SW_CODE = `
            const DB_NAME = 'WaveForgeDB_V4';
            const DB_VERSION = 3;
            const STORE_UPLOAD_QUEUE = 'upload_queue';

            function openDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onsuccess = e => resolve(e.target.result);
                    request.onerror = e => reject(e);
                });
            }

            async function getUploadQueue(db) {
                return new Promise((resolve) => {
                    if (!db.objectStoreNames.contains(STORE_UPLOAD_QUEUE)) { resolve([]); return; }
                    const tx = db.transaction(STORE_UPLOAD_QUEUE, 'readonly');
                    const req = tx.objectStore(STORE_UPLOAD_QUEUE).getAll();
                    req.onsuccess = () => resolve(req.result);
                });
            }

            async function removeFromQueue(db, id) {
                const tx = db.transaction(STORE_UPLOAD_QUEUE, 'readwrite');
                tx.objectStore(STORE_UPLOAD_QUEUE).delete(id);
                return new Promise(resolve => tx.oncomplete = resolve);
            }

            async function broadcastStatus(msg) {
                const clients = await self.clients.matchAll();
                clients.forEach(client => client.postMessage(msg));
            }

            async function processUploads() {
                const db = await openDB();
                const queue = await getUploadQueue(db);
                if (queue.length === 0) return;
                queue.sort((a, b) => a.timestamp - b.timestamp || a.chunkIndex - b.chunkIndex);

                // Track unique sessions and their progress
                const sessionProgress = new Map();
                let lastLoggedSession = null;
                let processedCount = 0;

                for (const item of queue) {
                    try {
                        const formData = new FormData();
                        formData.append('session_id', String(item.fileId)); // Use session_id instead of file_id
                        formData.append('chunk_index', String(item.chunkIndex));
                        formData.append('file', item.blob, item.fileName);

                        // Only broadcast progress for active uploads (not already existing chunks)
                        broadcastStatus({ 
                            type: 'UPLOAD_PROGRESS', 
                            fileId: item.fileId, 
                            progress: (item.chunkIndex + 1) / item.totalChunks 
                        });

                        const response = await fetch('/upload/chunk', {
                            method: 'POST',
                            body: formData
                        });

                        if (!response.ok) throw new Error(\`Server error: \${response.status}\`);
                        
                        // Parse response to check if chunk already exists
                        const result = await response.json();
                        
                        // Remove from queue regardless of whether it was uploaded or already existed
                        if (result.status === 'chunk_already_exists' || result.status === 'chunk_received') {
                            await removeFromQueue(db, item.id);
                            processedCount++;
                            
                            // Track session progress for logging
                            if (!sessionProgress.has(item.fileId)) {
                                sessionProgress.set(item.fileId, { 
                                    existing: 0, 
                                    uploaded: 0, 
                                    total: item.totalChunks 
                                });
                            }
                            
                            const progress = sessionProgress.get(item.fileId);
                            if (result.status === 'chunk_already_exists') {
                                progress.existing++;
                            } else {
                                progress.uploaded++;
                            }
                            
                            // Log summary once per session (only if chunks already existed)
                            if (lastLoggedSession !== item.fileId && progress.existing > 0) {
                                console.log(\`ðŸ“¦ Session \${item.fileId}: Skipping \${progress.existing} existing chunks, uploading remaining...\`);
                                lastLoggedSession = item.fileId;
                            }
                            
                            if (item.chunkIndex === item.totalChunks - 1) {
                                broadcastStatus({ type: 'UPLOAD_COMPLETE', fileId: item.fileId });
                            }
                        }
                    } catch (error) {
                        console.error("Upload failed for chunk", item.chunkIndex, error);
                        broadcastStatus({ type: 'UPLOAD_ERROR', fileId: item.fileId, error: error.message });
                        break; 
                    }
                }
                
                // Log final summary
                if (processedCount > 0) {
                    console.log(\`âœ“ Processed \${processedCount} chunks from upload queue\`);
                }
            }

            self.addEventListener('install', (event) => { self.skipWaiting(); });
            self.addEventListener('activate', (event) => { event.waitUntil(self.clients.claim()); });
            self.addEventListener('sync', (event) => { if (event.tag === 'audio-upload') event.waitUntil(processUploads()); });
            self.addEventListener('message', (event) => { if (event.data === 'TRIGGER_UPLOAD') processUploads(); });
        `;

        let toastTimeout;
        function showToast(msg, isError) {
            const toast = document.getElementById('toast');
            if (!toast) return;
            
            // Reset classes first
            toast.className = `fixed bottom-10 left-1/2 transform -translate-x-1/2 ${isError ? 'bg-red-900/90 border-red-500 text-red-400' : 'bg-gray-900/90 border-cyan-500 text-cyan-400'} px-6 py-3 rounded-lg shadow-[0_0_20px_rgba(0,243,255,0.2)] transition-all duration-300 z-[200] font-mono text-sm max-w-2xl opacity-100 translate-y-0`;
            toast.innerHTML = msg; // Support styled popups
            
            // Clear existing timeout
            clearTimeout(toastTimeout);
            
            // Hide after 5 seconds
            toastTimeout = setTimeout(() => {
                toast.classList.remove('opacity-100', 'translate-y-0');
                toast.classList.add('opacity-0', 'translate-y-10');
                
                // Completely hide after animation completes
                setTimeout(() => {
                    toast.style.display = 'none';
                }, 300); // Wait for transition
            }, 5000);
            
            // Make sure it's visible
            toast.style.display = 'block';
        }

        // === LIVE UPLOAD INDICATOR (Complete Redesign - UPLOAD Box with Click Handler) ===
        const LiveUploadIndicator = {
            element: null,
            tooltip: null,
            state: 'hidden',
            currentSessionId: null,
            currentChunk: 0,
            totalChunks: 0,
            uploadedChunks: 0,
            
            init: function() {
                try {
                    this.element = document.getElementById('liveUploadIndicator');
                    if (!this.element) {
                        console.warn('LiveUploadIndicator: Element not found');
                        return;
                    }
                    
                    // Create small tooltip balloon
                    this.tooltip = document.createElement('div');
                    this.tooltip.className = 'absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 bg-gray-900 border border-cyan-500 rounded px-3 py-1.5 text-[10px] whitespace-nowrap shadow-lg opacity-0 pointer-events-none transition-opacity duration-200 z-50';
                    this.tooltip.style.display = 'none';
                    this.element.parentElement.style.position = 'relative';
                    this.element.parentElement.appendChild(this.tooltip);
                    
                    // Show tooltip on hover
                    this.element.addEventListener('mouseenter', () => {
                        // Only show tooltip when there's actual recording activity (totalChunks > 0)
                        if ((this.state === 'uploading' || this.state === 'paused') && this.totalChunks > 0) {
                            this.tooltip.style.display = 'block';
                            setTimeout(() => this.tooltip.style.opacity = '1', 10);
                        }
                    });
                    this.element.addEventListener('mouseleave', () => {
                        this.tooltip.style.opacity = '0';
                        setTimeout(() => this.tooltip.style.display = 'none', 200);
                    });
                    
                    // Only disable for file:// protocol - show offline state when no recording active
                    if (window.location.protocol === 'file:' || (ENV && ENV.cloudUpload === false)) {
                        this.setState('disabled');
                    } else if (!navigator.onLine) {
                        this.setState('offline');
                    } else {
                        // Show offline state when no recording active (not disabled)
                        this.setState('offline');
                    }
                    
                    console.log('âœ… LiveUploadIndicator initialized with tooltip');
                } catch (err) {
                    console.error('LiveUploadIndicator.init error:', err);
                }
            },
            
            setState: function(state, chunkInfo) {
                try {
                    if (!this.element) return;
                    
                    this.state = state;
                    
                    // Update chunk info if provided
                    if (chunkInfo) {
                        this.currentChunk = chunkInfo.current || 0;
                        this.totalChunks = chunkInfo.total || 0;
                        this.updateTooltip();
                    }
                    
                    // Reset all classes
                    this.element.className = 'text-[10px] px-2 py-1 rounded border transition-all';
                    
                    const states = {
                        uploading: { 
                            classes: 'bg-cyan-900/30 text-cyan-400 border-cyan-500 shadow-[0_0_10px_rgba(0,243,255,0.3)] animate-pulse cursor-pointer hover:opacity-80',
                            label: 'Uploading chunks to server',
                            hidden: false
                        },
                        paused: { 
                            classes: 'bg-yellow-900/30 text-yellow-400 border-yellow-500 cursor-pointer hover:opacity-80',
                            label: 'Upload paused - server unavailable',
                            hidden: false
                        },
                        offline: { 
                            classes: 'bg-gray-800/30 text-gray-400 border-gray-600 cursor-pointer hover:opacity-80',
                            label: 'Waiting for recording',
                            hidden: false
                        },
                        disabled: { 
                            classes: 'bg-red-900/20 text-red-400 border-red-900 opacity-50 cursor-not-allowed',
                            label: 'Upload disabled in offline mode',
                            hidden: false
                        },
                        hidden: { 
                            classes: 'hidden',
                            label: '',
                            hidden: true
                        }
                    };
                    
                    const config = states[state];
                    if (config) {
                        this.element.className += ' ' + config.classes;
                        
                        if (config.hidden) {
                            this.element.classList.add('hidden');
                        } else {
                            this.element.classList.remove('hidden');
                        }
                        
                        if (config.label) {
                            this.element.setAttribute('aria-label', config.label);
                            this.element.title = config.label;
                        }
                        
                        if (state === 'disabled') {
                            this.element.disabled = true;
                        } else {
                            this.element.disabled = false;
                        }
                        
                        // Update button text based on state and whether recording is active
                        this.updateButtonText();
                    }
                } catch (err) {
                    console.error('LiveUploadIndicator.setState error:', err);
                }
            },
            
            updateButtonText: function() {
                try {
                    if (!this.element) return;
                    const span = this.element.querySelector('span');
                    if (!span) return;
                    
                    // Show "UPLOAD" when no recording active, or counts when recording
                    if (this.totalChunks === 0) {
                        span.textContent = 'UPLOAD';
                    } else {
                        span.textContent = `${this.uploadedChunks}/${this.totalChunks}`;
                    }
                } catch (err) {
                    console.error('LiveUploadIndicator.updateButtonText error:', err);
                }
            },
            
            updateTooltip: function() {
                try {
                    if (!this.tooltip) return;
                    
                    if (this.state === 'uploading') {
                        this.tooltip.innerHTML = `<span class="text-cyan-400">â¬†</span> <span class="text-green-400 font-bold">${this.uploadedChunks}</span>/<span class="text-white font-bold">${this.totalChunks}</span> Ã¼bertragen`;
                    } else if (this.state === 'paused') {
                        this.tooltip.innerHTML = `<span class="text-yellow-400">â¸</span> <span class="text-white font-bold">${this.uploadedChunks}/${this.totalChunks}</span> - Pausiert`;
                    } else if (this.state === 'offline') {
                        this.tooltip.innerHTML = `<span class="text-gray-400">ðŸ“¡</span> <span class="text-white font-bold">${this.uploadedChunks}/${this.totalChunks}</span> - Offline`;
                    }
                    
                    // Update button text as well
                    this.updateButtonText();
                } catch (err) {
                    console.error('LiveUploadIndicator.updateTooltip error:', err);
                }
            },
            
            updateProgress: function(currentChunk, totalChunks) {
                try {
                    // Only track generated chunks internally, don't show in UI
                    this.currentChunk = currentChunk;
                    if (totalChunks > this.totalChunks) {
                        this.totalChunks = totalChunks;
                        this.updateTooltip();
                    }
                } catch (err) {
                    console.error('LiveUploadIndicator.updateProgress error:', err);
                }
            },
            
            updateUploaded: function(uploadedCount, totalCount) {
                try {
                    this.uploadedChunks = uploadedCount;
                    if (totalCount && totalCount > 0) {
                        this.totalChunks = totalCount;
                    }
                    this.updateTooltip();
                    this.updateButtonText();
                    
                    // Change to uploading state when chunks are successfully uploading
                    // This includes transitions from disabled, offline, AND paused states
                    if (navigator.onLine && (this.state === 'disabled' || this.state === 'offline' || this.state === 'paused')) {
                        this.setState('uploading');
                    }
                } catch (err) {
                    console.error('LiveUploadIndicator.updateUploaded error:', err);
                }
            },
            
            showQueueInfo: async function() {
                try {
                    if (this.state === 'disabled' || this.state === 'hidden') return;
                    
                    const db = await new Promise((resolve, reject) => {
                        const req = indexedDB.open('WaveForgeDB_V4', 3);
                        req.onsuccess = e => resolve(e.target.result);
                        req.onerror = e => reject(e);
                    });
                    
                    if (!db.objectStoreNames.contains('upload_queue')) {
                        showToast('No uploads in queue', false);
                        return;
                    }
                    
                    const tx = db.transaction('upload_queue', 'readonly');
                    const store = tx.objectStore('upload_queue');
                    const allItems = await new Promise((resolve) => {
                        const req = store.getAll();
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => resolve([]);
                    });
                    
                    // Group by session
                    const sessions = {};
                    allItems.forEach(item => {
                        const sid = item.sessionId || item.fileId;
                        if (!sessions[sid]) {
                            sessions[sid] = {
                                chunks: [],
                                totalChunks: item.totalChunks || 0
                            };
                        }
                        sessions[sid].chunks.push(item.chunkIndex);
                    });
                    
                    // Build info HTML
                    let infoHTML = '<div class="bg-gray-900 border-2 border-cyan-500 rounded-lg p-4 max-w-md shadow-2xl text-left">';
                    infoHTML += '<h3 class="text-cyan-400 font-bold text-sm mb-3 flex items-center gap-2">';
                    infoHTML += '<span aria-hidden="true">ðŸ“¤</span> Upload Queue Status</h3>';
                    
                    if (Object.keys(sessions).length === 0) {
                        infoHTML += '<p class="text-gray-400 text-xs">No pending uploads</p>';
                    } else {
                        infoHTML += `<div class="space-y-3 text-xs">`;
                        infoHTML += `<div class="text-gray-300">Total Sessions: <span class="text-cyan-400 font-bold">${Object.keys(sessions).length}</span></div>`;
                        
                        for (const [sid, data] of Object.entries(sessions)) {
                            const pending = data.chunks.length;
                            const total = data.totalChunks || pending;
                            const uploaded = total - pending;
                            
                            infoHTML += `<div class="bg-gray-800 border border-gray-700 rounded p-3">`;
                            infoHTML += `<div class="font-mono text-gray-400 text-[10px] mb-2">Session: ${sid.substring(0, 20)}...</div>`;
                            infoHTML += `<div class="space-y-1">`;
                            infoHTML += `<div class="text-green-400">âœ“ Uploaded: <span class="font-bold">${uploaded}${total > 0 ? '/' + total : ''}</span> chunks</div>`;
                            infoHTML += `<div class="text-yellow-400">â³ Pending: <span class="font-bold">${pending}</span> chunks</div>`;
                            
                            // Show chunk indices (max 10)
                            const chunkList = data.chunks.sort((a, b) => a - b).slice(0, 10).join(', ');
                            const moreChunks = data.chunks.length > 10 ? ` ... +${data.chunks.length - 10} more` : '';
                            infoHTML += `<div class="text-gray-500 text-[10px] mt-2">Chunks: ${chunkList}${moreChunks}</div>`;
                            infoHTML += `</div></div>`;
                        }
                        
                        infoHTML += `</div>`;
                    }
                    
                    infoHTML += `<div class="mt-3 pt-3 border-t border-gray-700 text-[10px] text-gray-500">`;
                    infoHTML += `Status: <span class="${
                        this.state === 'uploading' ? 'text-cyan-400' : 
                        this.state === 'paused' ? 'text-yellow-400' : 
                        'text-gray-400'
                    } font-bold">${this.state.toUpperCase()}</span>`;
                    infoHTML += `</div></div>`;
                    
                    showToast(infoHTML, false);
                    
                } catch (err) {
                    console.error('Error showing queue info:', err);
                    showToast('Error loading queue info', true);
                }
            },
            
            onRecordingStart: function(sessionId) {
                try {
                    this.currentSessionId = sessionId;
                    this.uploadedChunks = 0;
                    this.totalChunks = 0;
                    
                    // Only disable for file:// mode - otherwise show appropriate state
                    if (window.location.protocol === 'file:' || (ENV && ENV.cloudUpload === false)) {
                        this.setState('disabled');
                    } else if (!navigator.onLine) {
                        this.setState('offline');
                    } else {
                        // Ready to start uploading when chunks arrive
                        this.setState('uploading');
                    }
                } catch (err) {
                    console.error('LiveUploadIndicator.onRecordingStart error:', err);
                }
            },
            
            onRecordingStop: function() {
                try {
                    // Keep sessionId and don't hide indicator
                    // Box stays visible to show upload progress even after recording stops
                } catch (err) {
                    console.error('LiveUploadIndicator.onRecordingStop error:', err);
                }
            }
        };



        // === MODAL ACCESSIBILITY: Focus Trap & ESC Key Handler (BITV 2.0) ===
        let lastFocusedElement = null;
        
        /**
         * Traps focus within a modal dialog for keyboard navigation
         * @param {HTMLElement} modalElement - The modal container element
         */
        function trapFocus(modalElement) {
            const focusableElements = modalElement.querySelectorAll(
                'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
            );
            const firstElement = focusableElements[0];
            const lastElement = focusableElements[focusableElements.length - 1];

            modalElement.addEventListener('keydown', function(e) {
                if (e.key === 'Tab') {
                    if (e.shiftKey) {
                        // Shift + Tab
                        if (document.activeElement === firstElement) {
                            e.preventDefault();
                            lastElement.focus();
                        }
                    } else {
                        // Tab
                        if (document.activeElement === lastElement) {
                            e.preventDefault();
                            firstElement.focus();
                        }
                    }
                }
            });
        }

        /**
         * Global ESC key handler for all modals
         */
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                // Check which modal is currently open and close it
                const saveModal = document.getElementById('saveModal');
                const recoveryModal = document.getElementById('recoveryModal');
                const deleteModal = document.getElementById('deleteModal');
                const infoModal = document.getElementById('infoModal');
                const uploadSettingsModal = document.getElementById('uploadSettingsModal');

                if (saveModal && saveModal.style.display === 'flex') {
                    closeSaveModal();
                } else if (recoveryModal && recoveryModal.style.display === 'flex') {
                    // Recovery modal should not be closeable with ESC (critical action)
                    console.log('Recovery modal cannot be closed with ESC key');
                } else if (deleteModal && deleteModal.style.display === 'flex') {
                    closeDeleteModal();
                } else if (infoModal && infoModal.style.display === 'flex') {
                    closeInfoModal();
                } else if (uploadSettingsModal && uploadSettingsModal.style.display === 'flex') {
                    closeUploadSettingsModal();
                }
            }
        });

        const infoModal = document.getElementById('infoModal');
        function openInfoModal() {
            lastFocusedElement = document.activeElement; // Save current focus
            infoModal.style.display = 'flex';
            infoModal.setAttribute('aria-hidden', 'false');
            setTimeout(() => {
                infoModal.classList.add('modal-open');
                trapFocus(infoModal); // Enable focus trap
                // Focus modal title for screen readers
                const modalTitle = infoModal.querySelector('#infoModalTitle');
                if (modalTitle) modalTitle.focus();
            }, 10);
        }
        function closeInfoModal() {
            infoModal.classList.remove('modal-open');
            infoModal.setAttribute('aria-hidden', 'true');
            setTimeout(() => {
                infoModal.style.display = 'none';
                // Restore focus to element that opened the modal
                if (lastFocusedElement) {
                    lastFocusedElement.focus();
                    lastFocusedElement = null;
                }
            }, 200);
        }

        function updateFormatWarning() {
            const fmt = document.getElementById('recordingFormat').value;
            const w = document.getElementById('ramWarning');
            if (fmt === 'webm') {
                w.textContent = t('format.ramWarning');
                w.className = "text-[9px] font-mono text-green-400 pl-1";
            } else {
                w.textContent = t('format.ramWarningWav');
                w.className = "text-[9px] font-mono text-red-400 pl-1 animate-pulse";
            }
        }

        // --- SERVICE WORKER & UPLOAD MANAGER (NEW) ---
        const UploadManager = {
            retryInterval: null,
            register: async function () {
                // CRITICAL: Skip Service Worker registration in file:// mode
                if (ENV && ENV.serviceWorker === false) {
                    console.log('â­ï¸ Service Worker registration skipped (not available in current environment)');
                    return;
                }
                if ('serviceWorker' in navigator) {
                    try {
                        // Use external sw.js file instead of blob URL
                        const reg = await navigator.serviceWorker.register('/sw.js');
                        console.log('âœ“ Service Worker registered successfully:', reg);
                        await navigator.serviceWorker.ready;
                        console.log('âœ“ Service Worker is ready and active');

                        navigator.serviceWorker.addEventListener('message', (event) => {
                            const { type, sessionId, hasPendingChunks } = event.data;

                            // Update LiveUploadIndicator based on real server status
                            try {
                                if (type === 'UPLOAD_PROGRESS') {
                                    if (typeof LiveUploadIndicator !== 'undefined' && sessionId === LiveUploadIndicator.currentSessionId) {
                                        LiveUploadIndicator.setState('uploading');
                                    }
                                    if (sessionId) {
                                        UploadManager.setUploadStatusForSession(sessionId, 'uploading');
                                    }
                                } else if (type === 'UPLOAD_COMPLETE') {
                                    if (typeof LiveUploadIndicator !== 'undefined' && sessionId === LiveUploadIndicator.currentSessionId) {
                                        // Keep box visible but change to offline state after 2 seconds (not disabled)
                                        setTimeout(() => LiveUploadIndicator.setState('offline'), 2000);
                                    }
                                    if (sessionId) {
                                        UploadManager.setUploadStatusForSession(sessionId, 'success');
                                        setTimeout(() => {
                                            UploadManager.setUploadStatusForSession(sessionId, 'idle');
                                        }, 2000);
                                    }
                                    loadTracksFromDB();
                                } else if (type === 'UPLOAD_PENDING') {
                                    if (typeof LiveUploadIndicator !== 'undefined' && sessionId === LiveUploadIndicator.currentSessionId) {
                                        // Only set paused if we're currently uploading (don't override paused from UPLOAD_OFFLINE)
                                        if (LiveUploadIndicator.state === 'uploading' || LiveUploadIndicator.state === 'offline') {
                                            LiveUploadIndicator.setState('paused');
                                        }
                                    }
                                    // Silent pending state - chunks are retrying
                                    if (sessionId) {
                                        UploadManager.setUploadStatusForSession(sessionId, 'pending');
                                    }
                                } else if (type === 'UPLOAD_OFFLINE') {
                                    if (typeof LiveUploadIndicator !== 'undefined' && sessionId === LiveUploadIndicator.currentSessionId) {
                                        // CRITICAL: Set paused state and prevent it from being overridden
                                        LiveUploadIndicator.setState('paused');
                                        console.log('âš ï¸ Server unavailable - showing yellow paused indicator');
                                    }
                                    // Connection lost - show paused status (yellow indicator)
                                    if (sessionId) {
                                        UploadManager.setUploadStatusForSession(sessionId, 'pending');
                                    }
                                    console.log('ðŸ“¡ Upload paused - waiting for connection (checking every 5s)');
                                } else if (type === 'CONNECTION_RESTORED') {
                                    if (typeof LiveUploadIndicator !== 'undefined' && (LiveUploadIndicator.state === 'offline' || LiveUploadIndicator.state === 'paused')) {
                                        LiveUploadIndicator.setState('uploading');
                                    }
                                    console.log('âœ… Connection restored - resuming uploads');
                                } else if (type === 'CHUNK_UPLOADED') {
                                    // Update uploaded chunks count
                                    const { sessionId, chunkIndex, totalChunks } = event.data;
                                    if (typeof LiveUploadIndicator !== 'undefined' && sessionId === LiveUploadIndicator.currentSessionId) {
                                        const uploadedCount = (typeof chunkIndex === 'number') ? chunkIndex + 1 : parseInt(chunkIndex || 0) + 1;
                                        const total = totalChunks || LiveUploadIndicator.totalChunks || 0;
                                        LiveUploadIndicator.updateUploaded(uploadedCount, total);
                                        console.log(`ðŸ“¤ Chunk ${uploadedCount}/${total} uploaded for session ${sessionId}`);
                                    }
                                }
                            } catch (err) {
                                console.error('Service Worker message handler error:', err);
                            }
                        });

                        // START SMART RETRY LOOP
                        this.startRetryLoop();

                    } catch (err) {
                        console.error('SW reg failed', err);
                        console.warn("Service Workers disabled or not supported in this context.");
                    }
                }
            },
            startRetryLoop: function () {
                // Periodically check queue and trigger upload
                // This handles cases where server comes online LATER
                setInterval(async () => {
                    if (navigator.onLine) {
                        const db = await new Promise((resolve) => {
                            const req = indexedDB.open('WaveForgeDB_V4', 3);
                            req.onsuccess = e => resolve(e.target.result);
                            req.onerror = () => resolve(null);
                        });
                        if (db) {
                            if (db.objectStoreNames.contains('upload_queue')) {
                                const countReq = db.transaction('upload_queue', 'readonly').objectStore('upload_queue').count();
                                countReq.onsuccess = () => {
                                    if (countReq.result > 0) {
                                        // Items waiting! Trigger Sync.
                                        console.log(`ðŸ“¦ UploadManager: ${countReq.result} chunks in queue, triggering upload...`);
                                        this.triggerSync();
                                    }
                                }
                            }
                        }
                    }
                }, 30000); // Check every 30 seconds (reduced CPU usage)
            },
            queueUpload: async function (id, blob, fileName, metadata = {}, sessionId = null) {
                // CRITICAL: Block upload queue in file:// mode
                if (ENV && ENV.cloudUpload === false) {
                    console.warn('â­ï¸ Upload queue disabled in offline mode');
                    showToast('Upload not available in offline mode - use DL button', false);
                    return;
                }
                
                const CHUNK_SIZE = 1024 * 1024; // 1MB chunks
                const totalChunks = Math.ceil(blob.size / CHUNK_SIZE);

                // Use provided sessionId or generate new one for manual uploads
                const uploadSessionId = sessionId || `manual_${Date.now()}`;

                const db = await new Promise((resolve, reject) => {
                    const req = indexedDB.open('WaveForgeDB_V4', 3);
                    req.onsuccess = e => resolve(e.target.result);
                    req.onerror = e => reject(e);
                });

                const tx = db.transaction(['upload_queue'], 'readwrite');
                const store = tx.objectStore('upload_queue');

                for (let i = 0; i < totalChunks; i++) {
                    const start = i * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE, blob.size);
                    const chunk = blob.slice(start, end);
                    store.add({
                        id: `${id}_${i}`,
                        fileId: id,
                        fileName: fileName,
                        sessionId: uploadSessionId, // Add sessionId
                        chunkIndex: i,
                        totalChunks: totalChunks,
                        blob: chunk,
                        timestamp: Date.now(),
                        metadata: i === totalChunks - 1 ? metadata : null, // Only attach metadata to last chunk
                        retryCount: 0,
                        nextRetryAt: 0
                    });
                }

                tx.oncomplete = () => {
                    console.log(`âœ“ Queued ${totalChunks} chunks for upload (File: ${fileName}, Session: ${uploadSessionId}, ID: ${id})`);
                    console.log(`ðŸ“Š Queue IDs: ${Array.from({ length: totalChunks }, (_, i) => `${id}_${i}`).join(', ')}`);
                    showToast("Queued for background upload");
                    this.triggerSync();
                };
            },
            triggerSync: function () {
                console.log('â†’ Attempting to trigger upload...');
                if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    console.log('âœ“ Service Worker controller is active');
                    if ('SyncManager' in window) {
                        console.log('â†’ Using Background Sync API');
                        navigator.serviceWorker.ready.then(reg => {
                            return reg.sync.register('audio-upload');
                        }).catch(() => {
                            console.log('â†’ Fallback to postMessage');
                            navigator.serviceWorker.controller.postMessage('TRIGGER_UPLOAD');
                        });
                    } else {
                        console.log('â†’ Using postMessage (no Background Sync)');
                        navigator.serviceWorker.controller.postMessage('TRIGGER_UPLOAD');
                    }
                } else {
                    console.warn('âš  Service Worker controller not ready. Please reload the page.');
                    showToast('Service Worker not active. Reload the page!', true);
                }
                
                // Update upload status UI if element exists (legacy code)
                const uploadStatusEl = document.getElementById('uploadStatus');
                if (uploadStatusEl) {
                    uploadStatusEl.classList.remove('hidden');
                }
            },
            updateUI: function (fileId, progress) {
                const bar = document.getElementById(`progress-${fileId}`);
                if (bar) bar.style.width = `${progress * 100}%`;
            },
            sessionStatus: {}, // Track status per session

            setUploadStatusForSession: function (sessionId, status, chunkInfo) {
                // Update status tracking
                this.sessionStatus[sessionId] = status;
                
                // Update Live Upload Indicator
                const hasActiveUploads = Object.values(this.sessionStatus).some(s => s === 'uploading');
                if (typeof LiveUploadIndicator !== 'undefined') {
                    if (status === 'uploading' || hasActiveUploads) {
                        if (chunkInfo) {
                            LiveUploadIndicator.updateProgress(chunkInfo.current, chunkInfo.total);
                        } else {
                            LiveUploadIndicator.setState('uploading');
                        }
                    } else if (status === 'pending') {
                        LiveUploadIndicator.setState('paused');
                    } else if (status === 'offline') {
                        LiveUploadIndicator.setState('offline');
                    } else if (status === 'idle' || status === 'complete') {
                        // Change to disabled state if NO active uploads
                        if (!hasActiveUploads) {
                            LiveUploadIndicator.setState('disabled');
                        }
                    }
                }

                // Find icon for this session (stored in data-session-id attribute)
                const icon = document.querySelector(`.upload-icon[data-session-id="${sessionId}"]`);
                if (!icon) {
                    console.warn(`No upload icon found for session ${sessionId}`);
                    return;
                }

                // Remove all status classes
                icon.classList.remove('status-idle', 'status-uploading', 'status-pending', 'status-success', 'status-error');

                // Add current status class
                icon.classList.add(`status-${status}`);

                // Update icon content and title based on status
                if (status === 'uploading') {
                    icon.innerHTML = 'â†‘';
                    icon.title = 'Uploading...';
                } else if (status === 'pending') {
                    icon.innerHTML = 'â³';
                    icon.title = 'Upload pending, retrying...';
                } else if (status === 'success') {
                    icon.innerHTML = 'âœ“';
                    icon.title = 'Upload complete';
                } else if (status === 'error') {
                    icon.innerHTML = 'âš ';
                    icon.title = 'Click to retry upload';
                } else {
                    icon.innerHTML = 'â˜';
                    icon.title = 'Upload to server';
                }
            },

            setUploadStatus: function (status) {
                // Update Live Upload Indicator
                if (typeof LiveUploadIndicator !== 'undefined') {
                    if (status === 'uploading') {
                        LiveUploadIndicator.setState('uploading');
                    } else if (status === 'pending') {
                        LiveUploadIndicator.setState('paused');
                    } else if (status === 'offline') {
                        LiveUploadIndicator.setState('offline');
                    } else {
                        // Keep box visible with disabled state
                        LiveUploadIndicator.setState('disabled');
                    }
                }
                
                // Legacy function - update all icons (used for global events)
                const uploadIcons = document.querySelectorAll('.upload-icon');

                uploadIcons.forEach(icon => {
                    const sessionId = icon.getAttribute('data-session-id');
                    if (sessionId && this.sessionStatus[sessionId]) {
                        // Keep existing session-specific status
                        return;
                    }

                    // Remove all status classes
                    icon.classList.remove('status-idle', 'status-uploading', 'status-pending', 'status-success', 'status-error');
                    icon.classList.add(`status-${status}`);

                    if (status === 'uploading') {
                        icon.innerHTML = 'â†‘';
                        icon.title = 'Uploading...';
                    } else if (status === 'pending') {
                        icon.innerHTML = 'â³';
                        icon.title = 'Upload pending, retrying...';
                    } else if (status === 'success') {
                        icon.innerHTML = 'âœ“';
                        icon.title = 'Upload complete';
                    } else if (status === 'error') {
                        icon.innerHTML = 'âš ';
                        icon.title = 'Click to retry upload';
                    } else {
                        icon.innerHTML = 'â˜';
                        icon.title = 'Upload to server';
                    }
                });
            },
            // Debug tool: Inspect upload queue
            async inspectQueue() {
                try {
                    const db = await new Promise((resolve, reject) => {
                        const req = indexedDB.open('WaveForgeDB_V4', 3);
                        req.onsuccess = e => resolve(e.target.result);
                        req.onerror = e => reject(e);
                    });

                    if (!db.objectStoreNames.contains('upload_queue')) {
                        console.log('ðŸ“Š Upload queue is empty (store does not exist)');
                        return;
                    }

                    const tx = db.transaction('upload_queue', 'readonly');
                    const store = tx.objectStore('upload_queue');
                    const allItems = await new Promise((resolve) => {
                        const req = store.getAll();
                        req.onsuccess = () => resolve(req.result);
                    });

                    console.log(`ðŸ“Š Upload Queue Status: ${allItems.length} chunks total`);

                    if (allItems.length === 0) {
                        console.log('âœ… Queue is empty - all chunks uploaded!');
                        return;
                    }

                    // Group by session
                    const sessions = {};
                    allItems.forEach(item => {
                        const sid = item.sessionId || item.fileId;
                        if (!sessions[sid]) sessions[sid] = [];
                        sessions[sid].push(item);
                    });

                    console.table(Object.entries(sessions).map(([sid, chunks]) => ({
                        SessionID: sid,
                        Chunks: chunks.length,
                        ChunkIndices: chunks.map(c => c.chunkIndex).sort((a, b) => a - b).join(','),
                        MaxRetry: Math.max(...chunks.map(c => c.retryCount || 0)),
                        Status: chunks[0].nextRetryAt > Date.now() ? `Waiting ${Math.round((chunks[0].nextRetryAt - Date.now()) / 1000)}s` : 'Ready'
                    })));

                } catch (err) {
                    console.error('Error inspecting queue:', err);
                }
            }
        };

        // Global debug function - call inspectUploadQueue() in console to see queue status
        window.inspectUploadQueue = () => UploadManager.inspectQueue();

        // --- UPLOAD COORDINATOR (Background Sync & Status Management) ---
        const UploadCoordinator = {
            activeUploads: new Map(), // sessionId -> { method, progress, status, totalChunks, uploadedChunks }
            uploadLock: false,
            
            init: function() {
                console.log('ðŸŽ¯ UploadCoordinator initialized');
                
                // Listen for connection changes
                window.addEventListener('online', () => this.onConnectionRestored());
                window.addEventListener('offline', () => this.onConnectionLost());
                
                // Listen for Service Worker messages
                if (navigator.serviceWorker) {
                    navigator.serviceWorker.addEventListener('message', (event) => {
                        this.handleServiceWorkerMessage(event.data);
                    });
                }
                
                // Register Background Sync if supported
                if ('serviceWorker' in navigator && 'sync' in ServiceWorkerRegistration.prototype) {
                    console.log('âœ“ Background Sync API supported');
                } else {
                    console.warn('âš ï¸ Background Sync API not supported - uploads will use fallback');
                }
                
                // IMPORTANT: Load pending uploads from IndexedDB on page load
                this.loadPendingUploads();
            },
            
            loadPendingUploads: async function() {
                console.log('ðŸ” Checking for pending uploads...');
                
                try {
                    const db = await new Promise((resolve, reject) => {
                        const req = indexedDB.open('WaveForgeDB_V4', 3);
                        req.onsuccess = e => resolve(e.target.result);
                        req.onerror = e => reject(e);
                    });
                    
                    if (!db.objectStoreNames.contains('upload_queue')) {
                        console.log('âœ“ No upload queue found');
                        return;
                    }
                    
                    const tx = db.transaction('upload_queue', 'readonly');
                    const store = tx.objectStore('upload_queue');
                    const allItems = await new Promise((resolve) => {
                        const req = store.getAll();
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => resolve([]);
                    });
                    
                    if (allItems.length === 0) {
                        console.log('âœ“ No pending uploads');
                        return;
                    }
                    
                    // Group chunks by sessionId
                    const sessionChunks = {};
                    allItems.forEach(item => {
                        const sessionId = item.sessionId;
                        if (!sessionId) return;
                        
                        if (!sessionChunks[sessionId]) {
                            sessionChunks[sessionId] = {
                                chunks: [],
                                totalChunks: item.totalChunks || 0
                            };
                        }
                        sessionChunks[sessionId].chunks.push(item);
                    });
                    
                    // Register each session as an active upload
                    for (const [sessionId, data] of Object.entries(sessionChunks)) {
                        const uploadedChunks = 0; // Will be calculated by countUploadedChunks
                        const totalChunks = data.totalChunks || data.chunks.length;
                        
                        console.log(`ðŸ“¦ Found pending upload: ${sessionId} (${data.chunks.length} chunks in queue)`);
                        
                        // Register as uploading (will show paused if offline)
                        this.registerUpload(sessionId, 'custom', totalChunks);
                        
                        // Count actual uploaded chunks
                        await this.countUploadedChunks(sessionId);
                    }
                    
                    console.log(`âœ… Loaded ${Object.keys(sessionChunks).length} pending uploads`);
                    
                    // Trigger UI update for all active uploads IMMEDIATELY
                    // Reduced delay for faster visual feedback
                    setTimeout(() => {
                        console.log(`ðŸŽ¨ Triggering UI update for ${this.activeUploads.size} pending uploads`);
                        for (const sessionId of this.activeUploads.keys()) {
                            this.updateUI(sessionId);
                        }
                    }, 50);
                    
                } catch (err) {
                    console.error('Error loading pending uploads:', err);
                }
            },
            
            registerUpload: function(sessionId, method = 'custom', totalChunks = 0) {
                if (this.activeUploads.has(sessionId)) {
                    // Update totalChunks if it was previously 0
                    const upload = this.activeUploads.get(sessionId);
                    if (upload.totalChunks === 0 && totalChunks > 0) {
                        console.log(`ðŸ“ Updating totalChunks for ${sessionId}: ${totalChunks}`);
                        upload.totalChunks = totalChunks;
                        this.updateUI(sessionId);
                    } else {
                        console.log(`ðŸ“ Upload already registered: ${sessionId}`);
                    }
                    return;
                }
                
                const upload = {
                    method: method, // 'custom', 'tus', or 'manual'
                    progress: 0,
                    status: 'uploading', // uploading, paused, synced, failed
                    totalChunks: totalChunks,
                    uploadedChunks: 0,
                    startTime: Date.now(),
                    error: null
                };
                
                this.activeUploads.set(sessionId, upload);
                console.log(`ðŸ“ Registered ${method} upload for session: ${sessionId} (${totalChunks} chunks)`);
                this.updateUI(sessionId);
                
                // Register Background Sync if online
                if (navigator.onLine && method !== 'tus') {
                    this.registerBackgroundSync();
                }
            },
            
            updateProgress: function(sessionId, uploadedChunks, totalChunks) {
                const upload = this.activeUploads.get(sessionId);
                if (!upload) {
                    console.warn(`âš ï¸ Upload not registered: ${sessionId}`);
                    return;
                }
                
                upload.uploadedChunks = uploadedChunks;
                upload.totalChunks = totalChunks;
                upload.progress = totalChunks > 0 ? Math.round((uploadedChunks / totalChunks) * 100) : 0;
                
                // Only log significant progress changes (every 10%)
                if (upload.progress % 10 === 0 || upload.progress === 100) {
                    console.log(`ðŸ“Š Upload progress for ${sessionId}: ${upload.progress}% (${uploadedChunks}/${totalChunks})`);
                }
                
                this.updateUI(sessionId);
            },
            

            triggerAssembly: async function(sessionId, data) {
                try {
                    console.log(`ðŸ”§ Triggering assembly for session ${sessionId}`);
                    
                    // Get fileName and metadata from event data (sent by Service Worker before chunk deletion)
                    const fileName = data.fileName || `Recording.webm`;
                    const metadata = data.metadata || {};
                    
                    const formData = new FormData();
                    formData.append('session_id', sessionId);
                    formData.append('file_name', fileName);
                    formData.append('metadata', JSON.stringify(metadata));
                    
                    const response = await fetch('/recording/complete', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('âœ… Assembly completed:', result);
                        this.completeUpload(sessionId);
                    } else {
                        const errorText = await response.text();
                        console.error('âŒ Assembly failed:', response.status, errorText);
                        showToast(`Assembly failed: ${response.status}`, true);
                    }
                } catch (error) {
                    console.error('âŒ Error triggering assembly:', error);
                    showToast('Assembly failed - see console', true);
                }
            },
            
            completeUpload: function(sessionId) {
                const upload = this.activeUploads.get(sessionId);
                if (!upload) return;
                
                upload.status = 'synced';
                upload.progress = 100;
                console.log(`âœ… Upload completed: ${sessionId}`);
                this.updateUI(sessionId);
                
                // Remove from active uploads after 3 seconds (showing completion state briefly)
                setTimeout(() => {
                    this.activeUploads.delete(sessionId);
                    this.updateUI(sessionId);
                }, 3000);
            },
            
            failUpload: function(sessionId, error, isFatal = false) {
                const upload = this.activeUploads.get(sessionId);
                if (!upload) return;
                
                upload.status = 'failed';
                upload.error = error;
                upload.isFatal = isFatal;
                
                if (isFatal) {
                    console.error(`ðŸ’€ Fatal upload error for session ${sessionId}:`, error);
                } else {
                    console.warn(`âš ï¸ Temporary upload error for session ${sessionId}:`, error);
                }
                
                this.updateUI(sessionId);
            },
            
            onConnectionLost: function() {
                console.log('ðŸ“´ UploadCoordinator: Connection lost - pausing all uploads');
                
                // Pause all active uploads
                for (const [sessionId, upload] of this.activeUploads.entries()) {
                    if (upload.status === 'uploading') {
                        upload.status = 'paused';
                        this.updateUI(sessionId);
                    }
                }
            },
            
            onConnectionRestored: function() {
                console.log('ðŸŒ UploadCoordinator: Connection restored - resuming uploads');
                
                // Resume all paused uploads
                let hasResumed = false;
                for (const [sessionId, upload] of this.activeUploads.entries()) {
                    if (upload.status === 'paused') {
                        upload.status = 'uploading';
                        this.updateUI(sessionId);
                        hasResumed = true;
                    }
                }
                
                // Trigger upload processing if we have paused uploads
                if (hasResumed) {
                    this.registerBackgroundSync();
                    
                    // Also trigger Service Worker directly
                    if (navigator.serviceWorker && navigator.serviceWorker.controller) {
                        navigator.serviceWorker.controller.postMessage({
                            type: 'PROCESS_UPLOADS',
                            force: true
                        });
                    }
                }
            },
            
            handleServiceWorkerMessage: function(data) {
                const { type, sessionId, chunkId, totalChunks, error, fileName, isFatal } = data;
                
                switch (type) {
                    case 'CHUNK_UPLOADED':
                        // Count uploaded chunks for this session
                        this.countUploadedChunks(sessionId);
                        break;
                        
                    case 'SESSION_UPLOAD_COMPLETE':
                        // Only trigger assembly for MANUAL uploads (indicated by manualUpload flag in metadata)
                        // Live recordings handle assembly via mediaRecorder.onstop
                        if (data.metadata && data.metadata.manualUpload === true) {
                            console.log(`ðŸ“¦ Manual upload complete - triggering assembly for ${sessionId}`);
                            this.triggerAssembly(sessionId, data);
                        } else {
                            console.log(`ðŸ“¦ Live recording upload complete - ${sessionId} (assembly handled separately)`);
                            this.completeUpload(sessionId);
                        }
                        break;
                        
                    case 'ASSEMBLY_COMPLETE':
                        console.log(`âœ… Assembly completed for session ${sessionId}: ${fileName}`);
                        showToast(`Upload complete: ${fileName}`);
                        this.completeUpload(sessionId);
                        break;
                        
                    case 'UPLOAD_FATAL_ERROR':
                        this.failUpload(sessionId, error, true);
                        showToast(`Fatal upload error - manual download required`, true);
                        break;
                        
                    case 'UPLOAD_ERROR':
                        this.failUpload(sessionId, error, isFatal || false);
                        if (!isFatal) {
                            // Only show toast for temporary errors after multiple retries
                            // Fatal errors already handled above
                        }
                        break;
                        
                    case 'UPLOAD_PROGRESS':
                        if (sessionId) {
                            const upload = this.activeUploads.get(sessionId);
                            if (upload && upload.status !== 'uploading') {
                                upload.status = 'uploading';
                                this.updateUI(sessionId);
                            }
                        }
                        break;
                }
            },
            
            countUploadedChunks: async function(sessionId) {
                // Query IndexedDB to count remaining chunks
                try {
                    const db = await new Promise((resolve, reject) => {
                        const req = indexedDB.open('WaveForgeDB_V4', 3);
                        req.onsuccess = e => resolve(e.target.result);
                        req.onerror = e => reject(e);
                    });
                    
                    if (!db.objectStoreNames.contains('upload_queue')) return;
                    
                    const tx = db.transaction('upload_queue', 'readonly');
                    const store = tx.objectStore('upload_queue');
                    const allItems = await new Promise((resolve) => {
                        const req = store.getAll();
                        req.onsuccess = () => resolve(req.result);
                    });
                    
                    const sessionChunks = allItems.filter(item => item.sessionId === sessionId);
                    const upload = this.activeUploads.get(sessionId);
                    
                    if (upload) {
                        const remainingChunks = sessionChunks.length;
                        const uploadedChunks = upload.totalChunks - remainingChunks;
                        this.updateProgress(sessionId, uploadedChunks, upload.totalChunks);
                        
                        // If all chunks uploaded, mark complete
                        if (remainingChunks === 0) {
                            this.completeUpload(sessionId);
                        }
                    }
                } catch (err) {
                    console.error('Error counting uploaded chunks:', err);
                }
            },
            
            registerBackgroundSync: function() {
                if ('serviceWorker' in navigator && 'sync' in ServiceWorkerRegistration.prototype) {
                    navigator.serviceWorker.ready.then(registration => {
                        return registration.sync.register('upload-chunks');
                    }).then(() => {
                        console.log('ðŸ”„ Background Sync registered');
                    }).catch(err => {
                        console.warn('âš ï¸ Background Sync registration failed:', err);
                    });
                }
            },
            
            updateUI: function(sessionId) {
                const upload = this.activeUploads.get(sessionId);
                
                // Find all playlist items with this sessionId
                const playlistItems = document.querySelectorAll(`[data-session-id="${sessionId}"]`);
                
                playlistItems.forEach(item => {
                    // Remove existing badge
                    const existingBadge = item.querySelector('.upload-status-badge');
                    if (existingBadge) {
                        existingBadge.remove();
                    }
                    
                    // Get upload status container
                    const statusContainer = item.querySelector('.upload-status-expanded');
                    const uploadIcon = item.querySelector('.upload-icon');
                    
                    // Add new badge if upload exists
                    if (upload) {
                        const badge = document.createElement('span');
                        badge.className = `upload-status-badge status-${upload.status}`;
                        badge.setAttribute('role', 'status');
                        badge.setAttribute('aria-live', 'polite');
                        
                        let badgeText = '';
                        let ariaLabel = '';
                        
                        switch (upload.status) {
                            case 'uploading':
                                badgeText = `â‡ª ${upload.progress}%`;
                                ariaLabel = `Uploading ${upload.progress} percent`;
                                break;
                            case 'paused':
                                badgeText = 'â¸ PAUSED';
                                ariaLabel = 'Upload paused';
                                break;
                            case 'synced':
                                badgeText = 'âœ“ SYNCED';
                                ariaLabel = 'Upload synced';
                                break;
                            case 'failed':
                                badgeText = 'âŒ FAILED';
                                ariaLabel = `Upload failed: ${upload.error || 'Unknown error'}`;
                                badge.title = upload.error || 'Upload failed';
                                break;
                        }
                        
                        badge.textContent = badgeText;
                        badge.setAttribute('aria-label', ariaLabel);
                        
                        // Insert badge after the filename
                        const filenameElement = item.querySelector('.filename, .track-name');
                        if (filenameElement) {
                            filenameElement.insertAdjacentElement('afterend', badge);
                        }
                        
                        // Update upload icon status
                        if (uploadIcon) {
                            uploadIcon.classList.remove('status-idle', 'status-uploading', 'status-pending', 'status-success', 'status-error', 'status-fatal');
                            
                            if (upload.status === 'failed' && upload.isFatal) {
                                uploadIcon.classList.add('status-fatal');
                            } else if (upload.status === 'uploading') {
                                uploadIcon.classList.add('status-uploading');
                            } else if (upload.status === 'paused') {
                                uploadIcon.classList.add('status-pending');
                            } else if (upload.status === 'failed') {
                                uploadIcon.classList.add('status-error');
                            } else if (upload.status === 'synced') {
                                uploadIcon.classList.add('status-success');
                            }
                        }
                        
                        // Show expanded status for active/paused/failed uploads
                        if (statusContainer && (upload.status === 'uploading' || upload.status === 'paused' || upload.status === 'failed')) {
                            statusContainer.classList.add('active');
                            
                            let statusClass = '';
                            let iconClass = '';
                            let statusLabel = '';
                            let statusDetails = '';
                            let iconSymbol = 'â˜';
                            
                            if (upload.status === 'uploading') {
                                statusClass = '';
                                iconClass = 'uploading';
                                statusLabel = `Uploading ${upload.progress}%`;
                                statusDetails = `${upload.uploadedChunks} / ${upload.totalChunks} chunks uploaded`;
                                iconSymbol = 'â‡ª';
                            } else if (upload.status === 'paused') {
                                statusClass = 'paused';
                                iconClass = 'paused';
                                statusLabel = 'Upload Paused';
                                statusDetails = 'Connection lost - will resume automatically';
                                iconSymbol = 'â¸';
                            } else if (upload.status === 'failed' && upload.isFatal) {
                                statusClass = 'fatal';
                                iconClass = 'fatal';
                                statusLabel = 'Upload Failed (Fatal Error)';
                                statusDetails = 'Click icon for manual download instructions';
                                iconSymbol = 'âš ';
                            } else if (upload.status === 'failed') {
                                statusClass = 'paused';
                                iconClass = 'paused';
                                statusLabel = 'Upload Paused (Temporary Error)';
                                statusDetails = 'Will retry automatically';
                                iconSymbol = 'â¸';
                            }
                            
                            statusContainer.innerHTML = `
                                <div class="upload-progress-info ${statusClass}">
                                    <div class="upload-icon-large ${iconClass}" id="fatal-icon-${sessionId}">
                                        <span aria-hidden="true">${iconSymbol}</span>
                                    </div>
                                    <div class="upload-progress-text">
                                        <div class="upload-progress-label" style="color: ${iconClass === 'uploading' ? '#3b82f6' : iconClass === 'fatal' ? '#dc2626' : '#f59e0b'}">${statusLabel}</div>
                                        <div class="upload-progress-details">${statusDetails}</div>
                                    </div>
                                </div>
                            `;
                            
                            // Add click handler for fatal error
                            if (upload.isFatal) {
                                const fatalIcon = statusContainer.querySelector(`#fatal-icon-${sessionId}`);
                                if (fatalIcon) {
                                    fatalIcon.style.cursor = 'pointer';
                                    fatalIcon.onclick = () => this.showFatalErrorModal(sessionId, upload);
                                }
                            }
                        } else if (statusContainer) {
                            // Hide expanded status for completed/idle uploads
                            statusContainer.classList.remove('active');
                            statusContainer.innerHTML = '';
                        }
                    } else {
                        // No active upload - hide expanded status
                        if (statusContainer) {
                            statusContainer.classList.remove('active');
                            statusContainer.innerHTML = '';
                        }
                        
                        // Reset upload icon to idle state
                        if (uploadIcon) {
                            uploadIcon.classList.remove('status-idle', 'status-uploading', 'status-pending', 'status-success', 'status-error', 'status-fatal');
                        }
                    }
                });
            },
            
            showFatalErrorModal: function(sessionId, upload) {
                const modalHtml = `
                    <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10000;" id="fatal-error-modal">
                        <div style="background: linear-gradient(135deg, #1e1e2e 0%, #0a0a14 100%); padding: 30px; border-radius: 12px; max-width: 500px; border: 2px solid #dc2626; box-shadow: 0 0 30px rgba(220, 38, 38, 0.3);">
                            <h2 style="color: #dc2626; margin: 0 0 16px 0; font-size: 20px; font-weight: 700; display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 28px;">âš </span> Fatal Upload Error
                            </h2>
                            <div style="color: #d1d5db; margin-bottom: 20px; line-height: 1.6; font-size: 14px;">
                                <p style="margin: 0 0 12px 0;">The upload has encountered a fatal error and cannot be completed automatically.</p>
                                <p style="margin: 0 0 12px 0; padding: 12px; background: rgba(220, 38, 38, 0.1); border-left: 3px solid #dc2626; border-radius: 4px; font-family: monospace; font-size: 12px;">
                                    Error: ${upload.error || 'Unknown fatal error'}
                                </p>
                                <p style="margin: 0; font-weight: 600;">To save your recording:</p>
                                <ol style="margin: 8px 0 0 0; padding-left: 20px;">
                                    <li style="margin-bottom: 6px;">Click the <strong style="color: #10b981;">DL</strong> button to download the file to your computer</li>
                                    <li style="margin-bottom: 6px;">Manually upload the downloaded file to your cloud storage</li>
                                    <li>The file is safely stored in your browser and won't be lost</li>
                                </ol>
                            </div>
                            <button onclick="document.getElementById('fatal-error-modal').remove()" style="width: 100%; padding: 12px; background: #dc2626; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 14px; transition: background 0.2s;" onmouseover="this.style.background='#b91c1c'" onmouseout="this.style.background='#dc2626'">
                                OK, Understood
                            </button>
                        </div>
                    </div>
                `;
                
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = modalHtml;
                document.body.appendChild(tempDiv.firstElementChild);
            }
        };
        
        // Initialize UploadCoordinator
        UploadCoordinator.init();

        // Monitor connection status and auto-resume uploads
        window.addEventListener('online', async () => {
            console.log('ðŸŒ Connection restored - resetting retry delays for immediate upload');
            UploadManager.setUploadStatus('idle');
            
            // Update Live Upload Indicator
            if (typeof LiveUploadIndicator !== 'undefined') {
                if (LiveUploadIndicator.totalChunks === 0) {
                    LiveUploadIndicator.setState('offline');
                } else {
                    LiveUploadIndicator.setState('uploading');
                }
            }

            // CRITICAL: Reset retry delays for all pending chunks to trigger immediate retry
            try {
                const db = await new Promise((resolve, reject) => {
                    const req = indexedDB.open('WaveForgeDB_V4', 3);
                    req.onsuccess = e => resolve(e.target.result);
                    req.onerror = e => reject(e);
                });

                if (db.objectStoreNames.contains('upload_queue')) {
                    const tx = db.transaction('upload_queue', 'readwrite');
                    const store = tx.objectStore('upload_queue');
                    const getAllReq = store.getAll();
                    
                    getAllReq.onsuccess = async () => {
                        const items = getAllReq.result;
                        let resetCount = 0;
                        const now = Date.now();
                        
                        // Reset nextRetryAt for all items that have a retry delay
                        for (const item of items) {
                            if (item.nextRetryAt && item.nextRetryAt > now) {
                                item.nextRetryAt = 0;  // Retry immediately
                                item.retryCount = Math.max(0, (item.retryCount || 0) - 1); // Reduce retry count by 1
                                store.put(item);
                                resetCount++;
                            }
                        }
                        
                        tx.oncomplete = () => {
                            if (resetCount > 0) {
                                console.log(`ðŸ”„ Reset retry delays for ${resetCount} chunks - triggering immediate upload`);
                            } else {
                                console.log(`ðŸ“¦ Found ${items.length} chunks in queue (no retry delays to reset)`);
                            }
                            
                            // Trigger Service Worker to process uploads immediately
                            if (items.length > 0 && navigator.serviceWorker && navigator.serviceWorker.controller) {
                                navigator.serviceWorker.controller.postMessage('TRIGGER_UPLOAD');
                            }
                            
                            db.close();
                        };
                    };
                    
                    getAllReq.onerror = () => {
                        console.error('âŒ Failed to reset retry delays:', getAllReq.error);
                        db.close();
                    };
                } else {
                    db.close();
                }
            } catch (err) {
                console.error('âŒ Error resetting retry delays:', err);
            }
        });

        window.addEventListener('offline', () => {
            console.log('ðŸ“´ Connection lost, uploads will resume when online');
            UploadManager.setUploadStatus('pending');
            
            // Update Live Upload Indicator
            if (typeof LiveUploadIndicator !== 'undefined') {
                LiveUploadIndicator.setState('offline');
            }
        });

        // --- 2. CRASH GUARD RAID SYSTEM ---
        const DB_NAME = 'WaveForgeDB_V4';
        const DB_VERSION = 3;
        const STORE_RECORDINGS = 'recordings';
        const STORE_RECOVERY = 'recovery_chunks';
        const STORE_UPLOAD_QUEUE = 'upload_queue';

        let db = null;
        let currentSessionId = null;

        const CrashGuard = {
            init: async function () {
                const count = await this.checkOrphans();
                if (count > 0) this.showRecoveryUI();
            },
            generateSessionId: () => 'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            logChunk: function (blob) {
                if (!db || !currentSessionId) {
                    console.error(`âŒâŒâŒ CRITICAL: Cannot log chunk - db=${!!db}, sessionId=${!!currentSessionId}`);
                    console.error(`âŒâŒâŒ This chunk will be LOST! Blob size: ${blob?.size || 0} bytes`);
                    return;
                }

                // Get current chunk index
                if (!this.chunkCounter) this.chunkCounter = {};
                if (!this.chunkCounter[currentSessionId]) this.chunkCounter[currentSessionId] = 0;
                const chunkIndex = this.chunkCounter[currentSessionId]++;

                console.log(`ðŸŽ¤ Recording chunk ${chunkIndex} (${blob.size} bytes) for session ${currentSessionId}`);

                // Track chunks being generated for this session
                if (!this.chunksGenerating) this.chunksGenerating = {};
                if (!this.chunksGenerating[currentSessionId]) this.chunksGenerating[currentSessionId] = 0;
                this.chunksGenerating[currentSessionId]++;

                // Save to IndexedDB for crash recovery
                const transaction = db.transaction([STORE_RECOVERY], 'readwrite');
                transaction.objectStore(STORE_RECOVERY).add({
                    sessionId: currentSessionId,
                    timestamp: Date.now(),
                    blob: blob,
                    chunkIndex: chunkIndex
                });

                // Register upload with UploadCoordinator on first chunk
                if (chunkIndex === 0 && typeof UploadCoordinator !== 'undefined') {
                    UploadCoordinator.registerUpload(currentSessionId, 'custom', 0);
                }

                // AUTO UPLOAD: Upload chunk immediately to server in background
                this.uploadChunkLive(blob, currentSessionId, chunkIndex);
            },
            uploadChunkLive: async function (blob, sessionId, chunkIndex) {
                // CRITICAL: Skip live upload in file:// mode
                if (ENV && ENV.cloudUpload === false) {
                    console.log('â­ï¸ Live chunk upload skipped (cloud upload not available)');
                    return;
                }
                
                try {
                    const db = await new Promise((resolve, reject) => {
                        const req = indexedDB.open('WaveForgeDB_V4', 3);
                        req.onsuccess = e => resolve(e.target.result);
                        req.onerror = e => reject(e);
                    });

                    const chunkId = `${sessionId}_chunk_${chunkIndex}`;

                    // Check if chunk already exists in queue
                    const checkTx = db.transaction(['upload_queue'], 'readonly');
                    const existingChunk = await new Promise((resolve) => {
                        const req = checkTx.objectStore('upload_queue').get(chunkId);
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => resolve(null);
                    });

                    if (existingChunk) {
                        console.log(`â© Chunk ${chunkIndex} already in queue (session: ${sessionId}), skipping`);
                        return;
                    }

                    const tx = db.transaction(['upload_queue'], 'readwrite');
                    const store = tx.objectStore('upload_queue');

                    // Add chunk to upload queue with session-based structure
                    // Note: We don't have totalChunks yet - will be determined when recording completes
                    store.add({
                        id: chunkId,
                        sessionId: sessionId,
                        chunkIndex: chunkIndex,
                        blob: blob,
                        timestamp: Date.now(),
                        isLiveChunk: true,
                        retryCount: 0,
                        nextRetryAt: 0
                    });

                    tx.oncomplete = () => {
                        console.log(`ðŸ’¾ Chunk ${chunkIndex} saved to IndexedDB (session: ${sessionId})`);

                        // Trigger upload immediately for live chunks
                        // Chunk counting happens in ondataavailable event (above)
                        if (navigator.serviceWorker && navigator.serviceWorker.controller) {
                            navigator.serviceWorker.controller.postMessage('TRIGGER_UPLOAD');
                        }
                    };
                    
                    tx.onerror = (e) => {
                        console.error(`âŒâŒâŒ CRITICAL: Failed to save chunk ${chunkIndex} to IndexedDB queue:`, e);
                        console.error(`âŒ Error name: ${e?.target?.error?.name}`);
                        console.error(`âŒ Error message: ${e?.target?.error?.message}`);
                        console.error(`âŒ This chunk will be LOST!`);
                    };
                } catch (err) {
                    console.error(`âŒâŒâŒ CRITICAL: Live upload queuing exception for chunk ${chunkIndex}:`, err);
                    console.error(`âŒ Error name: ${err?.name}`);
                    console.error(`âŒ Error message: ${err?.message}`);
                    console.error(`âŒ Stack trace:`, err?.stack);
                    console.error(`âŒ This chunk will be LOST unless saved to recovery storage!`);
                }
            },
            waitForAllChunksUploaded: async function (sessionId, maxWaitMs = 120000) {
                const startTime = Date.now();
                let lastChunkCount = -1;
                let noProgressCount = 0;

                while (Date.now() - startTime < maxWaitMs) {
                    try {
                        const db = await new Promise((resolve, reject) => {
                            const req = indexedDB.open('WaveForgeDB_V4', 3);
                            req.onsuccess = e => resolve(e.target.result);
                            req.onerror = e => reject(e);
                        });

                        if (!db.objectStoreNames.contains('upload_queue')) {
                            console.log('âœ… No upload queue - all chunks uploaded');
                            return true;
                        }

                        const tx = db.transaction('upload_queue', 'readonly');
                        const store = tx.objectStore('upload_queue');
                        const allItems = await new Promise((resolve) => {
                            const req = store.getAll();
                            req.onsuccess = () => resolve(req.result);
                        });

                        const sessionChunks = allItems.filter(item => item.sessionId === sessionId);

                        if (sessionChunks.length === 0) {
                            console.log(`âœ… All chunks uploaded for session ${sessionId}`);
                            return true;
                        }

                        // Check for progress
                        if (sessionChunks.length === lastChunkCount) {
                            noProgressCount++;
                            if (noProgressCount >= 5) { // 10 seconds no progress (5 * 2s)
                                console.warn(`âš ï¸ No upload progress for 10 seconds - forcing unlock`);
                                // Force trigger Service Worker upload with unlock
                                if (navigator.serviceWorker && navigator.serviceWorker.controller) {
                                    navigator.serviceWorker.controller.postMessage({
                                        type: 'PROCESS_UPLOADS',
                                        force: true
                                    });
                                }
                                noProgressCount = 0; // Reset counter
                            }
                        } else {
                            noProgressCount = 0; // Reset on progress
                        }
                        lastChunkCount = sessionChunks.length;

                        console.log(`â³ Waiting for ${sessionChunks.length} chunks to upload...`);

                        // Trigger upload in case it's stuck
                        if (navigator.serviceWorker && navigator.serviceWorker.controller) {
                            navigator.serviceWorker.controller.postMessage('TRIGGER_UPLOAD');
                        }

                        // Wait 2 seconds before checking again
                        await new Promise(resolve => setTimeout(resolve, 2000));

                    } catch (err) {
                        console.error('Error checking upload queue:', err);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                }

                console.warn('âš ï¸ Timeout waiting for chunks to upload');
                return false;
            },
            signalRecordingComplete: async function (sessionId, fileName, metadata) {
                // CRITICAL: Skip server signal in file:// mode
                if (ENV && ENV.serverFetch === false) {
                    console.log('â­ï¸ Server signal skipped (not available in offline mode)');
                    showToast('Recording saved locally - cloud sync disabled in offline mode', false);
                    return;
                }
                
                console.log(`ðŸ“¢ Signaling recording complete for session ${sessionId}`);

                // CRITICAL: Wait for all chunks to upload first
                console.log('â³ Waiting for all chunks to upload before signaling server...');
                const allUploaded = await this.waitForAllChunksUploaded(sessionId);

                if (!allUploaded) {
                    console.error('âš ï¸ Not all chunks uploaded, but proceeding with assembly anyway');
                }

                // IMPORTANT: Add small delay to ensure server has finished writing chunks to disk
                console.log('â³ Waiting for server to finish writing chunks to disk...');
                await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay

                try {
                    const formData = new FormData();
                    formData.append('session_id', sessionId);
                    formData.append('file_name', fileName);
                    formData.append('metadata', JSON.stringify(metadata));

                    const response = await fetch('/recording/complete', {
                        method: 'POST',
                        body: formData
                    });

                    if (response.ok) {
                        const result = await response.json();
                        console.log('âœ“ Server acknowledged recording complete:', result);
                        showToast(`Upload complete: ${fileName}`);
                    } else {
                        const errorText = await response.text();
                        console.error('Server error:', response.status, errorText);
                        showToast(`Server error: ${response.status}`, true);
                        
                        // Queue for retry if server error
                        await this.queueRecordingComplete(sessionId, fileName, metadata);
                    }
                } catch (error) {
                    console.error('Error signaling recording complete:', error);
                    showToast('Upload queued - will retry when connection restored', false);
                    
                    // Queue the signal for retry when connection restored
                    await this.queueRecordingComplete(sessionId, fileName, metadata);
                }
            },
            queueRecordingComplete: async function (sessionId, fileName, metadata) {
                console.log(`ðŸ“¥ Queuing recording complete signal for session ${sessionId}`);
                
                try {
                    if (!navigator.serviceWorker.controller) {
                        console.error('No service worker controller available');
                        return;
                    }
                    
                    navigator.serviceWorker.controller.postMessage({
                        type: 'QUEUE_ASSEMBLY_SIGNAL',
                        sessionId: sessionId,
                        fileName: fileName,
                        metadata: metadata
                    });
                    
                    console.log('âœ“ Assembly signal queued for retry');
                } catch (err) {
                    console.error('Failed to queue assembly signal:', err);
                }
            },
            checkOrphans: function () {
                return new Promise((resolve) => {
                    if (!db) { resolve(0); return; }
                    const req = db.transaction([STORE_RECOVERY], 'readonly').objectStore(STORE_RECOVERY).count();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => resolve(0);
                });
            },
            showRecoveryUI: function () {
                const store = db.transaction([STORE_RECOVERY], 'readonly').objectStore(STORE_RECOVERY);
                const cursorReq = store.openCursor();
                let chunks = 0, size = 0, foundId = null;
                cursorReq.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                        chunks++; size += cursor.value.blob.size; foundId = cursor.value.sessionId; cursor.continue();
                    } else if (chunks > 0) {
                        document.getElementById('recoveryId').textContent = foundId;
                        document.getElementById('recoveryChunks').textContent = chunks;
                        document.getElementById('recoverySize').textContent = (size / 1024 / 1024).toFixed(2) + ' MB';
                        const modal = document.getElementById('recoveryModal');
                        modal.style.display = 'flex'; setTimeout(() => modal.classList.add('modal-open'), 10);
                    }
                };
            },
            assembleSession: async function (targetSessionId = null, isRecovery = false) {
                if (!db) { showToast("Database not initialized", true); return; }
                const req = db.transaction([STORE_RECOVERY], 'readonly').objectStore(STORE_RECOVERY).getAll();
                req.onsuccess = () => {
                    let chunks = req.result.sort((a, b) => a.timestamp - b.timestamp);
                    if (targetSessionId) chunks = chunks.filter(c => c.sessionId === targetSessionId);

                    if (chunks.length > 0) {
                        const blobParts = chunks.map(c => c.blob);
                        tempBlob = new Blob(blobParts, { type: preferredMimeType });

                        // CRITICAL: Set currentSessionId from recovered chunks
                        currentSessionId = chunks[0].sessionId;
                        console.log(`ðŸ“¦ Assembled ${chunks.length} chunks (session: ${currentSessionId})`);

                        // Close recovery modal immediately
                        if (isRecovery) {
                            document.getElementById('recoveryModal').classList.remove('modal-open');
                            setTimeout(() => document.getElementById('recoveryModal').style.display = 'none', 200);
                        }

                        // ALWAYS open save modal so user can save the recording
                        openSaveModal(isRecovery);
                        
                        // Store recovery info for later upload in confirmSave()
                        if (isRecovery) {
                            window.pendingRecoveryUpload = {
                                chunks: chunks,
                                sessionId: currentSessionId
                            };
                        }
                    } else {
                        showToast("Error: No data found to assemble", true);
                    }
                };
                req.onerror = () => {
                    showToast("Error reading recovery data", true);
                };
            },
            uploadAndAssembleRecoveredChunks: async function (chunks, sessionId, userName, userFormat) {
                try {
                    console.log('ðŸ“¥ Queuing recovered chunks for upload with name:', userName);
                    
                    // Queue all recovered chunks for upload (doesn't require server connection)
                    // Chunks are already in STORE_RECOVERY, just add to upload_queue
                    for (let i = 0; i < chunks.length; i++) {
                        await this.uploadChunkLive(chunks[i].blob, sessionId, i);
                    }
                    console.log('âœ“ All recovered chunks queued for upload');

                    // Detect mime type from first chunk or use global defaults
                    let mimeType = 'audio/webm;codecs=opus';
                    let extension = userFormat || 'webm';
                    
                    if (chunks.length > 0 && chunks[0].blob && chunks[0].blob.type) {
                        mimeType = chunks[0].blob.type;
                        if (!userFormat) {
                            if (mimeType.includes('webm')) extension = 'webm';
                            else if (mimeType.includes('mp4')) extension = 'mp4';
                            else if (mimeType.includes('ogg')) extension = 'ogg';
                        }
                    } else if (typeof preferredMimeType !== 'undefined') {
                        mimeType = preferredMimeType;
                        if (!userFormat) {
                            extension = preferredExt || 'webm';
                        }
                    }

                    const recoveredFileName = `${userName}.${extension}`;
                    const totalSize = chunks.reduce((sum, chunk) => sum + (chunk.blob?.size || 0), 0);
                    
                    const recoveredMetadata = {
                        name: userName,
                        mimeType: mimeType,
                        extension: extension,
                        recordingCompletedAt: new Date().toISOString(),
                        totalChunks: chunks.length,
                        fileSize: totalSize,
                        isRecovery: true
                    };

                    // Queue assembly signal for when server becomes available
                    console.log('ðŸ“¥ Queuing assembly signal for when server is available...');
                    await this.queueRecordingComplete(sessionId, recoveredFileName, recoveredMetadata);
                    
                    showToast('Recovery saved - will upload when server available', false);
                    console.log('âœ… Recovery queued successfully');

                    // Clean up STORE_RECOVERY (chunks are now in upload_queue)
                    this.clearSession(sessionId);
                } catch (err) {
                    console.error('Recovery queueing failed:', err);
                    throw err;
                }
            },
            discardSession: function () {
                if (!confirm("Are you sure? This data will be lost forever.")) return;
                
                // Get current sessionId before clearing
                const currentSessionId = this.currentSessionId;
                
                console.log('ðŸ—‘ï¸ DISCARD: Clearing all recovery data for session:', currentSessionId);
                
                // CRITICAL: Clear recovery store SYNCHRONOUSLY and COMPLETELY
                if (db) {
                    const tx = db.transaction([STORE_RECOVERY], 'readwrite');
                    const store = tx.objectStore(STORE_RECOVERY);
                    
                    // Clear ALL recovery data immediately
                    store.clear();
                    
                    tx.oncomplete = () => {
                        console.log('âœ… DISCARD: Recovery store cleared completely');
                    };
                    
                    tx.onerror = (e) => {
                        console.error('âŒ DISCARD: Failed to clear recovery store:', e);
                    };
                }
                
                // Also clear upload queue for this session
                if (currentSessionId) {
                    this.clearUploadQueue(currentSessionId);
                }
                
                document.getElementById('recoveryModal').classList.remove('modal-open');
                setTimeout(() => document.getElementById('recoveryModal').style.display = 'none', 200);
            },
            clearSession: function (sessionId) {
                if (!db) return;
                try {
                    // CRITICAL: Only clear recovery store, NOT upload queue!
                    // Upload queue will be cleared automatically by Service Worker after successful upload
                    // If we clear it here, chunks that are still uploading will be lost!
                    console.log(`ðŸ—‘ï¸ Clearing recovery chunks for session ${sessionId}`);
                    
                    const tx = db.transaction([STORE_RECOVERY], 'readwrite');
                    const store = tx.objectStore(STORE_RECOVERY);

                    // Check if index exists before using it
                    if (store.indexNames.contains('sessionId')) {
                        const index = store.index('sessionId');
                        index.openKeyCursor(IDBKeyRange.only(sessionId)).onsuccess = (e) => {
                            const cursor = e.target.result;
                            if (cursor) { store.delete(cursor.primaryKey); cursor.continue(); }
                        };
                    } else {
                        // Silently clear all recovery data if index doesn't exist
                        // This happens when database was cleared or is newly created
                        store.clear();
                    }
                    
                    // DO NOT CLEAR UPLOAD QUEUE HERE!
                    // Chunks are still being uploaded by Service Worker
                } catch (e) {
                    console.error('Error clearing session:', e);
                }
            },
            clearUploadQueue: async function (sessionId) {
                if (!db) return;
                try {
                    // Check if upload_queue store exists
                    if (!db.objectStoreNames.contains('upload_queue')) {
                        console.log('â­ï¸ Upload queue store does not exist yet');
                        return;
                    }
                    
                    const tx = db.transaction(['upload_queue'], 'readwrite');
                    const store = tx.objectStore('upload_queue');
                    const getAllReq = store.getAll();
                    
                    getAllReq.onsuccess = () => {
                        const items = getAllReq.result;
                        // FIX: Search by sessionId field (live chunks) not fileId field
                        const sessionItems = items.filter(item => item.sessionId === sessionId || item.fileId === sessionId);
                        
                        if (sessionItems.length > 0) {
                            console.log(`ðŸ—‘ï¸ Clearing ${sessionItems.length} upload queue items for session ${sessionId}`);
                            const deleteTx = db.transaction(['upload_queue'], 'readwrite');
                            const deleteStore = deleteTx.objectStore('upload_queue');
                            
                            sessionItems.forEach(item => {
                                console.log(`  ðŸ—‘ï¸ Deleting chunk ${item.chunkIndex || 'unknown'} (ID: ${item.id})`);
                                deleteStore.delete(item.id);
                            });
                            
                            deleteTx.oncomplete = () => {
                                console.log(`âœ“ Upload queue cleared for session ${sessionId}`);
                            };
                        } else {
                            console.log(`âœ“ No upload queue items found for session ${sessionId}`);
                        }
                    };
                } catch (e) {
                    console.error('Error clearing upload queue:', e);
                }
            },
            clearAllRecoveryData: function () {
                if (!db) return;
                db.transaction([STORE_RECOVERY], 'readwrite').objectStore(STORE_RECOVERY).clear();
            }
        };

        // --- 3. INDEXED DB ---
        let preferredMimeType = 'audio/webm';
        let preferredExt = 'webm';
        let tempBlob = null;

        function detectMimeType() {
            const types = [
                { mime: 'audio/webm;codecs=opus', ext: 'webm' },
                { mime: 'audio/webm', ext: 'webm' },
                { mime: 'audio/mp4', ext: 'mp4' },
                { mime: 'audio/ogg', ext: 'ogg' }
            ];
            for (let t of types) {
                if (MediaRecorder.isTypeSupported(t.mime)) {
                    preferredMimeType = t.mime; preferredExt = t.ext; break;
                }
            }
            document.getElementById('formatInfo').textContent = `SYSTEM: ${preferredExt.toUpperCase()}`;
        }

        function initDB() {
            detectMimeType();
            return new Promise((resolve, reject) => {
                console.log('â†’ Opening IndexedDB:', DB_NAME, 'version:', DB_VERSION);

                // Check if IndexedDB is available
                if (!window.indexedDB) {
                    console.error('âŒ IndexedDB not supported');
                    showToast("IndexedDB not supported in this browser", true);
                    reject(new Error('IndexedDB not supported'));
                    return;
                }

                try {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    console.log('â†’ Request created:', request);

                    request.onerror = (e) => {
                        console.error('âŒ IndexedDB error event:', e);
                        console.error('âŒ Error details:', e.target.error);
                        showToast("Database error: " + (e.target.error?.message || 'Unknown error'), true);
                        reject(e.target.error);
                    };

                    request.onblocked = (e) => {
                        console.warn('âš  IndexedDB blocked - close other tabs!');
                        showToast("Database blocked - close other tabs and reload", true);
                    };

                    request.onupgradeneeded = (e) => {
                        console.log('â†’ Database upgrade needed from version', e.oldVersion, 'to', e.newVersion);
                        const dbUpgrade = e.target.result;
                        console.log('â†’ Existing stores:', Array.from(dbUpgrade.objectStoreNames));

                        if (!dbUpgrade.objectStoreNames.contains(STORE_RECORDINGS)) {
                            console.log('â†’ Creating store:', STORE_RECORDINGS);
                            dbUpgrade.createObjectStore(STORE_RECORDINGS, { keyPath: 'id', autoIncrement: true });
                        }
                        if (!dbUpgrade.objectStoreNames.contains(STORE_RECOVERY)) {
                            console.log('â†’ Creating store:', STORE_RECOVERY);
                            const rec = dbUpgrade.createObjectStore(STORE_RECOVERY, { autoIncrement: true });
                            rec.createIndex('sessionId', 'sessionId', { unique: false });
                        }
                        if (!dbUpgrade.objectStoreNames.contains(STORE_UPLOAD_QUEUE)) {
                            console.log('â†’ Creating store:', STORE_UPLOAD_QUEUE);
                            dbUpgrade.createObjectStore(STORE_UPLOAD_QUEUE, { keyPath: 'id' });
                        }
                        console.log('âœ“ Database upgrade complete');
                    };

                    request.onsuccess = (e) => {
                        db = e.target.result;
                        console.log('âœ“ IndexedDB opened successfully');
                        console.log('â†’ Available stores:', Array.from(db.objectStoreNames));
                        console.log('â†’ DB version:', db.version);
                        CrashGuard.init();
                        loadTracksFromDB();
                        UploadManager.register();
                        LiveUploadIndicator.init(); // Initialize Live Upload Indicator
                        resolve(db);
                    };

                    // Timeout fallback
                    setTimeout(() => {
                        if (!db) {
                            console.error('âŒ IndexedDB open timeout after 10s');
                            showToast("Database timeout - please reload", true);
                            reject(new Error('Database open timeout'));
                        }
                    }, 10000);

                } catch (err) {
                    console.error('âŒ Exception opening IndexedDB:', err);
                    showToast("Database exception: " + err.message, true);
                    reject(err);
                }
            });
        }

        function saveTrackToDB(blob, name, mimeType, ext) {
            if (!db) {
                showToast("Database not initialized", true);
                document.getElementById('processingIndicator').classList.add('hidden');
                return;
            }

            const tx = db.transaction([STORE_RECORDINGS], 'readwrite');
            tx.objectStore(STORE_RECORDINGS).add({
                name: name,
                blob: blob,
                date: new Date().toISOString(),
                mimeType: mimeType,
                extension: ext,
                sessionId: currentSessionId // Store sessionId with recording
            });

            tx.oncomplete = () => {
                showToast(`Saved as .${ext.toUpperCase()}`);

                // Signal server that recording is complete and should be assembled
                if (currentSessionId) {
                    const fileName = `${name}.${ext}`;
                    const metadata = {
                        name: name,
                        mimeType: mimeType,
                        extension: ext,
                        recordingCompletedAt: new Date().toISOString(),
                        fileSize: blob.size
                    };
                    
                    // IMPORTANT: Count total chunks in queue for this session and register upload
                    const savedSessionId = currentSessionId; // Store before resetting
                    
                    // CRITICAL: Reset retry delays for all chunks in this session BEFORE queuing assembly signal
                    // This ensures immediate upload instead of waiting for exponential backoff
                    const resetTx = db.transaction(['upload_queue'], 'readwrite');
                    const resetStore = resetTx.objectStore('upload_queue');
                    const resetReq = resetStore.getAll();
                    
                    resetReq.onsuccess = () => {
                        const allItems = resetReq.result;
                        const sessionChunks = allItems.filter(item => item.sessionId === savedSessionId && item.type !== 'assembly_signal');
                        const totalChunks = sessionChunks.length;
                        
                        console.log(`ðŸ“¦ Recording saved: ${totalChunks} chunks queued for upload`);
                        
                        // Reset nextRetryAt for all chunks in this session to trigger immediate upload
                        let resetCount = 0;
                        const now = Date.now();
                        sessionChunks.forEach(item => {
                            if (item.nextRetryAt && item.nextRetryAt > now) {
                                item.nextRetryAt = 0;  // Retry immediately
                                item.retryCount = Math.max(0, (item.retryCount || 0) - 1);
                                resetStore.put(item);
                                resetCount++;
                            }
                        });
                        
                        if (resetCount > 0) {
                            console.log(`ðŸš€ Reset retry delays for ${resetCount} chunks - immediate upload triggered`);
                        }
                        
                        // Register upload with total chunks BEFORE rendering playlist
                        if (typeof UploadCoordinator !== 'undefined' && totalChunks > 0) {
                            UploadCoordinator.registerUpload(savedSessionId, 'custom', totalChunks);
                            console.log(`ðŸ“¦ Upload registered immediately for ${savedSessionId}`);
                        }
                        
                        // CRITICAL: Queue assembly signal AFTER resetting retry delays
                        console.log('ðŸ“¥ Queuing assembly signal (will be sent after all chunks upload)');
                        CrashGuard.queueRecordingComplete(savedSessionId, fileName, metadata);
                        
                        // Trigger Service Worker immediately
                        if (navigator.serviceWorker && navigator.serviceWorker.controller) {
                            navigator.serviceWorker.controller.postMessage('TRIGGER_UPLOAD');
                        }
                    };
                }

                // Clear recovery data after successful save
                try {
                    if (currentSessionId) {
                        CrashGuard.clearSession(currentSessionId);
                    } else {
                        CrashGuard.clearAllRecoveryData();
                    }
                } catch (e) {
                    console.warn('Could not clear recovery data:', e);
                }

                tempBlob = null; // Clear tempBlob after successful save
                const savedSessionId = currentSessionId; // Store sessionId before resetting
                currentSessionId = null; // Reset session ID
                
                // Load tracks and close modal
                loadTracksFromDB();
                closeSaveModal();
                
                // CRITICAL: Trigger UI update AFTER dialog is closed AND playlist is rendered
                // Multiple timeouts to ensure DOM is ready and dialog animation is complete
                if (savedSessionId && typeof UploadCoordinator !== 'undefined') {
                    // First update after dialog close animation (200ms) + rendering time
                    setTimeout(() => {
                        console.log(`ðŸŽ¨ [1st attempt] Triggering UI update for session: ${savedSessionId}`);
                        UploadCoordinator.updateUI(savedSessionId);
                    }, 250);
                    
                    // Second update as backup to ensure it's visible
                    setTimeout(() => {
                        console.log(`ðŸŽ¨ [2nd attempt] Triggering UI update for session: ${savedSessionId}`);
                        UploadCoordinator.updateUI(savedSessionId);
                    }, 500);
                }
            };

            tx.onerror = (e) => {
                console.error("DB Save Error:", e);
                showToast("Failed to save to database", true);
                document.getElementById('processingIndicator').classList.add('hidden');
            };
        }

        function loadTracksFromDB() {
            if (!db) return;
            const req = db.transaction([STORE_RECORDINGS], 'readonly').objectStore(STORE_RECORDINGS).getAll();
            req.onsuccess = () => renderPlaylist(req.result);
        }

        function deleteTrackFromDB(id) {
            db.transaction([STORE_RECORDINGS], 'readwrite').objectStore(STORE_RECORDINGS).delete(id).onsuccess = () => {
                showToast("Track deleted"); loadTracksFromDB();
            };
        }

        // --- 4. AUDIO ENGINE ---
        let audioContext, analyser, dataArray, canvas, canvasCtx;
        let inputSource, mediaRecorder, recordingNodes = {}, isRecording = false, startTime, timerInterval;
        let currentAudioBuffer = null, playbackSource = null, outputNodes = {}, isPlaying = false, playbackStartTime = 0, playbackOffset = 0, playbackRafId = null;
        let audioElement = null, mediaElementSource = null, currentBlobUrl = null;

        function initAudioEngine() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                initVisualizer();
            }
            if (audioContext.state === 'suspended') audioContext.resume();
        }

        function initVisualizer() {
            canvas = document.getElementById('visualizer');
            if (!canvas) return;
            canvasCtx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvas.getBoundingClientRect().width * dpr;
            canvas.height = canvas.getBoundingClientRect().height * dpr;
            canvasCtx.scale(dpr, dpr);
            drawVisualizer();
        }

        function drawVisualizer() {
            requestAnimationFrame(drawVisualizer);
            if (!canvas || !canvasCtx || !analyser) return;
            canvasCtx.clearRect(0, 0, canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);
            analyser.getByteFrequencyData(dataArray);
            const w = (canvas.width / window.devicePixelRatio) / dataArray.length * 2.5;
            let x = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const h = (dataArray[i] / 255) * (canvas.height / window.devicePixelRatio);
                canvasCtx.fillStyle = `rgb(${0 + 255 * (h / (canvas.height / window.devicePixelRatio))}, ${243 - 100 * (h / (canvas.height / window.devicePixelRatio))}, 255)`;
                canvasCtx.fillRect(x, (canvas.height / window.devicePixelRatio) - h, w - 2, h);
                x += w + 1;
            }
        }

        function encodeWAV(samples, sampleRate) {
            const buffer = new ArrayBuffer(44 + samples.length * 2);
            const view = new DataView(buffer);
            const writeString = (view, offset, string) => { for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i)); };
            writeString(view, 0, 'RIFF'); view.setUint32(4, 36 + samples.length * 2, true); writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * 2, true); view.setUint16(32, 2, true); view.setUint16(34, 16, true);
            writeString(view, 36, 'data'); view.setUint32(40, samples.length * 2, true);
            let offset = 44;
            for (let i = 0; i < samples.length; i++, offset += 2) {
                let s = Math.max(-1, Math.min(1, samples[i]));
                view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
            return view;
        }

        async function convertBlobToWav(blob) {
            const ab = await blob.arrayBuffer();
            const abuff = await audioContext.decodeAudioData(ab);
            const wavView = encodeWAV(abuff.getChannelData(0), abuff.sampleRate);
            return new Blob([wavView], { type: 'audio/wav' });
        }

        // Recording
        async function startRecording() {
            initAudioEngine();
            // FIXED: Disable Playback UI & Stop Audio
            document.getElementById('playerDock').classList.remove('active');
            if (isPlaying) stopAudio();

            // FIXED: Prevent Echo/Feedback
            // Disconnect analyser from destination if it was connected during playback
            try { analyser.disconnect(); } catch (e) { }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                inputSource = audioContext.createMediaStreamSource(stream);
                currentSessionId = CrashGuard.generateSessionId();

                ['low', 'mid', 'high', 'gain'].forEach(k => { recordingNodes[k] = audioContext.createBiquadFilter(); });
                recordingNodes.low.type = "lowshelf"; recordingNodes.low.frequency.value = 320;
                recordingNodes.mid.type = "peaking"; recordingNodes.mid.frequency.value = 1000;
                recordingNodes.high.type = "highshelf"; recordingNodes.high.frequency.value = 3200;
                recordingNodes.gain = audioContext.createGain();

                inputSource.connect(recordingNodes.low);
                recordingNodes.low.connect(recordingNodes.mid); recordingNodes.mid.connect(recordingNodes.high);
                recordingNodes.high.connect(recordingNodes.gain);

                // Connect to Analyser for visualizer, BUT NOT DESTINATION
                recordingNodes.gain.connect(analyser);

                const dest = audioContext.createMediaStreamDestination();
                recordingNodes.gain.connect(dest);

                try { mediaRecorder = new MediaRecorder(dest.stream, { mimeType: preferredMimeType }); } catch (e) { mediaRecorder = new MediaRecorder(dest.stream); }

                mediaRecorder.ondataavailable = e => {
                    if (e.data.size > 0) {
                        CrashGuard.logChunk(e.data);
                        
                        // CRITICAL: Update chunk count IMMEDIATELY when chunk is generated
                        // This ensures the counter updates even when server is offline
                        if (typeof LiveUploadIndicator !== 'undefined' && currentSessionId === LiveUploadIndicator.currentSessionId) {
                            LiveUploadIndicator.totalChunks++;
                            LiveUploadIndicator.updateTooltip();
                            console.log(`ðŸ“Š Chunk generated: ${LiveUploadIndicator.uploadedChunks}/${LiveUploadIndicator.totalChunks}`);
                        }
                    }
                };

                mediaRecorder.onstop = () => {
                    // CRITICAL: Wait briefly for any final ondataavailable events
                    // MediaRecorder may have 1-2 buffered chunks that haven't been delivered yet
                    const stoppedSessionId = currentSessionId;
                    console.log('ðŸ›‘ Recording stopped, waiting 300ms for final chunks...');
                    
                    // Simple fixed delay - most reliable approach
                    // Previous approach was flawed because it counted chunks already uploaded and removed from queue
                    setTimeout(() => {
                        console.log('âœ… Opening save modal');
                        CrashGuard.assembleSession(stoppedSessionId, false);
                    }, 300); // Just 300ms is enough for final ondataavailable events
                };

                mediaRecorder.start(1000);

                isRecording = true;
                document.getElementById('recordButton').classList.add('recording-active');
                document.getElementById('recordButton').disabled = true;
                document.getElementById('stopButton').disabled = false;
                startTimer();
                applyInputEQ();
                
                // Initialize live upload indicator for this recording session
                LiveUploadIndicator.onRecordingStart(currentSessionId);
            } catch (err) { console.error(err); showToast("Mic Error", true); }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                if (inputSource) {
                    inputSource.disconnect();
                    // Close the microphone stream
                    const tracks = inputSource.mediaStream.getTracks();
                    tracks.forEach(track => track.stop());
                }
                isRecording = false;
                document.getElementById('recordButton').classList.remove('recording-active');
                document.getElementById('recordButton').disabled = false;
                document.getElementById('stopButton').disabled = true;
                stopTimer();
                
                // Stop live upload indicator
                LiveUploadIndicator.onRecordingStop();
            }
        }

        // Save Modal
        const modal = document.getElementById('saveModal');
        const nameInput = document.getElementById('saveNameInput');
        function openSaveModal(isRecovery = false) {
            if (!tempBlob || tempBlob.size === 0) return;
            lastFocusedElement = document.activeElement; // Save current focus
            nameInput.value = isRecovery ? `RECOVERED ${new Date().toLocaleTimeString()}` : `Sequence ${new Date().toLocaleTimeString()}`;
            nameInput.style.borderColor = isRecovery ? 'var(--neon-red)' : '#374151';

            const fmt = document.getElementById('recordingFormat').value;
            const w = document.getElementById('processingWarning');
            if (fmt !== 'webm') w.classList.remove('hidden'); else w.classList.add('hidden');

            // Update format display
            document.getElementById('saveFormatDisplay').textContent = fmt.toUpperCase();

            modal.style.display = 'flex';
            modal.setAttribute('aria-hidden', 'false');
            setTimeout(() => {
                modal.classList.add('modal-open');
                trapFocus(modal); // Enable focus trap
                nameInput.focus();
            }, 10);
        }
        function closeSaveModal() {
            // CRITICAL: Clear recovery data when discarding save modal
            if (currentSessionId && db) {
                console.log('ðŸ—‘ï¸ DISCARD: Clearing recovery data for session:', currentSessionId);
                const tx = db.transaction([STORE_RECOVERY], 'readwrite');
                const store = tx.objectStore(STORE_RECOVERY);
                store.clear();
                tx.oncomplete = () => {
                    console.log('âœ… DISCARD: Recovery store cleared');
                };
            }
            
            // Clear pending recovery upload
            window.pendingRecoveryUpload = null;
            
            modal.classList.remove('modal-open');
            modal.setAttribute('aria-hidden', 'true');
            setTimeout(() => {
                modal.style.display = 'none';
                document.getElementById('processingIndicator').classList.add('hidden');
                // Restore focus
                if (lastFocusedElement) {
                    lastFocusedElement.focus();
                    lastFocusedElement = null;
                }
            }, 200);
        }

        async function confirmSave() {
            const name = nameInput.value || "Untitled";
            const fmt = document.getElementById('recordingFormat').value;

            // VALIDATION: Check if tempBlob exists
            if (!tempBlob || tempBlob.size === 0) {
                showToast("Error: No audio data to save", true);
                closeSaveModal();
                return;
            }

            console.log("Starting save process...", { name, fmt, blobSize: tempBlob.size });
            document.getElementById('processingIndicator').classList.remove('hidden');
            
            // If this is a recovery, upload chunks first with the real name
            if (window.pendingRecoveryUpload) {
                console.log('ðŸ”„ Processing recovery upload with name:', name);
                document.getElementById('processingIndicator').textContent = 'UPLOADING RECOVERY DATA...';
                
                try {
                    const { chunks, sessionId } = window.pendingRecoveryUpload;
                    await CrashGuard.uploadAndAssembleRecoveredChunks(chunks, sessionId, name, fmt);
                    window.pendingRecoveryUpload = null;
                    console.log('âœ… Recovery upload complete');
                } catch (err) {
                    console.error('Recovery upload failed:', err);
                    showToast('Recovery upload failed: ' + err.message, true);
                    document.getElementById('processingIndicator').classList.add('hidden');
                    return;
                }
                
                document.getElementById('processingIndicator').textContent = 'PROCESSING AUDIO... PLEASE WAIT';
            }

            // Use immediate async execution instead of setTimeout
            try {
                let blobToSave;
                let mimeType;
                let extension;

                if (fmt === 'wav') {
                    console.log("Converting to WAV...");
                    blobToSave = await convertBlobToWav(tempBlob);
                    mimeType = 'audio/wav';
                    extension = 'wav';
                } else if (fmt === 'mp3') {
                    blobToSave = tempBlob;
                    mimeType = 'audio/mpeg';
                    extension = 'mp3';
                } else {
                    // WebM format
                    blobToSave = tempBlob;
                    mimeType = preferredMimeType;
                    extension = preferredExt;
                }

                console.log("Saving to DB...", { size: blobToSave.size, mimeType, extension });
                saveTrackToDB(blobToSave, name, mimeType, extension);

            } catch (e) {
                console.error("Save error:", e);
                showToast("Save Failed: " + e.message, true);
                document.getElementById('processingIndicator').classList.add('hidden');
                closeSaveModal();
            }
        }

        // --- 5. PLAYER LOGIC & DOCK BEHAVIOR ---

        async function loadTrack(id, name, blob) {
            // FIXED: Disable Playback if Recording
            if (isRecording) { showToast("Recording Active!", true); return; }

            initAudioEngine();
            stopAudio();
            showToast("Loading audio...");
            try {
                // Clean up old blob URL
                if (currentBlobUrl) {
                    URL.revokeObjectURL(currentBlobUrl);
                }

                // Create NEW Audio Element for each track (MediaElementSource can only be created once per element)
                currentBlobUrl = URL.createObjectURL(blob);

                // Clean up old audio element
                if (audioElement) {
                    audioElement.pause();
                    audioElement.src = '';
                }

                // Create fresh audio element
                audioElement = new Audio();
                audioElement.preservesPitch = true; // CRITICAL: Prevents Mickey Mouse effect
                audioElement.crossOrigin = 'anonymous';
                audioElement.playbackRate = currentPlaybackRate; // Restore speed setting

                // Reset MediaElementSource so it gets recreated in playAudio()
                if (mediaElementSource) {
                    mediaElementSource.disconnect();
                    mediaElementSource = null;
                }

                audioElement.src = currentBlobUrl;
                audioElement.preload = 'auto'; // Force full preload

                // Wait for audio to be fully loaded
                await new Promise((resolve, reject) => {
                    // Use canplaythrough for complete loading
                    audioElement.oncanplaythrough = resolve;
                    audioElement.onerror = reject;
                    audioElement.load(); // Explicitly trigger load
                });

                // Extra safety: Wait until duration is actually available and valid
                let retries = 0;
                while ((!audioElement.duration || !isFinite(audioElement.duration)) && retries < 100) {
                    await new Promise(resolve => setTimeout(resolve, 20));
                    retries++;
                }

                console.log('Audio loaded, duration:', audioElement.duration, 'readyState:', audioElement.readyState);

                audioElement.currentTime = 0;

                const dock = document.getElementById('playerDock');
                dock.classList.add('active');

                document.getElementById('nowPlayingText').textContent = name;
                playbackOffset = 0;
                updateDurationDisplay(audioElement.duration);
                updateCurrentTimeDisplay(0);
                document.getElementById('seekSlider').value = 0;
                await playAudio(0);
            } catch (e) { console.error(e); showToast("Error loading audio", true); }
        }

        async function playAudio(offset) {
            // FIXED: Disable Playback if Recording
            if (isRecording) return;

            if (!audioElement) return;

            // Create MediaElementSource if not exists
            if (!mediaElementSource) {
                mediaElementSource = audioContext.createMediaElementSource(audioElement);

                // Setup EQ chain
                ['low', 'mid', 'high', 'gain'].forEach(k => { outputNodes[k] = audioContext.createBiquadFilter(); });
                outputNodes.low.type = "lowshelf"; outputNodes.low.frequency.value = 320;
                outputNodes.mid.type = "peaking"; outputNodes.mid.frequency.value = 1000;
                outputNodes.high.type = "highshelf"; outputNodes.high.frequency.value = 3200;
                outputNodes.gain = audioContext.createGain();

                // Create crossfade gain node
                crossfadeGainNode = audioContext.createGain();
                crossfadeGainNode.gain.value = 1;

                // Connect audio chain
                mediaElementSource.connect(outputNodes.low);
                outputNodes.low.connect(outputNodes.mid);
                outputNodes.mid.connect(outputNodes.high);
                outputNodes.high.connect(outputNodes.gain);
                outputNodes.gain.connect(crossfadeGainNode);
                crossfadeGainNode.connect(analyser);
                analyser.connect(audioContext.destination);

                applyOutputEQ();
            }

            // Set playback position and speed
            audioElement.currentTime = offset || 0;
            audioElement.playbackRate = currentPlaybackRate;
            audioElement.preservesPitch = true; // Always preserve pitch!

            // Set state BEFORE starting playback
            playbackStartTime = audioContext.currentTime;
            playbackOffset = offset || 0;
            isPlaying = true;
            updatePlayPauseButtonUI();

            // Start playback and seek loop
            try {
                await audioElement.play();
                startSeekLoop();
            } catch (e) {
                console.error('Play error:', e);
                isPlaying = false;
                updatePlayPauseButtonUI();
            }
        }

        function stopAudio(reachedEnd = false, skipFade = false) {
            if (audioElement) {
                // Smooth fade-out to prevent clicks (10ms) unless skipping
                if (crossfadeGainNode && !skipFade) {
                    const now = audioContext.currentTime;
                    crossfadeGainNode.gain.cancelScheduledValues(now);
                    crossfadeGainNode.gain.setValueAtTime(crossfadeGainNode.gain.value, now);
                    crossfadeGainNode.gain.linearRampToValueAtTime(0.01, now + 0.01);

                    setTimeout(() => {
                        audioElement.pause();
                        crossfadeGainNode.gain.setValueAtTime(1, audioContext.currentTime);
                    }, 15);
                } else {
                    audioElement.pause();
                }
            }
            isPlaying = false;
            cancelAnimationFrame(playbackRafId);
            updatePlayPauseButtonUI();
            if (reachedEnd) {
                if (audioElement) audioElement.currentTime = 0;
                playbackOffset = 0;
                document.getElementById('seekSlider').value = 0;
                updateCurrentTimeDisplay(0);
            }
        }

        function togglePlayPause() {
            if (isRecording) return; // Guard
            if (!audioElement) return;

            if (isPlaying) {
                stopAudio();
            } else {
                // Start from current position or beginning if at end
                const currentPos = audioElement.currentTime;
                if (currentPos >= audioElement.duration - 0.1) {
                    playAudio(0);
                } else {
                    playAudio(currentPos);
                }
            }
        }

        function playerSeek(percentage) {
            if (!audioElement) return;
            // Convert percentage (0-100) to actual time
            const time = (percentage / 100) * audioElement.duration;
            if (isPlaying) {
                audioElement.currentTime = time;
            } else {
                audioElement.currentTime = time;
                updateCurrentTimeDisplay(time);
                document.getElementById('seekSlider').value = percentage;
            }
        }
        function playerSkip(s) {
            if (audioElement && audioElement.duration && isFinite(audioElement.duration)) {
                const newTime = audioElement.currentTime + s;
                const clampedTime = Math.max(0, Math.min(newTime, audioElement.duration));
                const percentage = (clampedTime / audioElement.duration) * 100;
                playerSeek(percentage);
            }
        }
        function playerSeekStart() { playerSeek(0); }
        function playerSeekEnd() { if (audioElement) { audioElement.currentTime = audioElement.duration; updateCurrentTimeDisplay(audioElement.duration); document.getElementById('seekSlider').value = 100; } }

        function startSeekLoop() {
            cancelAnimationFrame(playbackRafId);
            let durationDiscovered = false;

            function loop() {
                if (isPlaying && audioElement) {
                    const pos = audioElement.currentTime;
                    const dur = audioElement.duration;

                    // Always update current time display
                    updateCurrentTimeDisplay(pos);

                    // Check if we got a valid duration
                    if (dur && isFinite(dur) && dur > 0) {
                        if (!durationDiscovered) {
                            durationDiscovered = true;
                            updateDurationDisplay(dur);
                        }

                        // Convert time to percentage (0-100)
                        const percentage = (pos / dur) * 100;
                        // Only update slider if user is not dragging it
                        if (!window.isSeekDragging) {
                            document.getElementById('seekSlider').value = percentage;
                        }
                    }
                    // If duration not available yet, slider stays at 0 (no confusing estimates)

                    // Continue loop if not at end
                    if (!audioElement.ended && !audioElement.paused) {
                        playbackRafId = requestAnimationFrame(loop);
                    } else if (audioElement.ended) {
                        // Audio zu Ende
                        stopAudio(true);
                    }
                }
            }
            loop();
        }

        function updateDurationDisplay(d) {
            if (!d || !isFinite(d)) { document.getElementById('totalTime').textContent = '00:00'; return; }
            document.getElementById('totalTime').textContent = `${Math.floor(d / 60).toString().padStart(2, '0')}:${Math.floor(d % 60).toString().padStart(2, '0')}`;
        }
        function updateCurrentTimeDisplay(t) {
            if (!t || !isFinite(t)) { document.getElementById('currentTime').textContent = '00:00'; return; }
            document.getElementById('currentTime').textContent = `${Math.floor(t / 60).toString().padStart(2, '0')}:${Math.floor(t % 60).toString().padStart(2, '0')}`;
        }
        function updatePlayPauseButtonUI() { document.getElementById('dockPlayBtn').innerHTML = isPlaying ? 'âšâš' : 'â–¶'; }
        document.getElementById('seekSlider').addEventListener('change', (e) => playerSeek(parseFloat(e.target.value)));

        document.addEventListener('click', (e) => {
            const dock = document.getElementById('playerDock');
            const clickedInsideDock = dock.contains(e.target);
            const clickedPlayBtn = e.target.closest('button') && e.target.closest('button').className.includes('play-btn-');
            if (dock.classList.contains('active') && !clickedInsideDock && !clickedPlayBtn) {
                dock.classList.remove('active');
                // Stop playback when dock closes
                if (isPlaying) {
                    stopAudio();
                    playbackOffset = 0;
                }
            }
        });

        // EQ Updates
        function applyInputEQ() { if (!recordingNodes.gain) return; applyEQ(recordingNodes, 'input'); }
        function applyOutputEQ() { if (!outputNodes.gain) return; applyEQ(outputNodes, 'output'); }
        function applyEQ(nodes, prefix) {
            const v = getSliderValues(prefix);
            nodes.low.gain.setTargetAtTime(v.low, audioContext.currentTime, 0.1);
            nodes.mid.gain.setTargetAtTime(v.mid, audioContext.currentTime, 0.1);
            nodes.high.gain.setTargetAtTime(v.high, audioContext.currentTime, 0.1);
            nodes.gain.gain.setTargetAtTime(v.gain, audioContext.currentTime, 0.1);
        }
        function getSliderValues(prefix) {
            const low = parseFloat(document.getElementById(`${prefix}LowShelf`).value);
            const mid = parseFloat(document.getElementById(`${prefix}Peaking`).value);
            const high = parseFloat(document.getElementById(`${prefix}HighShelf`).value);
            const gain = parseFloat(document.getElementById(`${prefix}Gain`).value);
            document.getElementById(`val-${prefix}Low`).textContent = (low > 0 ? `+${low}` : low) + 'dB';
            document.getElementById(`val-${prefix}Mid`).textContent = (mid > 0 ? `+${mid}` : mid) + 'dB';
            document.getElementById(`val-${prefix}High`).textContent = (high > 0 ? `+${high}` : high) + 'dB';
            document.getElementById(`val-${prefix}Gain`).textContent = Math.round(gain * 100) + '%';
            return { low, mid, high, gain };
        }

        // Playlist & Timer
        function renderPlaylist(tracks) {
            const c = document.getElementById('playlist');
            document.getElementById('trackCount').textContent = `${tracks ? tracks.length : 0} ${t('playlist.trackCount')}`;
            c.innerHTML = '';
            if (!tracks || tracks.length === 0) { c.innerHTML = `<div class="text-center text-gray-600 mt-10 digital-text">${t('playlist.noData')}</div>`; return; }
            tracks.reverse().forEach(t => {
                const el = document.createElement('div');
                el.className = 'group flex flex-col p-3 rounded hover:bg-white/5 border border-transparent hover:border-white/10 transition-all';
                
                // Add session ID to container for UploadCoordinator
                if (t.sessionId) {
                    el.setAttribute('data-session-id', t.sessionId);
                }
                
                const date = new Date(t.date).toLocaleDateString();
                const ext = t.extension || 'webm';
                let col = 'text-gray-500'; if (ext === 'wav') col = 'text-cyan-400'; if (ext === 'mp3') col = 'text-pink-400';

                // CONDITIONAL: Show upload button only if cloud upload is available
                const uploadButtonHTML = (!ENV || ENV.cloudUpload !== false)
                    ? `<button class="up-btn-${t.id} w-8 h-8 rounded-full border border-gray-600 flex items-center justify-center hover:border-cyan-400 hover:text-cyan-400 upload-icon transition-all" title="Upload to Cloud" aria-label="In Cloud hochladen: ${t.name}" type="button"><span aria-hidden="true">â˜</span></button>`
                    : `<button class="w-8 h-8 rounded-full border border-gray-700 flex items-center justify-center text-gray-700 cursor-not-allowed opacity-30" title="Upload not available in offline mode" disabled><span aria-hidden="true">â˜</span></button>`;

                el.innerHTML = `
                    <div class="flex justify-between items-center w-full">
                        <div><div class="font-bold text-gray-200 group-hover:text-cyan-400 transition-colors filename">${t.name}</div><div class="text-[10px] ${col} font-mono">${date} | ${ext.toUpperCase()}</div></div>
                        <div class="flex gap-2 opacity-60 group-hover:opacity-100 transition-opacity">
                            <button class="play-btn-${t.id} w-8 h-8 rounded-full border border-gray-600 flex items-center justify-center hover:border-cyan-400 hover:text-cyan-400 hover:shadow-[0_0_10px_rgba(0,243,255,0.3)] transition-all" aria-label="Abspielen: ${t.name}" type="button"><span aria-hidden="true">â–¶</span></button>
                            ${uploadButtonHTML}
                            <button class="dl-btn-${t.id} px-2 h-8 rounded border border-gray-600 flex items-center justify-center hover:border-green-400 hover:text-green-400 text-[10px] font-mono transition-all" aria-label="Herunterladen: ${t.name}" type="button">DL</button>
                            <button class="del-btn-${t.id} w-8 h-8 rounded-full border border-gray-600 flex items-center justify-center hover:border-red-500 hover:text-red-500 transition-all" aria-label="LÃ¶schen: ${t.name}" type="button"><span aria-hidden="true">Ã—</span></button>
                        </div>
                    </div>
                    <div class="upload-status-bar" id="progress-bar-${t.id}"><div class="upload-status-fill" id="progress-${t.id}"></div></div>
                    <div class="upload-status-expanded" id="upload-status-${t.id}">
                        <!-- Dynamically filled by UploadCoordinator -->
                    </div>
                `;
                c.appendChild(el);
                el.querySelector(`.play-btn-${t.id}`).onclick = () => loadTrack(t.id, t.name, t.blob);
                el.querySelector(`.dl-btn-${t.id}`).onclick = () => { const u = URL.createObjectURL(t.blob); const a = document.createElement('a'); a.href = u; a.download = `${t.name}.${ext}`; a.click(); URL.revokeObjectURL(u); };
                el.querySelector(`.del-btn-${t.id}`).onclick = () => openDeleteModal(t.id, t.name);
                
                // CONDITIONAL: Only add upload handler if cloud upload is available
                if (!ENV || ENV.cloudUpload !== false) {
                    el.querySelector(`.up-btn-${t.id}`).onclick = () => {
                        document.getElementById(`progress-bar-${t.id}`).style.display = 'block';
                        const metadata = {
                            name: t.name,
                            mimeType: t.mimeType || preferredMimeType,
                            extension: ext,
                            savedAt: t.date,
                            fileSize: t.blob.size,
                            manualUpload: true  // Flag to indicate this is a manual upload
                        };
                        UploadManager.queueUpload(t.id, t.blob, `${t.name}.${ext}`, metadata, t.sessionId);
                    };
                }
                
                // IMPORTANT: Immediately show upload status if this recording has an active upload
                if (t.sessionId && UploadCoordinator.activeUploads.has(t.sessionId)) {
                    // Trigger UI update immediately after element is in DOM
                    setTimeout(() => UploadCoordinator.updateUI(t.sessionId), 0);
                }
            });
            
            // CRITICAL: After rendering all items, update UI for ALL active uploads
            // This ensures the upload status boxes are expanded immediately
            if (typeof UploadCoordinator !== 'undefined' && UploadCoordinator.activeUploads.size > 0) {
                // Multiple updates to ensure box appears (DOM needs time to settle)
                setTimeout(() => {
                    console.log(`ðŸŽ¨ [renderPlaylist 1st] Updating UI for ${UploadCoordinator.activeUploads.size} active uploads`);
                    for (const sessionId of UploadCoordinator.activeUploads.keys()) {
                        UploadCoordinator.updateUI(sessionId);
                    }
                }, 50);
                
                setTimeout(() => {
                    console.log(`ðŸŽ¨ [renderPlaylist 2nd] Updating UI for ${UploadCoordinator.activeUploads.size} active uploads`);
                    for (const sessionId of UploadCoordinator.activeUploads.keys()) {
                        UploadCoordinator.updateUI(sessionId);
                    }
                }, 150);
            }
        }

        function startTimer() { startTime = Date.now(); timerInterval = setInterval(() => { document.getElementById('timerDisplay').textContent = new Date(Date.now() - startTime).toISOString().substr(11, 8); }, 100); }
        function stopTimer() { clearInterval(timerInterval); }

        // DELETE MODAL FUNCTIONS
        function openDeleteModal(trackId, trackName) {
            lastFocusedElement = document.activeElement; // Save current focus
            deleteModal = document.getElementById('deleteModal');
            trackToDelete = trackId;
            document.getElementById('deleteRecordingName').textContent = trackName;
            deleteModal.style.display = 'flex';
            deleteModal.classList.add('modal-open');
            deleteModal.setAttribute('aria-hidden', 'false');
            setTimeout(() => {
                trapFocus(deleteModal); // Enable focus trap
                // Focus modal title
                const modalTitle = deleteModal.querySelector('#deleteModalTitle');
                if (modalTitle) modalTitle.focus();
            }, 10);
        }

        function closeDeleteModal() {
            if (deleteModal) {
                deleteModal.style.display = 'none';
                deleteModal.classList.remove('modal-open');
                deleteModal.setAttribute('aria-hidden', 'true');
                trackToDelete = null;
                // Restore focus
                if (lastFocusedElement) {
                    lastFocusedElement.focus();
                    lastFocusedElement = null;
                }
            }
        }

        function confirmDelete() {
            if (trackToDelete) {
                deleteTrackFromDB(trackToDelete);
                closeDeleteModal();
            }
        }

        // PLAYBACK SPEED CONTROL - Native HTML5 Audio mit Pitch Preservation!
        function changePlaybackSpeed(speed) {
            const newRate = parseFloat(speed);
            currentPlaybackRate = newRate;

            if (audioElement) {
                // HTML5 Audio Element unterstÃ¼tzt native Pitch Preservation!
                audioElement.playbackRate = newRate;
                audioElement.preservesPitch = true; // Verhindert Mickey Mouse Effekt
            }
        }

        // CLOSE DOCK FUNCTION
        function closeDock() {
            const dock = document.getElementById('playerDock');
            dock.classList.remove('active');
            // Stop playback when dock closes
            if (isPlaying) {
                stopAudio();
                playbackOffset = 0;
            }
            // Reset playback speed
            currentPlaybackRate = 1.0;
            document.getElementById('playbackSpeed').value = '1';
        }

        document.addEventListener('DOMContentLoaded', () => {
            initDB().catch(err => {
                console.error('Failed to initialize database:', err);
                showToast('Database initialization failed!', true);
            });
            document.getElementById('recordButton').addEventListener('click', startRecording);
            document.getElementById('stopButton').addEventListener('click', stopRecording);
            ['LowShelf', 'Peaking', 'HighShelf', 'Gain'].forEach(t => {
                document.getElementById(`input${t}`).addEventListener('input', (e) => {
                    getSliderValues('input');
                    applyInputEQ();
                    // Update ARIA attributes dynamically for screen readers
                    const val = e.target.value;
                    e.target.setAttribute('aria-valuenow', val);
                    e.target.setAttribute('aria-valuetext', `${val} Dezibel`);
                });
                document.getElementById(`output${t}`).addEventListener('input', (e) => {
                    getSliderValues('output');
                    applyOutputEQ();
                    // Update ARIA attributes dynamically for screen readers
                    const val = e.target.value;
                    e.target.setAttribute('aria-valuenow', val);
                    e.target.setAttribute('aria-valuetext', `${val} Dezibel`);
                });
            });
            getSliderValues('input'); getSliderValues('output');
            updateFormatWarning();
            
            // Initialize live upload indicator
            LiveUploadIndicator.init();

            // BITV 2.0: Keyboard accessibility - Escape key closes modals
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (modal.style.display === 'flex') closeSaveModal();
                    else if (infoModal.style.display === 'flex') closeInfoModal();
                    else if (document.getElementById('uploadSettingsModal')?.style.display === 'flex') closeUploadSettingsModal();
                    else if (document.getElementById('deleteModal')?.style.display === 'flex') closeDeleteModal();
                    else if (document.getElementById('recoveryModal').style.display === 'flex') {
                        // Recovery modal doesn't have close function, but we can discard
                        CrashGuard.discardSession();
                    }
                }
            });

            // Initialize language
            initLanguage();
        });

        // ============================================
        // MULTI-LANGUAGE SUPPORT SYSTEM
        // ============================================

        const translations = {
            de: {
                // UI Elements
                'ui.info': 'INFO',
                'ui.skipToContent': 'Zum Hauptinhalt springen',
                'ui.crashguard': 'CRASHGUARD // RAID PROTECTED SYSTEM',
                'ui.format': 'FORMAT:',
                'ui.rec': 'REC',
                'ui.stop': 'STOP',
                'ui.input': 'INPUT',
                'ui.output': 'OUTPUT',
                'ui.inputStage': 'INPUT STAGE',
                'ui.outputStage': 'OUTPUT STAGE',
                'ui.low': 'LOW',
                'ui.mid': 'MID',
                'ui.high': 'HIGH',
                'ui.gain': 'GAIN',
                'ui.save': 'SAVE',
                'ui.close': 'CLOSE',
                'ui.yes': 'JA',
                'ui.no': 'NEIN',
                'ui.delete': 'LÃ¶schen',
                'ui.download': 'DL',
                'ui.play': 'Abspielen',
                'ui.upload': 'Upload',

                // Status Messages
                'status.ready': 'SYSTEM READY',
                'status.recording': 'RECORDING',
                'status.stopped': 'GESTOPPT',
                'status.playing': 'ABSPIELEN',
                'status.paused': 'ANGEHALTEN',
                'status.error': 'ERROR',
                'status.uploading': 'HOCHLADEN',
                'status.uploaded': 'HOCHGELADEN',

                // Format Options
                'format.webm': 'WEBM (Opus Codec)',
                'format.wav': 'WAV (Hoher Speicherverbrauch!)',
                'format.mp3': 'MP3',
                'format.detecting': 'FORMAT: ERKENNUNG...',
                'format.ramWarning': 'âœ“ FÃ¼r Aufnahmen auch Ã¼ber 8h!',
                'format.ramWarningWav': 'âš  Nur 30-60 Minuten sicher! ',

                // Recording Info
                'recording.sessionStarted': 'Session gestartet',
                'recording.crashDetected': 'CRASH DETECTED! Session wird wiederhergestellt...',
                'recording.recoveryAvailable': 'Wiederherstellung verfÃ¼gbar',
                'recording.sessionRecovered': 'Session erfolgreich wiederhergestellt',
                'recording.chunksSaved': 'Chunks gespeichert',
                'recording.duration': 'Dauer',

                // Playlist
                'playlist.title': 'AUFNAHMEN',
                'playlist.noData': 'KEINE DATEN GEFUNDEN',
                'playlist.trackCount': 'TRACKS',

                // Upload Settings
                'ui.uploadSettings': 'UPLOAD',
                'aria.uploadSettings': 'Upload-Methode wÃ¤hlen',
                'modal.uploadSettings': 'UPLOAD EINSTELLUNGEN',
                'upload.method': 'Ãœbertragungsmethode',
                'upload.desc': 'WÃ¤hlen Sie die Methode fÃ¼r den Datei-Upload. TUS ermÃ¶glicht das Fortsetzen unterbrochener Uploads.',
                'upload.tus': 'TUS (Resumable, Empfohlen)',
                'upload.legacy': 'Legacy (Standard POST)',

                // Modal Titles
                'modal.save': 'Aufnahme speichern',
                'modal.info': 'WAVEFORGE PRO - INFO',
                'modal.recovery': 'Session Wiederherstellung',

                // Save Modal
                'save.enterName': 'Dateinamen eingeben',
                'save.placeholder': 'Meine Aufnahme',
                'save.saveButton': 'Speichern',
                'save.closeButton': 'Verwerfen',

                // Recovery Modal
                'recovery.title': 'CRASH RECOVERY',
                'recovery.detected': 'Unterbrochene Session erkannt!',
                'recovery.message': 'Eine vorherige Aufnahme wurde unterbrochen. MÃ¶chten Sie diese wiederherstellen?',
                'recovery.chunkInfo': 'VerfÃ¼gbare Chunks',
                'recovery.restore': 'Wiederherstellen',
                'recovery.discard': 'Verwerfen',

                // Info Modal Sections
                'info.title': 'WAVEFORGE PRO - INFO',
                'info.close': 'SchlieÃŸen',
                'info.introduction': 'Professionelle Offline Audio-Workstation im Browser',
                'info.introText': 'WaveForge Pro ist eine hochmoderne Digital Audio Workstation (DAW) fÃ¼r den Browser, optimiert fÃ¼r lange Aufnahmen (8+ Stunden) mit intelligentem CrashGuard-System, Cloud-Synchronisation und vollstÃ¤ndiger BITV 2.0 Barrierefreiheit.',
                'info.offlineCapable': 'Offline-fÃ¤hig',
                'info.multiBrowser': 'Multi-Browser',
                'info.storageOptimized': 'Speicheroptimiert',
                'info.localDownload': 'Lokaler Download',

                // Compliance
                'compliance.title': 'Compliance & Zertifizierungen',
                'compliance.wcag': 'WCAG 2.1 Level AA',
                'compliance.wcagDesc': 'Web Content Accessibility Guidelines',
                'compliance.bitv': 'BITV 2.0 Compliant',
                'compliance.bitvDesc': 'Barrierefreie IT-Verordnung',
                'compliance.en': 'EN 301 549 Compliant',
                'compliance.enDesc': 'EU Accessibility Standard',

                // Features
                'features.title': 'Hauptfunktionen',
                'features.recording': 'Aufnahme & Produktion',
                'features.crashguard': 'CrashGuard System',
                'features.cloud': 'Cloud-Synchronisation',
                'features.accessibility': 'Barrierefreiheit',
                'features.offline': 'Offline & Multi-Browser',
                'features.performance': 'Performance & Speicher',

                // Technical Specs
                'tech.title': 'Technische Spezifikationen',
                'tech.frontend': 'Frontend:',
                'tech.backend': 'Backend:',
                'tech.storage': 'Storage:',
                'tech.audio': 'Audio API:',
                'tech.serviceWorker': 'Service Worker:',
                'tech.recorder': 'Recorder:',

                // Planned Features
                'planned.title': 'Geplante Features (Roadmap)',
                'planned.webcomponent': 'WebComponent-Integration',
                'planned.webcomponentDesc': 'Standalone Component fÃ¼r Angular, React, Vue.js',
                'planned.multilang': 'Multi-Language Support',
                'planned.multilangDesc': 'Deutsch, English, FranÃ§ais, EspaÃ±ol, Italiano',
                'planned.auth': 'Authentifizierung & Sicherheit',
                'planned.authDesc': 'OAuth2, SAML, JWT, End-to-End Encryption',
                'planned.collab': 'Collaborative Recording',
                'planned.collabDesc': 'Multi-User Sessions, Real-Time Collaboration',
                'planned.theme': 'Theme Engine',
                'planned.themeDesc': 'Light/Dark Mode, Custom Color Schemes, Skins',
                'planned.effects': 'Advanced Effects',
                'planned.effectsDesc': 'Reverb, Delay, Compressor, Limiter, Noise Gate',
                'planned.multitrack': 'Multi-Track Recording',
                'planned.multitrackDesc': 'Parallele Aufnahme mehrerer Spuren',

                // Preview Warning
                'preview.title': 'Preview Version - EinschrÃ¤nkungen',
                'preview.intro': 'Dies ist eine Preview-Version zur Demonstration der KernfunktionalitÃ¤t. Folgende Features sind aktuell nicht implementiert:',
                'preview.noAuth': 'Authentifizierung',
                'preview.noAuthDesc': 'Kein Login-System, keine Benutzerkonten',
                'preview.noAuthz': 'Autorisierung',
                'preview.noAuthzDesc': 'Keine Rollen- oder Rechteverwaltung',
                'preview.noEncrypt': 'InhaltsverschlÃ¼sselung',
                'preview.noEncryptDesc': 'DatenÃ¼bertragung ist per TLS/SSL verschlÃ¼sselt, jedoch nicht die DB-Inhalte in lokalen Browser-Datenbanken',
                'preview.noIntegration': 'Framework-Integration',
                'preview.noIntegrationDesc': 'WebComponent fÃ¼r Angular/React noch nicht verfÃ¼gbar',
                'preview.disclaimer': 'âš  Diese Version ist ausschlieÃŸlich fÃ¼r Test- und Demonstrationszwecke bestimmt und nicht fÃ¼r den Produktivbetrieb geeignet.',

                // ARIA Labels
                'aria.selectLanguage': 'Sprache auswÃ¤hlen',
                'aria.info': 'Informationen und Compliance anzeigen',
                'aria.recordingDuration': 'Aufnahmedauer',
                'aria.startRecording': 'Aufnahme starten',
                'aria.stopRecording': 'Aufnahme stoppen',
                'aria.inputLowShelf': 'Eingangs-Low-Shelf EQ',
                'aria.inputPeaking': 'Eingangs-Peaking EQ',
                'aria.inputHighShelf': 'Eingangs-High-Shelf EQ',
                'aria.inputGain': 'Eingangs-VerstÃ¤rkung',
                'aria.outputLowShelf': 'Ausgangs-Low-Shelf EQ',
                'aria.outputPeaking': 'Ausgangs-Peaking EQ',
                'aria.outputHighShelf': 'Ausgangs-High-Shelf EQ',
                'aria.outputGain': 'AusgangslautstÃ¤rke',
                'aria.selectFormat': 'Aufnahmeformat auswÃ¤hlen',
                'aria.visualizer': 'Audio-Visualisierung',
                'aria.inputSection': 'Eingangsstufe',
                'aria.outputSection': 'Ausgangsstufe',
                'aria.playlistSection': 'Aufnahmeliste',
            },
            en: {
                // UI Elements
                'ui.info': 'INFO',
                'ui.skipToContent': 'Skip to main content',
                'ui.crashguard': 'CRASHGUARD // RAID PROTECTED SYSTEM',
                'ui.format': 'FORMAT:',
                'ui.rec': 'REC',
                'ui.stop': 'STOP',
                'ui.input': 'INPUT',
                'ui.output': 'OUTPUT',
                'ui.inputStage': 'INPUT STAGE',
                'ui.outputStage': 'OUTPUT STAGE',
                'ui.low': 'LOW',
                'ui.mid': 'MID',
                'ui.high': 'HIGH',
                'ui.gain': 'GAIN',
                'ui.save': 'SAVE',
                'ui.close': 'CLOSE',
                'ui.yes': 'YES',
                'ui.no': 'NO',
                'ui.delete': 'Delete',
                'ui.download': 'DL',
                'ui.play': 'Play',
                'ui.upload': 'Upload',

                // Status Messages
                'status.ready': 'SYSTEM READY',
                'status.recording': 'RECORDING',
                'status.stopped': 'STOPPED',
                'status.playing': 'PLAYING',
                'status.paused': 'PAUSED',
                'status.error': 'ERROR',
                'status.uploading': 'UPLOADING',
                'status.uploaded': 'UPLOADED',

                // Format Options
                'format.webm': 'WEBM (Opus Codec)',
                'format.wav': 'WAV (Lossless)',
                'format.mp3': 'MP3',
                'format.detecting': 'FORMAT: DETECTING...',
                'format.ramWarning': 'âœ“ LOW RAM MODE (Safe for 8h+)',
                'format.ramWarningWav': 'âš  HIGH RAM! Only 30min safe with 8GB',

                // Recording Info
                'recording.sessionStarted': 'Session started',
                'recording.crashDetected': 'CRASH DETECTED! Restoring session...',
                'recording.recoveryAvailable': 'Recovery available',
                'recording.sessionRecovered': 'Session successfully recovered',
                'recording.chunksSaved': 'Chunks saved',
                'recording.duration': 'Duration',

                // Playlist
                'playlist.title': 'RECORDINGS',
                'playlist.noData': 'NO DATA FOUND',
                'playlist.trackCount': 'TRACKS',

                // Upload Settings
                'ui.uploadSettings': 'UPLOAD',
                'aria.uploadSettings': 'Select upload method',
                'modal.uploadSettings': 'UPLOAD SETTINGS',
                'upload.method': 'Transfer Method',
                'upload.desc': 'Choose the file upload method. TUS allows resuming interrupted uploads.',
                'upload.tus': 'TUS (Resumable, Recommended)',
                'upload.legacy': 'Legacy (Standard POST)',

                // Modal Titles
                'modal.save': 'Save Recording',
                'modal.info': 'WAVEFORGE PRO - INFO',
                'modal.recovery': 'Session Recovery',

                // Save Modal
                'save.enterName': 'Enter filename',
                'save.placeholder': 'My Recording',
                'save.saveButton': 'Save',
                'save.closeButton': 'Discard',

                // Recovery Modal
                'recovery.title': 'CRASH RECOVERY',
                'recovery.detected': 'Interrupted session detected!',
                'recovery.message': 'A previous recording was interrupted. Would you like to restore it?',
                'recovery.chunkInfo': 'Available chunks',
                'recovery.restore': 'Restore',
                'recovery.discard': 'Discard',

                // Info Modal Sections
                'info.title': 'WAVEFORGE PRO - INFO',
                'info.close': 'Close',
                'info.introduction': 'Professional Browser-Based Offline Audio Workstation',
                'info.introText': 'WaveForge Pro is a cutting-edge Digital Audio Workstation (DAW) for browsers, optimized for long recordings (8+ hours) with intelligent CrashGuard system, cloud synchronization, and full BITV 2.0 accessibility compliance.',
                'info.offlineCapable': 'Offline-Capable',
                'info.multiBrowser': 'Multi-Browser',
                'info.storageOptimized': 'Storage-Optimized',
                'info.localDownload': 'Local Download',

                // Compliance
                'compliance.title': 'Compliance & Certifications',
                'compliance.wcag': 'WCAG 2.1 Level AA',
                'compliance.wcagDesc': 'Web Content Accessibility Guidelines',
                'compliance.bitv': 'BITV 2.0 Compliant',
                'compliance.bitvDesc': 'Barrier-Free IT Ordinance',
                'compliance.en': 'EN 301 549 Compliant',
                'compliance.enDesc': 'EU Accessibility Standard',

                // Features
                'features.title': 'Main Features',
                'features.recording': 'Recording & Production',
                'features.crashguard': 'CrashGuard System',
                'features.cloud': 'Cloud Synchronization',
                'features.accessibility': 'Accessibility',
                'features.offline': 'Offline & Multi-Browser',
                'features.performance': 'Performance & Storage',

                // Technical Specs
                'tech.title': 'Technical Specifications',
                'tech.frontend': 'Frontend:',
                'tech.backend': 'Backend:',
                'tech.storage': 'Storage:',
                'tech.audio': 'Audio API:',
                'tech.serviceWorker': 'Service Worker:',
                'tech.recorder': 'Recorder:',

                // Planned Features
                'planned.title': 'Planned Features (Roadmap)',
                'planned.webcomponent': 'WebComponent Integration',
                'planned.webcomponentDesc': 'Standalone component for Angular, React, Vue.js',
                'planned.multilang': 'Multi-Language Support',
                'planned.multilangDesc': 'German, English, French, Spanish, Italian',
                'planned.auth': 'Authentication & Security',
                'planned.authDesc': 'OAuth2, SAML, JWT, End-to-End Encryption',
                'planned.collab': 'Collaborative Recording',
                'planned.collabDesc': 'Multi-User Sessions, Real-Time Collaboration',
                'planned.theme': 'Theme Engine',
                'planned.themeDesc': 'Light/Dark Mode, Custom Color Schemes, Skins',
                'planned.effects': 'Advanced Effects',
                'planned.effectsDesc': 'Reverb, Delay, Compressor, Limiter, Noise Gate',
                'planned.multitrack': 'Multi-Track Recording',
                'planned.multitrackDesc': 'Parallel recording of multiple tracks',

                // Preview Warning
                'preview.title': 'Preview Version - Limitations',
                'preview.intro': 'This is a preview version to demonstrate core functionality. The following features are currently not implemented:',
                'preview.noAuth': 'Authentication',
                'preview.noAuthDesc': 'No login system, no user accounts',
                'preview.noAuthz': 'Authorization',
                'preview.noAuthzDesc': 'No role or permission management',
                'preview.noEncrypt': 'Encryption',
                'preview.noEncryptDesc': 'Encrypted data transmission is per TLS/SSL implemented, however no encrypted contents in local browser databases',
                'preview.noIntegration': 'Framework Integration',
                'preview.noIntegrationDesc': 'WebComponent for Angular/React not yet available',
                'preview.disclaimer': 'âš  This version is exclusively for testing and demonstration purposes and not suitable for production use.',

                // ARIA Labels
                'aria.selectLanguage': 'Select language',
                'aria.info': 'Show information and compliance',
                'aria.recordingDuration': 'Recording duration',
                'aria.startRecording': 'Start recording',
                'aria.stopRecording': 'Stop recording',
                'aria.inputLowShelf': 'Input Low-Shelf EQ',
                'aria.inputPeaking': 'Input Peaking EQ',
                'aria.inputHighShelf': 'Input High-Shelf EQ',
                'aria.inputGain': 'Input Gain',
                'aria.outputLowShelf': 'Output Low-Shelf EQ',
                'aria.outputPeaking': 'Output Peaking EQ',
                'aria.outputHighShelf': 'Output High-Shelf EQ',
                'aria.outputGain': 'Output Volume',
                'aria.selectFormat': 'Select recording format',
                'aria.visualizer': 'Audio Visualization',
                'aria.inputSection': 'Input Stage',
                'aria.outputSection': 'Output Stage',
                'aria.playlistSection': 'Recording List',
            }
        };

        // Upload Settings Logic
        function openUploadSettingsModal() {
            lastFocusedElement = document.activeElement; // Save current focus
            const modal = document.getElementById('uploadSettingsModal');
            modal.style.display = 'flex';
            modal.setAttribute('aria-hidden', 'false');

            // Load current setting
            const currentMethod = localStorage.getItem('waveforge_upload_method') || 'tus';
            const radio = document.querySelector(`input[name="uploadMethod"][value="${currentMethod}"]`);
            if (radio) radio.checked = true;

            setTimeout(() => {
                trapFocus(modal); // Enable focus trap
                // Focus modal title
                const modalTitle = modal.querySelector('#uploadSettingsModalTitle');
                if (modalTitle) modalTitle.focus();
            }, 10);
        }

        function closeUploadSettingsModal() {
            const modal = document.getElementById('uploadSettingsModal');
            modal.style.display = 'none';
            modal.setAttribute('aria-hidden', 'true');
            // Restore focus
            if (lastFocusedElement) {
                lastFocusedElement.focus();
                lastFocusedElement = null;
            }
        }

        function saveUploadSettings() {
            const selected = document.querySelector('input[name="uploadMethod"]:checked').value;
            localStorage.setItem('waveforge_upload_method', selected);
            closeUploadSettingsModal();
            // Reload page to apply changes if necessary, or just update global var
            if (window.uploadManager) {
                // If we had a global manager, we'd update it here.
                // For now, the upload logic checks localStorage directly or we should update a global config.
                console.log("Upload method updated to:", selected);
            }
        }

        let currentLanguage = 'de';

        function initLanguage() {
            // Check if user has saved preference
            const savedLang = localStorage.getItem('waveforge_language');
            if (savedLang && translations[savedLang]) {
                currentLanguage = savedLang;
                document.getElementById('languageSelector').value = savedLang;
            } else {
                // Detect browser language
                const browserLang = navigator.language.split('-')[0];
                if (translations[browserLang]) {
                    currentLanguage = browserLang;
                    document.getElementById('languageSelector').value = browserLang;
                }
            }

            // Update HTML lang attribute
            document.documentElement.lang = currentLanguage;

            // Apply translations
            translatePage();
        }

        function switchLanguage(lang) {
            if (!translations[lang]) return;
            currentLanguage = lang;
            localStorage.setItem('waveforge_language', lang);
            document.documentElement.lang = lang;
            translatePage();
        }

        function translatePage() {
            const t = translations[currentLanguage];

            // Translate elements with data-i18n attribute
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (t[key]) {
                    el.textContent = t[key];
                }
            });

            // Translate attributes (aria-label, placeholder, title, etc.)
            document.querySelectorAll('[data-i18n-attr]').forEach(el => {
                const attrs = el.getAttribute('data-i18n-attr').split(',');
                attrs.forEach(attr => {
                    const [attrName, key] = attr.trim().split(':');
                    if (t[key]) {
                        el.setAttribute(attrName, t[key]);
                    }
                });
            });

            // Update dynamic content that uses t() function
            updateFormatWarning();
            loadTracksFromDB(); // Refresh playlist with new language
        }

        function t(key) {
            return translations[currentLanguage][key] || key;
        }
    </script>
    
    <!-- TUS Upload Client (for main thread uploads) -->
    <script src="/tus.min.js"></script>
    <script src="/tus-upload-manager.js"></script>
</body>

</html>