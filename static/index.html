<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="WaveForge DAW - Professionelle Audio-Aufnahmesoftware mit CrashGuard und Cloud-Synchronisation">
    <title>WaveForge DAW - Preview Edition</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="manifest" href="/manifest.json">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;500;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --neon-cyan: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-red: #ff3333;
            --neon-yellow: #ffd700;
            --bg-dark: #050510;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        body {
            background-color: var(--bg-dark);
            background-image: 
                radial-gradient(circle at 50% 0%, #1a1a40 0%, transparent 50%),
                linear-gradient(0deg, rgba(0,243,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,243,255,0.03) 1px, transparent 1px);
            background-size: 100% 100%, 40px 40px, 40px 40px;
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            overflow-x: hidden;
            padding-bottom: 120px;
        }

        .glass-panel {
            background: var(--glass);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        /* Player Dock Styles */
        #playerDock {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(150%);
            width: 90%;
            max-width: 820px;
            background: rgba(10, 10, 26, 0.95);
            border: 1px solid var(--neon-cyan);
            box-shadow: 0 0 40px rgba(0, 243, 255, 0.15);
            border-radius: 16px;
            padding: 15px 25px;
            z-index: 100;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.27);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #playerDock.active {
            transform: translateX(-50%) translateY(0);
        }

        /* Seek Slider */
        .seek-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }
        .seek-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--neon-cyan);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--neon-cyan);
            cursor: pointer;
            transition: transform 0.1s;
        }
        .seek-slider::-webkit-slider-thumb:hover { transform: scale(1.3); }

        /* Control Buttons */
        .player-btn {
            background: transparent;
            border: 1px solid #444;
            color: #aaa;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            cursor: pointer;
        }
        .player-btn:hover {
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.3);
        }
        .player-btn.main-play {
            width: 50px;
            height: 50px;
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
            font-size: 1.2rem;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 150;
            display: none;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background: #0a0a1a;
            border: 1px solid var(--neon-cyan);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.2);
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            transform: scale(0.9);
            transition: transform 0.2s;
        }
        .modal-open .modal-content { transform: scale(1); }

        /* RECOVERY MODAL SPECIFIC */
        .recovery-modal .modal-content {
            border-color: var(--neon-red);
            box-shadow: 0 0 40px rgba(255, 51, 51, 0.3);
        }
        .recovery-btn {
            background: rgba(255, 51, 51, 0.1);
            color: var(--neon-red);
            border: 1px solid var(--neon-red);
        }
        .recovery-btn:hover {
            background: var(--neon-red);
            color: black;
            box-shadow: 0 0 15px var(--neon-red);
        }

        /* LICENSE MODAL SPECIFIC */
        .license-modal .modal-content {
            max-width: 600px;
            border-color: #ffd700; /* Gold for premium/business feel */
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.15);
        }
        .license-header {
            color: #ffd700;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
        }

        /* DELETE MODAL SPECIFIC */
        .delete-modal .modal-content {
            border-color: var(--neon-red);
            box-shadow: 0 0 40px rgba(255, 51, 51, 0.25);
            max-width: 400px;
        }
        .delete-btn {
            background: rgba(255, 51, 51, 0.1);
            color: var(--neon-red);
            border: 1px solid var(--neon-red);
            padding: 0.5rem 1.5rem;
            border-radius: 6px;
            font-weight: bold;
            transition: all 0.2s;
        }
        .delete-btn:hover {
            background: var(--neon-red);
            color: black;
            box-shadow: 0 0 15px var(--neon-red);
        }
        .cancel-btn {
            background: transparent;
            color: #9ca3af;
            border: 1px solid #4b5563;
            padding: 0.5rem 1.5rem;
            border-radius: 6px;
            transition: all 0.2s;
        }
        .cancel-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        /* UPLOAD STATUS STYLES (NEW) */
        .upload-status-bar {
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
            display: none;
        }
        .upload-status-fill {
            height: 100%;
            background: var(--neon-cyan);
            width: 0%;
            transition: width 0.3s ease;
        }
        /* Upload Icon Status Indicators */
        .upload-icon { 
            color: var(--neon-cyan); 
            border-color: var(--neon-cyan); 
            transition: all 0.3s ease;
        }
        .upload-icon:hover { background: rgba(0, 243, 255, 0.1); }
        
        .upload-icon.status-uploading {
            color: #3b82f6;
            border-color: #3b82f6;
            animation: pulse-upload 1.5s ease-in-out infinite;
        }
        .upload-icon.status-pending {
            color: #f59e0b;
            border-color: #f59e0b;
            opacity: 0.8;
        }
        .upload-icon.status-success {
            color: #10b981;
            border-color: #10b981;
            animation: successPop 0.4s ease-out;
        }
        .upload-icon.status-error {
            color: #ef4444;
            border-color: #ef4444;
            animation: shake 0.5s ease-in-out;
        }
        
        @keyframes pulse-upload {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }
        
        @keyframes successPop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }

        /* Faders & Ranges */
        .fader-group {
            display: flex; flex-direction: column; align-items: center; gap: 10px; height: 200px;
        }
        input[type=range][orient=vertical] {
            writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 8px; height: 120px; padding: 0 5px; background: transparent; cursor: pointer;
        }
        .range-wrapper {
            position: relative; width: 40px; height: 150px; display: flex; justify-content: center;
        }
        .custom-range {
            -webkit-appearance: none; width: 150px; height: 4px; background: #333; border-radius: 2px; outline: none; transform: rotate(-90deg); transform-origin: center; position: absolute; top: 70px;
        }
        .custom-range::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 10px; background: var(--neon-cyan); box-shadow: 0 0 10px var(--neon-cyan); cursor: pointer; border-radius: 2px; transition: all 0.1s ease;
        }
        .custom-range.pink::-webkit-slider-thumb {
            background: var(--neon-pink); box-shadow: 0 0 10px var(--neon-pink);
        }

        #visualizer {
            width: 100%; height: 120px; border-bottom: 1px solid var(--neon-cyan); mask-image: linear-gradient(to bottom, black 50%, transparent 100%);
        }

        .digital-text { font-family: 'Share Tech Mono', monospace; }
        
        /* Screen reader only - BITV 2.0 compliance */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        
        /* Focus visible for keyboard navigation - BITV 2.0 compliance */
        button:focus-visible, 
        input:focus-visible, 
        select:focus-visible, 
        a:focus-visible {
            outline: 2px solid var(--neon-cyan);
            outline-offset: 2px;
        }
        
        /* Skip to content link - BITV 2.0 compliance */
        .skip-to-content {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--neon-cyan);
            color: var(--bg-dark);
            padding: 8px 16px;
            text-decoration: none;
            font-weight: bold;
            z-index: 10000;
        }
        .skip-to-content:focus {
            top: 0;
        }
        
        @keyframes pulse-rec {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }

        .recording-active {
            animation: pulse-rec 1.5s infinite; background-color: #ff0055 !important; border-color: #ff0055 !important; color: white !important;
        }
        
        /* Select */
        .cyber-select {
            background: rgba(0,0,0,0.5); border: 1px solid #333; color: var(--neon-cyan); padding: 5px 10px; font-family: 'Share Tech Mono', monospace; border-radius: 4px; outline: none;
        }
        .cyber-select:focus { border-color: var(--neon-cyan); }

        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #050510; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--neon-cyan); }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4">
    <!-- BITV 2.0: Skip to content link for keyboard navigation -->
    <a href="#main-content" class="skip-to-content" data-i18n="ui.skipToContent">Zum Hauptinhalt springen</a>

    <!-- Header & Visualizer -->
    <header class="w-full max-w-5xl mb-6 glass-panel overflow-hidden relative" role="banner">
        <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-cyan-500 to-transparent opacity-50"></div>
        <div class="p-4 flex justify-between items-end relative z-10 bg-black/20">
            <div>
                <h1 class="text-3xl font-bold tracking-widest uppercase text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-600" style="text-shadow: 0 0 20px rgba(0,243,255,0.3);">
                    WAVE<span class="text-white">FORGE</span>
                </h1>
                <p class="text-xs text-gray-400 tracking-[0.2em] mt-1" data-i18n="ui.crashguard">CRASHGUARD // RAID PROTECTED SYSTEM</p>
            </div>
            <div class="flex flex-col items-end gap-1">
                <div class="flex items-center gap-2 mb-1">
                    <!-- Language Selector -->
                    <label for="languageSelector" class="sr-only" data-i18n="aria.selectLanguage">Sprache ausw√§hlen</label>
                    <select id="languageSelector" 
                            onchange="switchLanguage(this.value)"
                            class="cyber-select text-[10px] px-2 py-1 border-gray-700 hover:border-cyan-500/50"
                            aria-label="Sprache ausw√§hlen">
                        <option value="de">üá©üá™ DE</option>
                        <option value="en">üá¨üáß EN</option>
                    </select>
                    <!-- Info Button -->
                    <button onclick="openInfoModal()" 
                            class="text-[10px] text-gray-500 hover:text-cyan-400 transition-colors flex items-center gap-1 border border-gray-800 rounded px-2 py-0.5 hover:border-cyan-500/50"
                            aria-label="Informationen und Compliance anzeigen"
                            data-i18n-attr="aria-label:aria.info"
                            type="button">
                        <span class="text-cyan-400" aria-hidden="true">‚Ñπ</span> <span data-i18n="ui.info">INFO</span>
                    </button>
                </div>
                <div id="statusIndicator" class="text-xs digital-text text-cyan-400" role="status" aria-live="polite" data-i18n="status.ready">SYSTEM READY</div>
                <div id="timerDisplay" class="text-2xl digital-text font-bold text-white" role="timer" aria-live="off" aria-label="Aufnahmedauer" data-i18n-attr="aria-label:aria.recordingDuration">00:00:00</div>
            </div>
        </div>
        <canvas id="visualizer" aria-label="Audio-Visualisierung"></canvas>
    </header>

    <main id="main-content" class="w-full max-w-5xl grid grid-cols-1 lg:grid-cols-12 gap-6" role="main">
        
        <!-- LEFT: Controls & EQ -->
        <div class="lg:col-span-7 space-y-6">
            
            <!-- Recording / Input Section -->
            <section class="glass-panel p-6 relative overflow-hidden" aria-label="Eingangsstufe" data-i18n-attr="aria-label:aria.inputSection">
                <div class="absolute top-0 right-0 p-2 text-[10px] text-gray-500 font-mono border-l border-b border-gray-800" data-i18n="ui.inputStage">INPUT STAGE</div>
                
                <div class="flex items-center justify-between mb-6 flex-wrap gap-4">
                    <h2 class="text-xl font-bold flex items-center gap-2">
                        <span class="w-2 h-2 bg-cyan-500 rounded-full shadow-[0_0_10px_#00f3ff]"></span> 
                        <span data-i18n="ui.input">INPUT</span>
                    </h2>
                    
                    <div class="flex flex-col gap-1">
                        <div class="flex items-center gap-2 bg-black/30 p-1 rounded border border-gray-800">
                            <label class="text-[10px] text-gray-400 pl-2" data-i18n="ui.format">FORMAT:</label>
                            <label for="recordingFormat" class="sr-only">Aufnahmeformat</label>
                            <select id="recordingFormat" 
                                    onchange="updateFormatWarning()" 
                                    class="cyber-select text-xs border-none bg-transparent"
                                    aria-label="Aufnahmeformat ausw√§hlen">
                                <option value="webm">WEBM (Opus Codec)</option>
                                <option value="wav">WAV</option>
                                <option value="mp3">MP3</option>
                            </select>
                        </div>
                        <div id="ramWarning" class="text-[9px] font-mono text-green-400 pl-1">
                            ‚úì LOW RAM MODE (Safe for 8h+)
                        </div>
                    </div>

                    <div class="flex gap-3">
                        <button id="recordButton" 
                                class="px-6 py-2 rounded border border-red-500/50 text-red-400 hover:bg-red-500/10 hover:text-white transition-all font-mono tracking-wider text-sm uppercase flex items-center gap-2"
                                aria-label="Aufnahme starten"
                                data-i18n-attr="aria-label:aria.startRecording"
                                type="button">
                            <span class="w-2 h-2 rounded-full bg-current" aria-hidden="true"></span> <span data-i18n="ui.rec">REC</span>
                        </button>
                        <button id="stopButton" 
                                class="px-6 py-2 rounded border border-gray-600 text-gray-400 hover:bg-white/10 transition-all font-mono tracking-wider text-sm uppercase" 
                                disabled
                                aria-label="Aufnahme stoppen"
                                aria-disabled="true"
                                data-i18n-attr="aria-label:aria.stopRecording"
                                type="button">
                            <span data-i18n="ui.stop">STOP</span>
                        </button>
                    </div>
                </div>

                <div class="grid grid-cols-4 gap-2">
                    <!-- Faders -->
                    <div class="fader-group">
                        <div class="range-wrapper">
                            <label for="inputLowShelf" class="sr-only">Eingangs-Low-Shelf EQ</label>
                            <input type="range" 
                                   id="inputLowShelf" 
                                   min="-20" 
                                   max="20" 
                                   step="1" 
                                   value="0" 
                                   class="custom-range"
                                   aria-label="Eingangs-Low-Shelf: 0 dB"
                                   aria-valuemin="-20"
                                   aria-valuemax="20"
                                   aria-valuenow="0"
                                   aria-valuetext="0 Dezibel">
                        </div>
                        <span class="text-xs text-cyan-300 font-mono mt-[-20px]" data-i18n="ui.low">LOW</span>
                        <span id="val-inputLow" class="text-[10px] text-gray-500">0dB</span>
                    </div>
                    <div class="fader-group">
                        <div class="range-wrapper">
                            <label for="inputPeaking" class="sr-only">Eingangs-Peaking EQ</label>
                            <input type="range" 
                                   id="inputPeaking" 
                                   min="-20" 
                                   max="20" 
                                   step="1" 
                                   value="0" 
                                   class="custom-range"
                                   aria-label="Eingangs-Peaking: 0 dB"
                                   aria-valuemin="-20"
                                   aria-valuemax="20"
                                   aria-valuenow="0"
                                   aria-valuetext="0 Dezibel">
                        </div>
                        <span class="text-xs text-cyan-300 font-mono mt-[-20px]" data-i18n="ui.mid">MID</span>
                        <span id="val-inputMid" class="text-[10px] text-gray-500">0dB</span>
                    </div>
                    <div class="fader-group">
                        <div class="range-wrapper">
                            <label for="inputHighShelf" class="sr-only">Eingangs-High-Shelf EQ</label>
                            <input type="range" 
                                   id="inputHighShelf" 
                                   min="-20" 
                                   max="20" 
                                   step="1" 
                                   value="0" 
                                   class="custom-range"
                                   aria-label="Eingangs-High-Shelf: 0 dB"
                                   aria-valuemin="-20"
                                   aria-valuemax="20"
                                   aria-valuenow="0"
                                   aria-valuetext="0 Dezibel">
                        </div>
                        <span class="text-xs text-cyan-300 font-mono mt-[-20px]" data-i18n="ui.high">HIGH</span>
                        <span id="val-inputHigh" class="text-[10px] text-gray-500">0dB</span>
                    </div>
                    <div class="fader-group">
                        <div class="range-wrapper">
                            <label for="inputGain" class="sr-only">Eingangsverst√§rkung</label>
                            <input type="range" 
                                   id="inputGain" 
                                   min="0" 
                                   max="2" 
                                   step="0.1" 
                                   value="1" 
                                   class="custom-range pink"
                                   aria-label="Eingangsverst√§rkung: 1.0x"
                                   aria-valuemin="0"
                                   aria-valuemax="2"
                                   aria-valuenow="1"
                                   aria-valuetext="1.0 fache Verst√§rkung">
                        </div>
                        <span class="text-xs text-pink-400 font-mono mt-[-20px]" data-i18n="ui.gain">GAIN</span>
                        <span id="val-inputGain" class="text-[10px] text-gray-500">100%</span>
                    </div>
                </div>
            </section>

            <!-- Playback EQ Section -->
            <section class="glass-panel p-6 relative overflow-hidden" aria-label="Ausgangsstufe" data-i18n-attr="aria-label:aria.outputSection">
                <div class="absolute top-0 right-0 p-2 text-[10px] text-gray-500 font-mono border-l border-b border-gray-800" data-i18n="ui.outputStage">OUTPUT STAGE</div>
                <h2 class="text-xl font-bold flex items-center gap-2 mb-6">
                    <span class="w-2 h-2 bg-pink-500 rounded-full shadow-[0_0_10px_#ff00ff]"></span> 
                    <span data-i18n="ui.output">OUTPUT</span>
                </h2>
                <div class="grid grid-cols-4 gap-2">
                    <div class="fader-group">
                        <div class="range-wrapper">
                            <label for="outputLowShelf" class="sr-only">Ausgangs-Low-Shelf EQ</label>
                            <input type="range" 
                                   id="outputLowShelf" 
                                   min="-20" 
                                   max="20" 
                                   step="1" 
                                   value="0" 
                                   class="custom-range pink"
                                   aria-label="Ausgangs-Low-Shelf: 0 dB"
                                   aria-valuemin="-20"
                                   aria-valuemax="20"
                                   aria-valuenow="0"
                                   aria-valuetext="0 Dezibel">
                        </div>
                        <span class="text-xs text-pink-300 font-mono mt-[-20px]">LOW</span>
                        <span id="val-outputLow" class="text-[10px] text-gray-500">0dB</span>
                    </div>
                    <div class="fader-group">
                        <div class="range-wrapper">
                            <label for="outputPeaking" class="sr-only">Ausgangs-Peaking EQ</label>
                            <input type="range" 
                                   id="outputPeaking" 
                                   min="-20" 
                                   max="20" 
                                   step="1" 
                                   value="0" 
                                   class="custom-range pink"
                                   aria-label="Ausgangs-Peaking: 0 dB"
                                   aria-valuemin="-20"
                                   aria-valuemax="20"
                                   aria-valuenow="0"
                                   aria-valuetext="0 Dezibel">
                        </div>
                        <span class="text-xs text-pink-300 font-mono mt-[-20px]">MID</span>
                        <span id="val-outputMid" class="text-[10px] text-gray-500">0dB</span>
                    </div>
                    <div class="fader-group">
                        <div class="range-wrapper">
                            <label for="outputHighShelf" class="sr-only">Ausgangs-High-Shelf EQ</label>
                            <input type="range" 
                                   id="outputHighShelf" 
                                   min="-20" 
                                   max="20" 
                                   step="1" 
                                   value="0" 
                                   class="custom-range pink"
                                   aria-label="Ausgangs-High-Shelf: 0 dB"
                                   aria-valuemin="-20"
                                   aria-valuemax="20"
                                   aria-valuenow="0"
                                   aria-valuetext="0 Dezibel">
                        </div>
                        <span class="text-xs text-pink-300 font-mono mt-[-20px]">HIGH</span>
                        <span id="val-outputHigh" class="text-[10px] text-gray-500">0dB</span>
                    </div>
                    <div class="fader-group">
                        <div class="range-wrapper">
                            <label for="outputGain" class="sr-only">Ausgangslautst√§rke</label>
                            <input type="range" 
                                   id="outputGain" 
                                   min="0" 
                                   max="2" 
                                   step="0.1" 
                                   value="1" 
                                   class="custom-range"
                                   aria-label="Ausgangslautst√§rke: 1.0x"
                                   aria-valuemin="0"
                                   aria-valuemax="2"
                                   aria-valuenow="1"
                                   aria-valuetext="1.0 fache Lautst√§rke">
                        </div>
                        <span class="text-xs text-cyan-400 font-mono mt-[-20px]">VOL</span>
                        <span id="val-outputGain" class="text-[10px] text-gray-500">100%</span>
                    </div>
                </div>
            </section>
        </div>

        <!-- RIGHT: Library / Playlist -->
        <div class="lg:col-span-5 flex flex-col h-full">
            <div class="glass-panel p-6 flex-grow flex flex-col h-[600px] lg:h-auto" role="region" aria-label="Aufnahmedatenbank">
                <div class="flex justify-between items-center mb-4 pb-4 border-b border-gray-800">
                    <div>
                        <h2 class="text-xl font-bold font-mono text-gray-200" data-i18n="playlist.title">RECORDINGS</h2>
                        <div class="text-[10px] text-gray-500" id="formatInfo" aria-live="polite" data-i18n="format.detecting">FORMAT: DETECTING...</div>
                    </div>
                    <div class="flex items-center gap-2">
                        <span id="uploadStatus" class="text-[10px] text-cyan-400 hidden animate-pulse" aria-live="polite" role="status">UPLOADING...</span>
                        <span id="dbStatus" class="text-[10px] bg-green-900/30 text-green-400 px-2 py-1 rounded border border-green-900">DB ONLINE</span>
                    </div>
                </div>

                <div id="playlist" class="flex-grow overflow-y-auto space-y-2 pr-2">
                    <div class="text-center text-gray-600 mt-10 digital-text">LOADING DATA...</div>
                </div>
                
                <div id="storageInfo" class="mt-4 pt-4 border-t border-gray-800 text-xs text-gray-500 font-mono flex justify-between">
                    <span>LOCAL STORAGE</span>
                    <span id="trackCount">0 TRACKS</span>
                </div>
            </div>
        </div>
    </main>

    <!-- FLOATING PLAYER DOCK -->
    <div id="playerDock">
        <div class="flex items-center justify-between mb-2">
            <div class="flex items-center gap-2">
                <label for="playbackSpeed" class="text-[10px] text-gray-500 font-mono">SPEED:</label>
                <select id="playbackSpeed"  
                        onchange="changePlaybackSpeed(this.value)"
                        class="cyber-select text-xs px-2 py-1 border-gray-700"
                        aria-label="Wiedergabegeschwindigkeit">
                    <option value="0.25">0.25x</option>
                    <option value="0.5">0.5x</option>
                    <option value="0.75">0.75x</option>
                    <option value="1" selected>1x</option>
                    <option value="1.25">1.25x</option>
                    <option value="1.5">1.5x</option>
                    <option value="1.75">1.75x</option>
                    <option value="2">2x</option>
                </select>
            </div>
            <button onclick="closeDock()" 
                    class="player-btn text-xs w-6 h-6" 
                    aria-label="Player schlie√üen"
                    type="button">√ó</button>
        </div>
        <div class="flex items-center gap-3 w-full mb-1">
            <span id="currentTime" class="text-xs font-mono text-cyan-400 w-12 text-right" aria-label="Aktuelle Zeit">00:00</span>
            <div class="flex-grow relative">
                <label for="seekSlider" class="sr-only">Wiedergabeposition</label>
                <input type="range" 
                       id="seekSlider" 
                       class="seek-slider" 
                       min="0" 
                       max="100" 
                       value="0" 
                       step="0.01"
                       oninput="playerSeek(this.value)"
                       onmousedown="window.isSeekDragging=true"
                       onmouseup="window.isSeekDragging=false"
                       ontouchstart="window.isSeekDragging=true"
                       ontouchend="window.isSeekDragging=false"
                       aria-label="Wiedergabeposition"
                       aria-valuemin="0"
                       aria-valuemax="100"
                       aria-valuenow="0"
                       aria-valuetext="0 Prozent">
            </div>
            <span id="totalTime" class="text-xs font-mono text-gray-400 w-12" aria-label="Gesamtdauer">00:00</span>
        </div>
        <div class="flex justify-center items-center gap-4">
            <button onclick="playerSeekStart()" 
                    class="player-btn text-xs" 
                    aria-label="Zum Anfang springen"
                    type="button">|<</button>
            <button onclick="playerSkip(-10)" 
                    class="player-btn text-xs" 
                    aria-label="10 Sekunden zur√ºck"
                    type="button">-10s</button>
            <button id="dockPlayBtn" 
                    onclick="togglePlayPause()" 
                    class="player-btn main-play"
                    aria-label="Abspielen"
                    type="button">‚ñ∂</button>
            <button onclick="playerSkip(10)" 
                    class="player-btn text-xs" 
                    aria-label="10 Sekunden vorw√§rts"
                    type="button">+10s</button>
            <button onclick="playerSeekEnd()" 
                    class="player-btn text-xs" 
                    aria-label="Zum Ende springen"
                    type="button">>|</button>
        </div>
        <div class="text-center">
            <div id="nowPlayingText" class="text-[10px] text-gray-400 tracking-wider font-mono truncate">NO TRACK SELECTED</div>
        </div>
    </div>

    <!-- SAVE MODAL -->
    <div id="saveModal" class="modal-overlay" aria-hidden="true">
        <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="saveModalTitle">
            <h2 id="saveModalTitle" class="text-xl font-bold text-white mb-4 border-b border-gray-700 pb-2">SAVE SEQUENCE</h2>
            <div class="mb-4">
                <label for="saveNameInput" class="block text-gray-400 text-xs mb-1">NAME</label>
                <input type="text" 
                       id="saveNameInput" 
                       class="w-full bg-black/50 border border-gray-700 rounded p-2 text-white focus:border-cyan-400 outline-none" 
                       placeholder="Enter sequence name..."
                       aria-label="Sequenzname eingeben"
                       aria-required="true">
            </div>
            <div class="mb-6">
                <label class="block text-gray-400 text-xs mb-1">SELECTED FORMAT</label>
                <div id="saveFormatDisplay" class="text-cyan-400 font-mono text-sm">WEBM</div>
                <div id="processingWarning" class="text-[10px] text-yellow-500 mt-1 hidden">‚ö† Converting large files may require high RAM.</div>
            </div>
            <div class="flex gap-3 justify-end">
                <button onclick="closeSaveModal()" 
                        class="px-4 py-2 rounded text-gray-400 hover:bg-white/10 text-sm"
                        aria-label="Verwerfen und schlie√üen"
                        type="button">DISCARD</button>
                <button onclick="confirmSave()" 
                        class="px-6 py-2 rounded bg-cyan-600 hover:bg-cyan-500 text-white font-bold text-sm shadow-[0_0_15px_rgba(0,243,255,0.4)]"
                        aria-label="In Datenbank speichern"
                        type="button">SAVE TO DB</button>
            </div>
            <div id="processingIndicator" class="hidden mt-4 text-center text-xs text-pink-400 animate-pulse">PROCESSING AUDIO... PLEASE WAIT</div>
        </div>
    </div>

    <!-- RECOVERY MODAL -->
    <div id="recoveryModal" class="modal-overlay recovery-modal" aria-hidden="true">
        <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="recoveryModalTitle">
            <h2 id="recoveryModalTitle" class="text-xl font-bold text-red-500 mb-4 border-b border-red-900 pb-2 flex items-center gap-2">
                <span class="animate-pulse" aria-hidden="true">‚ö†</span> SYSTEM ALERT
            </h2>
            <p class="text-sm text-gray-300 mb-4">
                The system detected a crash or unexpected closure during an active recording session. RAID fragments have been recovered.
            </p>
            
            <div class="bg-red-900/20 border border-red-900/50 p-3 rounded mb-6">
                <div class="text-[10px] text-red-400 font-mono mb-1">RECOVERED SESSION ID:</div>
                <div id="recoveryId" class="text-xs font-mono text-white truncate">...</div>
                <div class="flex justify-between mt-2">
                    <span class="text-[10px] text-gray-400">CHUNKS: <span id="recoveryChunks" class="text-white">0</span></span>
                    <span class="text-[10px] text-gray-400">SIZE: <span id="recoverySize" class="text-white">0 MB</span></span>
                </div>
            </div>

            <div class="flex gap-3 justify-end">
                <button onclick="CrashGuard.discardSession()" 
                        class="px-4 py-2 rounded text-gray-400 hover:text-red-400 hover:bg-red-900/20 text-sm"
                        aria-label="Wiederherstellungsdaten l√∂schen"
                        type="button">PURGE DATA</button>
                <button onclick="CrashGuard.assembleSession(null, true)" 
                        class="recovery-btn px-6 py-2 rounded font-bold text-sm shadow-[0_0_15px_rgba(255,51,51,0.4)]"
                        aria-label="Sitzung wiederherstellen und speichern"
                        type="button">RESTORE & SAVE</button>
            </div>
        </div>
    </div>

    <!-- INFO MODAL -->
    <div id="infoModal" class="modal-overlay license-modal" aria-hidden="true">
        <div class="modal-content text-gray-200 font-sans max-h-[90vh] overflow-y-auto" role="dialog" aria-modal="true" aria-labelledby="infoModalTitle">
            <div class="flex justify-between items-start mb-6 license-header pb-3 sticky top-0 bg-gray-900 z-10">
                <h2 id="infoModalTitle" class="text-xl font-bold font-mono tracking-widest text-cyan-400">WAVEFORGE PRO - INFO</h2>
                <button onclick="closeInfoModal()" 
                        class="text-gray-500 hover:text-white text-2xl leading-none"
                        aria-label="Informationen schlie√üen"
                        type="button">&times;</button>
            </div>

            <!-- INTRODUCTION -->
            <div class="bg-gradient-to-r from-cyan-900/20 to-blue-900/20 border border-cyan-800/40 p-5 rounded-lg mb-6">
                <h3 class="font-bold text-cyan-400 text-lg mb-3">Professionelle Audio-Workstation f√ºr Browser</h3>
                <p class="text-sm text-gray-300 leading-relaxed mb-3">
                    WaveForge Pro ist eine hochmoderne Digital Audio Workstation (DAW), die vollst√§ndig im Browser l√§uft - OFFLINE!. 
                    Mit fortschrittlicher CrashGuard-Technologie erm√∂glicht sie unterbrechungsfreie Langzeitaufnahmen von √ºber 8 Stunden 
                    und bietet dabei professionelle Features wie Echtzeit-EQ, Cloud-Synchronisation und automatische Wiederherstellung.
                </p>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs">
                    <div class="bg-black/40 p-2 rounded border border-gray-700">
                        <span class="text-cyan-400">‚úì</span> <strong class="text-white">Offline-f√§hig</strong>
                    </div>
                    <div class="bg-black/40 p-2 rounded border border-gray-700">
                        <span class="text-cyan-400">‚úì</span> <strong class="text-white">Multi-Browser</strong>
                    </div>
                    <div class="bg-black/40 p-2 rounded border border-gray-700">
                        <span class="text-cyan-400">‚úì</span> <strong class="text-white">Speicher-optimiert</strong>
                    </div>
                    <div class="bg-black/40 p-2 rounded border border-gray-700">
                        <span class="text-cyan-400">‚úì</span> <strong class="text-white">Lokaler Download</strong>
                    </div>
                </div>
            </div>

            <!-- COMPLIANCE CERTIFICATIONS -->
            <div class="bg-gray-800/30 border border-gray-700 p-4 rounded mb-6">
                <h3 class="font-bold text-gray-200 mb-3 text-sm uppercase tracking-wide">
                    Compliance & Zertifizierungen
                </h3>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                    <div class="bg-black/30 p-3 rounded border border-gray-700">
                        <div class="text-gray-200 font-bold text-sm mb-1">WCAG 2.1</div>
                        <div class="text-xs text-gray-400">Level AA</div>
                        <div class="text-[10px] text-cyan-400 mt-1">‚úì Compliant</div>
                    </div>
                    <div class="bg-black/30 p-3 rounded border border-gray-700">
                        <div class="text-gray-200 font-bold text-sm mb-1">BITV 2.0</div>
                        <div class="text-xs text-gray-400">DE Accessibility</div>
                        <div class="text-[10px] text-cyan-400 mt-1">‚úì Compliant</div>
                    </div>
                    <div class="bg-black/30 p-3 rounded border border-gray-700">
                        <div class="text-gray-200 font-bold text-sm mb-1">EN 301 549</div>
                        <div class="text-xs text-gray-400">EU Standard</div>
                        <div class="text-[10px] text-cyan-400 mt-1">‚úì Compliant</div>
                    </div>
                </div>
                <p class="text-xs text-gray-400 mt-3">Vollst√§ndige Barrierefreiheit f√ºr Screenreader, Tastaturnavigation und assistive Technologien.</p>
            </div>

            <!-- FEATURES -->
            <div class="space-y-4 text-sm leading-relaxed">
                <h3 class="font-bold text-gray-200 uppercase tracking-wide text-sm border-b border-gray-700 pb-2">Hauptfunktionen</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div class="bg-gray-800/30 border border-gray-700 p-3 rounded">
                        <h4 class="font-bold text-gray-200 text-xs mb-2">üéô Aufnahme & Produktion</h4>
                        <ul class="text-xs text-gray-400 space-y-1">
                            <li>‚Ä¢ 8+ Stunden Langzeitaufnahme</li>
                            <li>‚Ä¢ WEBM, WAV, MP3 Format-Support</li>
                            <li>‚Ä¢ Echtzeit-Wellenform-Visualisierung</li>
                            <li>‚Ä¢ 3-Band EQ (Low/Mid/High)</li>
                            <li>‚Ä¢ Lokaler Download als Audio-Datei</li>
                        </ul>
                    </div>
                    <div class="bg-gray-800/30 border border-gray-700 p-3 rounded">
                        <h4 class="font-bold text-gray-200 text-xs mb-2">üõ° CrashGuard System</h4>
                        <ul class="text-xs text-gray-400 space-y-1">
                            <li>‚Ä¢ Automatische Crash-Wiederherstellung</li>
                            <li>‚Ä¢ RAID-√§hnliche Chunk-Sicherung</li>
                            <li>‚Ä¢ Atomare Schreiboperationen (fsync)</li>
                            <li>‚Ä¢ L√ºckenlose Datenintegrit√§t</li>
                            <li>‚Ä¢ Session-Recovery bei Absturz</li>
                        </ul>
                    </div>
                    <div class="bg-gray-800/30 border border-gray-700 p-3 rounded">
                        <h4 class="font-bold text-gray-200 text-xs mb-2">‚òÅ Cloud-Synchronisation</h4>
                        <ul class="text-xs text-gray-400 space-y-1">
                            <li>‚Ä¢ Service Worker Background-Upload</li>
                            <li>‚Ä¢ Intelligenter Retry-Mechanismus</li>
                            <li>‚Ä¢ Offline-Queue mit Persistenz</li>
                            <li>‚Ä¢ Automatische Netzwerk-Erkennung</li>
                            <li>‚Ä¢ Hash-basiertes Sharding (Skalierbar)</li>
                        </ul>
                    </div>
                    <div class="bg-gray-800/30 border border-gray-700 p-3 rounded">
                        <h4 class="font-bold text-gray-200 text-xs mb-2">‚ôø Barrierefreiheit</h4>
                        <ul class="text-xs text-gray-400 space-y-1">
                            <li>‚Ä¢ ARIA Labels & Semantic HTML</li>
                            <li>‚Ä¢ Vollst√§ndige Tastatur-Navigation</li>
                            <li>‚Ä¢ Screen Reader Unterst√ºtzung</li>
                            <li>‚Ä¢ Focus Management & Skip Links</li>
                            <li>‚Ä¢ BITV 2.0 / WCAG 2.1 AA konform</li>
                        </ul>
                    </div>
                    <div class="bg-gray-800/30 border border-gray-700 p-3 rounded">
                        <h4 class="font-bold text-gray-200 text-xs mb-2">üì± Offline & Multi-Browser</h4>
                        <ul class="text-xs text-gray-400 space-y-1">
                            <li>‚Ä¢ <strong>Offline First:</strong> Volle Funktionalit√§t ohne Internet</li>
                            <li>‚Ä¢ IndexedDB f√ºr lokale Speicherung</li>
                            <li>‚Ä¢ <strong>Browser-Support:</strong> Chrome, Firefox, Edge</li>
                            <li>‚Ä¢ Safari, Brave, Opera kompatibel</li>
                            <li>‚Ä¢ Progressive Web App (PWA) Ready</li>
                        </ul>
                    </div>
                    <div class="bg-gray-800/30 border border-gray-700 p-3 rounded">
                        <h4 class="font-bold text-gray-200 text-xs mb-2">‚ö° Performance & Speicher</h4>
                        <ul class="text-xs text-gray-400 space-y-1">
                            <li>‚Ä¢ Speicheroptimiert (< 100 MB RAM)</li>
                            <li>‚Ä¢ Streaming-basierte Verarbeitung</li>
                            <li>‚Ä¢ Chunk-basierte Aufnahme (10 Sek.)</li>
                            <li>‚Ä¢ Lazy Loading von Audio-Daten</li>
                            <li>‚Ä¢ Effiziente IndexedDB-Nutzung</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- TECHNICAL SPECS -->
            <div class="mt-6 space-y-3">
                <h3 class="font-bold text-gray-200 uppercase tracking-wide text-sm border-b border-gray-700 pb-2">Technische Spezifikationen</h3>
                <div class="grid grid-cols-2 gap-2 text-xs">
                    <div class="bg-gray-800/30 p-2 rounded border border-gray-700">
                        <span class="text-gray-400">Frontend:</span>
                        <span class="text-gray-200 ml-2">HTML5, Tailwind CSS</span>
                    </div>
                    <div class="bg-gray-800/30 p-2 rounded border border-gray-700">
                        <span class="text-gray-400">Backend:</span>
                        <span class="text-gray-200 ml-2">Python 3.13+, FastAPI</span>
                    </div>
                    <div class="bg-gray-800/30 p-2 rounded border border-gray-700">
                        <span class="text-gray-400">Storage:</span>
                        <span class="text-gray-200 ml-2">IndexedDB (Client)</span>
                    </div>
                    <div class="bg-gray-800/30 p-2 rounded border border-gray-700">
                        <span class="text-gray-400">Audio API:</span>
                        <span class="text-gray-200 ml-2">Web Audio API</span>
                    </div>
                    <div class="bg-gray-800/30 p-2 rounded border border-gray-700">
                        <span class="text-gray-400">Service Worker:</span>
                        <span class="text-gray-200 ml-2">Background Sync</span>
                    </div>
                    <div class="bg-gray-800/30 p-2 rounded border border-gray-700">
                        <span class="text-gray-400">Recorder:</span>
                        <span class="text-gray-200 ml-2">MediaRecorder API</span>
                    </div>
                </div>
            </div>

            <!-- PLANNED FEATURES -->
            <div class="mt-6 bg-gray-800/30 border border-gray-700 p-4 rounded">
                <h3 class="font-bold text-gray-200 mb-2 text-sm uppercase tracking-wide flex items-center gap-2">
                    <span aria-hidden="true">üöÄ</span> Geplante Features (Roadmap)
                </h3>
                <ul class="space-y-2 text-xs text-gray-400">
                    <li class="flex items-start gap-2">
                        <span class="text-cyan-400 mt-0.5">‚ñ∏</span>
                        <div><strong class="text-gray-200">WebComponent-Integration:</strong> Standalone Component f√ºr Angular, React, Vue.js</div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-cyan-400 mt-0.5">‚ñ∏</span>
                        <div><strong class="text-gray-200">Multi-Language Support:</strong> Deutsch, English, Fran√ßais, Espa√±ol, Italiano</div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-cyan-400 mt-0.5">‚ñ∏</span>
                        <div><strong class="text-gray-200">Authentifizierung & Sicherheit:</strong> OAuth2, SAML, JWT, End-to-End Encryption</div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-cyan-400 mt-0.5">‚ñ∏</span>
                        <div><strong class="text-gray-200">Collaborative Recording:</strong> Multi-User Sessions, Real-Time Collaboration</div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-cyan-400 mt-0.5">‚ñ∏</span>
                        <div><strong class="text-gray-200">Theme Engine:</strong> Light/Dark Mode, Custom Color Schemes, Skins</div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-cyan-400 mt-0.5">‚ñ∏</span>
                        <div><strong class="text-gray-200">Advanced Effects:</strong> Reverb, Delay, Compressor, Limiter, Noise Gate</div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-cyan-400 mt-0.5">‚ñ∏</span>
                        <div><strong class="text-gray-200">Multi-Track Recording:</strong> Parallele Aufnahme mehrerer Spuren</div>
                    </li>
                </ul>
            </div>

            <!-- PREVIEW WARNING -->
            <div class="mt-6 bg-gray-800/30 border border-gray-700 p-4 rounded">
                <h3 class="font-bold text-gray-200 mb-3 text-sm uppercase tracking-wide">
                    Preview Version - Limitations
                </h3>
                <p class="text-sm text-gray-300 mb-3">
                    This is a preview version to demonstrate core functionality. The following features are currently <strong>not implemented</strong>:
                </p>
                <ul class="space-y-2 text-xs text-gray-400">
                    <li class="flex items-start gap-2">
                        <span class="text-gray-500 mt-0.5">‚ñ∏</span>
                        <div><strong class="text-gray-200">Authentication:</strong> No login system, no user accounts</div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-gray-500 mt-0.5">‚ñ∏</span>
                        <div><strong class="text-gray-200">Authorization:</strong> No role or permission management</div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-gray-500 mt-0.5">‚ñ∏</span>
                        <div><strong class="text-gray-200">Encryption:</strong> Data transmission is per TLS/SSL encrypted, however no encrypted contents in local browser databases</div>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-gray-500 mt-0.5">‚ñ∏</span>
                        <div><strong class="text-gray-200">Framework Integration:</strong> WebComponent for Angular/React not yet available</div>
                    </li>
                </ul>
                <div class="mt-3 pt-3 border-t border-gray-700">
                    <p class="text-xs text-gray-400">‚ö† This version is exclusively for testing and demonstration purposes and not suitable for production use.</p>
                </div>
            </div>

            <!-- LICENSE -->
            <div class="mt-6 bg-gray-800/30 border border-gray-700 p-4 rounded">
                <h3 class="font-bold text-gray-200 uppercase tracking-wide text-sm border-b border-gray-700 pb-2 mb-4">Lizenz & Nutzungsrechte</h3>
                
                <div class="space-y-3 text-sm text-gray-300">
                    <div>
                        <h4 class="font-bold text-gray-200 mb-1">Herausgeber</h4>
                        <p class="text-xs">Nina Ennekes<br>
                        <a href="https://www.xing.com/profile/Nina_Ennekes" target="_blank" rel="noopener noreferrer" class="text-cyan-400 hover:underline">https://www.xing.com/profile/Nina_Ennekes</a><br>
                        <span class="text-gray-500">¬© 2025 All Rights Reserved</span></p>
                    </div>
                    
                    <div class="pt-2 border-t border-gray-700">
                        <h4 class="font-bold text-gray-200 mb-2">Business Source License 1.1</h4>
                        <p class="text-xs text-gray-400 mb-3">Diese Software unterliegt der Business Source License 1.1 mit Dual-Lizenzierungsoptionen.</p>
                        
                        <div class="space-y-2 text-xs">
                            <div>
                                <strong class="text-gray-150">A) Nicht-kommerzielle Nutzung ‚Äì Apache 2.0</strong>
                                <p class="text-gray-400 mt-1">Die Software darf f√ºr nicht-kommerzielle Zwecke (privat, Forschung, Bildung) unter der Apache License 2.0 genutzt werden.</p>
                            </div>
                            
                            <div class="pt-2 border-t border-gray-700">
                                <strong class="text-gray-150">B) Kommerzielle Nutzung ‚Äì Business Source License 1.1</strong>
                                <div class="space-y-1 text-gray-400 mt-1">
                                    <div><span class="text-gray-300">Unmodifiziert:</span> Die Software darf unver√§ndert f√ºr kommerzielle Zwecke frei eingesetzt werden.</div>
                                    <div><span class="text-gray-300">Open-Source Umsetzung:</span> Neue Anforderungen und Pull-Requests k√∂nnen nach Ermessen des Autors kostenlos umgesetzt werden.</div>
                                    <div><span class="text-gray-300">Mit Modifikationen:</span> Jede externe √Ñnderung oder Anpassung erfordert die Zustimmung des Authors und ggf. eine separate, kostenpflichtige kommerzielle Lizenz.</div>
                                </div>
                            </div>
                            
                            <div class="pt-2 border-t border-gray-700">
                                <strong class="text-gray-150">Change Date & Change License</strong>
                                <p class="text-gray-400 mt-1">Vier Jahre nach der ersten √∂ffentlichen Ver√∂ffentlichung werden die Rechte automatisch auf Apache License 2.0 √ºbergeleitet.</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="pt-2 border-t border-gray-700">
                        <strong class="text-gray-150">Haftungsausschluss</strong>
                        <p class="text-xs text-gray-400 mt-1">Die Software wird ‚Äûwie besehen" (AS-IS) ohne jegliche Gew√§hrleistung bereitgestellt. Der Lizenzgeber haftet nicht f√ºr direkte, indirekte oder Folgesch√§den aus der Nutzung.</p>
                    </div>
                </div>
            </div>

            <!-- FOOTER -->
            <div class="mt-8 text-center pt-4 border-t border-gray-800">
                <p class="text-[10px] text-gray-500 font-mono mb-2">¬© 2025 Nina Ennekes. All Rights Reserved.</p>
                <p class="text-[9px] text-gray-600 mb-4">Version 1.0.0-preview | Build 2025.11.27</p>
                <button onclick="closeInfoModal()" 
                        class="px-6 py-2 rounded border border-cyan-600/50 text-cyan-400 hover:bg-cyan-600/10 text-xs font-bold tracking-wider"
                        aria-label="Informationen schlie√üen"
                        type="button">SCHLIESSEN</button>
            </div>
        </div>
    </div>

    <!-- DELETE CONFIRMATION MODAL -->
    <div id="deleteModal" class="modal-overlay delete-modal" aria-hidden="true">
        <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="deleteModalTitle">
            <h2 id="deleteModalTitle" class="text-xl font-bold text-red-500 mb-4 border-b border-red-900 pb-2 flex items-center gap-2">
                <span aria-hidden="true">‚ö†</span> DELETE RECORDING
            </h2>
            <p class="text-sm text-gray-300 mb-4">
                Are you sure you want to delete this recording?
            </p>
            
            <div class="bg-red-900/20 border border-red-900/50 p-3 rounded mb-6">
                <div class="text-[10px] text-red-400 font-mono mb-1">RECORDING NAME:</div>
                <div id="deleteRecordingName" class="text-xs font-mono text-white truncate">...</div>
            </div>

            <div class="flex gap-3 justify-end">
                <button onclick="closeDeleteModal()" 
                        class="cancel-btn text-sm"
                        aria-label="Abbrechen"
                        type="button">CANCEL</button>
                <button onclick="confirmDelete()" 
                        class="delete-btn text-sm"
                        aria-label="L√∂schen best√§tigen"
                        type="button">DELETE</button>
            </div>
        </div>
    </div>

    <!-- Notification Toast -->
    <div id="toast" class="fixed bottom-10 left-1/2 transform -translate-x-1/2 bg-gray-900/90 border border-cyan-500 text-cyan-400 px-6 py-3 rounded-full shadow-[0_0_20px_rgba(0,243,255,0.2)] transition-all duration-300 opacity-0 translate-y-10 z-[200] font-mono text-sm pointer-events-none">
        Notification
    </div>

    <script>
        // --- 1. UTILS & UI LOGIC ---
        
        // DELETE MODAL VARIABLES
        let deleteModal = null;
        let trackToDelete = null;
        let currentPlaybackRate = 1.0;
        let crossfadeGainNode = null; // For smooth speed transitions
        
        // EMBEDDED SERVICE WORKER CODE TO FIX BLOB URL ISSUES & UPLOAD LOGIC
        const SW_CODE = `
            const DB_NAME = 'WaveForgeDB_V4';
            const DB_VERSION = 3;
            const STORE_UPLOAD_QUEUE = 'upload_queue';

            function openDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onsuccess = e => resolve(e.target.result);
                    request.onerror = e => reject(e);
                });
            }

            async function getUploadQueue(db) {
                return new Promise((resolve) => {
                    if (!db.objectStoreNames.contains(STORE_UPLOAD_QUEUE)) { resolve([]); return; }
                    const tx = db.transaction(STORE_UPLOAD_QUEUE, 'readonly');
                    const req = tx.objectStore(STORE_UPLOAD_QUEUE).getAll();
                    req.onsuccess = () => resolve(req.result);
                });
            }

            async function removeFromQueue(db, id) {
                const tx = db.transaction(STORE_UPLOAD_QUEUE, 'readwrite');
                tx.objectStore(STORE_UPLOAD_QUEUE).delete(id);
                return new Promise(resolve => tx.oncomplete = resolve);
            }

            async function broadcastStatus(msg) {
                const clients = await self.clients.matchAll();
                clients.forEach(client => client.postMessage(msg));
            }

            async function processUploads() {
                const db = await openDB();
                const queue = await getUploadQueue(db);
                if (queue.length === 0) return;
                queue.sort((a, b) => a.timestamp - b.timestamp || a.chunkIndex - b.chunkIndex);

                for (const item of queue) {
                    try {
                        const formData = new FormData();
                        formData.append('file_id', String(item.fileId));
                        formData.append('chunk_index', String(item.chunkIndex));
                        formData.append('total_chunks', String(item.totalChunks));
                        formData.append('file_name', item.fileName);
                        formData.append('file', item.blob, item.fileName);

                        broadcastStatus({ 
                            type: 'UPLOAD_PROGRESS', 
                            fileId: item.fileId, 
                            progress: (item.chunkIndex + 1) / item.totalChunks 
                        });

                        const response = await fetch('/upload/chunk', {
                            method: 'POST',
                            body: formData
                        });

                        if (!response.ok) throw new Error(\`Server error: \${response.status}\`);
                        await removeFromQueue(db, item.id);
                        if (item.chunkIndex === item.totalChunks - 1) {
                            broadcastStatus({ type: 'UPLOAD_COMPLETE', fileId: item.fileId });
                        }
                    } catch (error) {
                        console.error("Upload failed for chunk", item.chunkIndex, error);
                        broadcastStatus({ type: 'UPLOAD_ERROR', fileId: item.fileId, error: error.message });
                        break; 
                    }
                }
            }

            self.addEventListener('install', (event) => { self.skipWaiting(); });
            self.addEventListener('activate', (event) => { event.waitUntil(self.clients.claim()); });
            self.addEventListener('sync', (event) => { if (event.tag === 'audio-upload') event.waitUntil(processUploads()); });
            self.addEventListener('message', (event) => { if (event.data === 'TRIGGER_UPLOAD') processUploads(); });
        `;

        let toastTimeout;
        function showToast(msg, isError) {
            const t = document.getElementById('toast');
            clearTimeout(toastTimeout);
            const baseClasses = "fixed bottom-24 left-1/2 transform -translate-x-1/2 px-6 py-3 rounded-full shadow transition-all duration-300 z-[200] font-mono text-sm border";
            const colorClasses = isError ? "bg-red-900/90 border-red-500 text-red-300" : "bg-gray-900/90 border-cyan-500 text-cyan-400";
            const visibleClasses = "opacity-100 translate-y-0";
            t.textContent = msg;
            t.className = `${baseClasses} ${colorClasses} ${visibleClasses}`;
            toastTimeout = setTimeout(() => {
                t.classList.remove('opacity-100', 'translate-y-0');
                t.classList.add('opacity-0', 'translate-y-10', 'pointer-events-none');
            }, 3000);
        }

        const infoModal = document.getElementById('infoModal');
        function openInfoModal() { 
            infoModal.style.display = 'flex'; 
            infoModal.setAttribute('aria-hidden', 'false');
            setTimeout(() => {
                infoModal.classList.add('modal-open');
                // Focus first focusable element in modal
                const firstFocusable = infoModal.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
                if (firstFocusable) firstFocusable.focus();
            }, 10);
        }
        function closeInfoModal() { 
            infoModal.classList.remove('modal-open'); 
            infoModal.setAttribute('aria-hidden', 'true');
            setTimeout(() => infoModal.style.display = 'none', 200); 
        }

        function updateFormatWarning() {
            const fmt = document.getElementById('recordingFormat').value;
            const w = document.getElementById('ramWarning');
            if(fmt === 'webm') {
                w.textContent = t('format.ramWarning');
                w.className = "text-[9px] font-mono text-green-400 pl-1";
            } else {
                w.textContent = t('format.ramWarningWav');
                w.className = "text-[9px] font-mono text-red-400 pl-1 animate-pulse";
            }
        }

        // --- SERVICE WORKER & UPLOAD MANAGER (NEW) ---
        const UploadManager = {
            retryInterval: null,
            register: async function() {
                if ('serviceWorker' in navigator) {
                    try {
                        // Use external sw.js file instead of blob URL
                        const reg = await navigator.serviceWorker.register('/sw.js');
                        console.log('‚úì Service Worker registered successfully:', reg);
                        await navigator.serviceWorker.ready;
                        console.log('‚úì Service Worker is ready and active');
                        
                        navigator.serviceWorker.addEventListener('message', (event) => {
                            const { type, sessionId, hasPendingChunks } = event.data;
                            
                            if (type === 'UPLOAD_PROGRESS') {
                                if (sessionId) {
                                    UploadManager.setUploadStatusForSession(sessionId, 'uploading');
                                }
                            } else if (type === 'UPLOAD_COMPLETE') {
                                if (sessionId) {
                                    UploadManager.setUploadStatusForSession(sessionId, 'success');
                                    setTimeout(() => {
                                        UploadManager.setUploadStatusForSession(sessionId, 'idle');
                                    }, 2000);
                                }
                                loadTracksFromDB();
                            } else if (type === 'UPLOAD_PENDING') {
                                // Silent pending state - chunks are retrying
                                if (sessionId) {
                                    UploadManager.setUploadStatusForSession(sessionId, 'pending');
                                }
                            } else if (type === 'UPLOAD_OFFLINE') {
                                // Connection lost - show pending status
                                if (sessionId) {
                                    UploadManager.setUploadStatusForSession(sessionId, 'pending');
                                }
                                console.log('üì° Upload paused - waiting for connection (checking every 5s)');
                            } else if (type === 'CONNECTION_RESTORED') {
                                console.log('‚úÖ Connection restored - resuming uploads');
                            }
                        });
                        
                        // START SMART RETRY LOOP
                        this.startRetryLoop();
                        
                    } catch (err) {
                        console.error('SW reg failed', err);
                        console.warn("Service Workers disabled or not supported in this context.");
                    }
                }
            },
            startRetryLoop: function() {
                // Periodically check queue and trigger upload
                // This handles cases where server comes online LATER
                setInterval(async () => {
                    if (navigator.onLine) {
                        const db = await new Promise((resolve) => {
                           const req = indexedDB.open('WaveForgeDB_V4', 3);
                           req.onsuccess = e => resolve(e.target.result);
                           req.onerror = () => resolve(null);
                        });
                        if(db) {
                             if(db.objectStoreNames.contains('upload_queue')) {
                                 const countReq = db.transaction('upload_queue', 'readonly').objectStore('upload_queue').count();
                                 countReq.onsuccess = () => {
                                     if(countReq.result > 0) {
                                         // Items waiting! Trigger Sync.
                                         console.log(`üì¶ UploadManager: ${countReq.result} chunks in queue, triggering upload...`);
                                         this.triggerSync();
                                     }
                                 }
                             }
                        }
                    }
                }, 30000); // Check every 30 seconds (reduced CPU usage)
            },
            queueUpload: async function(id, blob, fileName, metadata = {}, sessionId = null) {
                const CHUNK_SIZE = 1024 * 1024; // 1MB chunks
                const totalChunks = Math.ceil(blob.size / CHUNK_SIZE);
                
                // Use provided sessionId or generate new one for manual uploads
                const uploadSessionId = sessionId || `manual_${Date.now()}`;
                
                const db = await new Promise((resolve, reject) => {
                    const req = indexedDB.open('WaveForgeDB_V4', 3); 
                    req.onsuccess = e => resolve(e.target.result);
                    req.onerror = e => reject(e);
                });

                const tx = db.transaction(['upload_queue'], 'readwrite');
                const store = tx.objectStore('upload_queue');

                for (let i = 0; i < totalChunks; i++) {
                    const start = i * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE, blob.size);
                    const chunk = blob.slice(start, end);
                    store.add({
                        id: `${id}_${i}`,
                        fileId: id,
                        fileName: fileName,
                        sessionId: uploadSessionId, // Add sessionId
                        chunkIndex: i,
                        totalChunks: totalChunks,
                        blob: chunk,
                        timestamp: Date.now(),
                        metadata: i === totalChunks - 1 ? metadata : null, // Only attach metadata to last chunk
                        retryCount: 0,
                        nextRetryAt: 0
                    });
                }

                tx.oncomplete = () => {
                    console.log(`‚úì Queued ${totalChunks} chunks for upload (File: ${fileName}, Session: ${uploadSessionId}, ID: ${id})`);
                    console.log(`üìä Queue IDs: ${Array.from({length: totalChunks}, (_, i) => `${id}_${i}`).join(', ')}`);
                    showToast("Queued for background upload");
                    this.triggerSync();
                };
            },
            triggerSync: function() {
                console.log('‚Üí Attempting to trigger upload...');
                if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    console.log('‚úì Service Worker controller is active');
                    if ('SyncManager' in window) {
                        console.log('‚Üí Using Background Sync API');
                        navigator.serviceWorker.ready.then(reg => {
                            return reg.sync.register('audio-upload');
                        }).catch(() => {
                            console.log('‚Üí Fallback to postMessage');
                            navigator.serviceWorker.controller.postMessage('TRIGGER_UPLOAD');
                        });
                    } else {
                        console.log('‚Üí Using postMessage (no Background Sync)');
                        navigator.serviceWorker.controller.postMessage('TRIGGER_UPLOAD');
                    }
                } else {
                    console.warn('‚ö† Service Worker controller not ready. Please reload the page.');
                    showToast('Service Worker not active. Reload the page!', true);
                }
                document.getElementById('uploadStatus').classList.remove('hidden');
            },
            updateUI: function(fileId, progress) {
                const bar = document.getElementById(`progress-${fileId}`);
                if(bar) bar.style.width = `${progress * 100}%`;
            },
            sessionStatus: {}, // Track status per session
            
            setUploadStatusForSession: function(sessionId, status) {
                // Update status tracking
                this.sessionStatus[sessionId] = status;
                
                // Find icon for this session (stored in data-session-id attribute)
                const icon = document.querySelector(`.upload-icon[data-session-id="${sessionId}"]`);
                if (!icon) {
                    console.warn(`No upload icon found for session ${sessionId}`);
                    return;
                }
                
                // Remove all status classes
                icon.classList.remove('status-idle', 'status-uploading', 'status-pending', 'status-success', 'status-error');
                
                // Add current status class
                icon.classList.add(`status-${status}`);
                
                // Update icon content and title based on status
                if (status === 'uploading') {
                    icon.innerHTML = '‚Üë';
                    icon.title = 'Uploading...';
                } else if (status === 'pending') {
                    icon.innerHTML = '‚è≥';
                    icon.title = 'Upload pending, retrying...';
                } else if (status === 'success') {
                    icon.innerHTML = '‚úì';
                    icon.title = 'Upload complete';
                } else if (status === 'error') {
                    icon.innerHTML = '‚ö†';
                    icon.title = 'Click to retry upload';
                } else {
                    icon.innerHTML = '‚òÅ';
                    icon.title = 'Upload to server';
                }
            },
            
            setUploadStatus: function(status) {
                // Legacy function - update all icons (used for global events)
                const uploadIcons = document.querySelectorAll('.upload-icon');
                
                uploadIcons.forEach(icon => {
                    const sessionId = icon.getAttribute('data-session-id');
                    if (sessionId && this.sessionStatus[sessionId]) {
                        // Keep existing session-specific status
                        return;
                    }
                    
                    // Remove all status classes
                    icon.classList.remove('status-idle', 'status-uploading', 'status-pending', 'status-success', 'status-error');
                    icon.classList.add(`status-${status}`);
                    
                    if (status === 'uploading') {
                        icon.innerHTML = '‚Üë';
                        icon.title = 'Uploading...';
                    } else if (status === 'pending') {
                        icon.innerHTML = '‚è≥';
                        icon.title = 'Upload pending, retrying...';
                    } else if (status === 'success') {
                        icon.innerHTML = '‚úì';
                        icon.title = 'Upload complete';
                    } else if (status === 'error') {
                        icon.innerHTML = '‚ö†';
                        icon.title = 'Click to retry upload';
                    } else {
                        icon.innerHTML = '‚òÅ';
                        icon.title = 'Upload to server';
                    }
                });
            },
            // Debug tool: Inspect upload queue
            async inspectQueue() {
                try {
                    const db = await new Promise((resolve, reject) => {
                        const req = indexedDB.open('WaveForgeDB_V4', 3);
                        req.onsuccess = e => resolve(e.target.result);
                        req.onerror = e => reject(e);
                    });
                    
                    if (!db.objectStoreNames.contains('upload_queue')) {
                        console.log('üìä Upload queue is empty (store does not exist)');
                        return;
                    }
                    
                    const tx = db.transaction('upload_queue', 'readonly');
                    const store = tx.objectStore('upload_queue');
                    const allItems = await new Promise((resolve) => {
                        const req = store.getAll();
                        req.onsuccess = () => resolve(req.result);
                    });
                    
                    console.log(`üìä Upload Queue Status: ${allItems.length} chunks total`);
                    
                    if (allItems.length === 0) {
                        console.log('‚úÖ Queue is empty - all chunks uploaded!');
                        return;
                    }
                    
                    // Group by session
                    const sessions = {};
                    allItems.forEach(item => {
                        const sid = item.sessionId || item.fileId;
                        if (!sessions[sid]) sessions[sid] = [];
                        sessions[sid].push(item);
                    });
                    
                    console.table(Object.entries(sessions).map(([sid, chunks]) => ({
                        SessionID: sid,
                        Chunks: chunks.length,
                        ChunkIndices: chunks.map(c => c.chunkIndex).sort((a, b) => a - b).join(','),
                        MaxRetry: Math.max(...chunks.map(c => c.retryCount || 0)),
                        Status: chunks[0].nextRetryAt > Date.now() ? `Waiting ${Math.round((chunks[0].nextRetryAt - Date.now())/1000)}s` : 'Ready'
                    })));
                    
                } catch (err) {
                    console.error('Error inspecting queue:', err);
                }
            }
        };
        
        // Global debug function - call inspectUploadQueue() in console to see queue status
        window.inspectUploadQueue = () => UploadManager.inspectQueue();

        // Monitor connection status and auto-resume uploads
        window.addEventListener('online', async () => {
            console.log('üåê Connection restored, checking for pending uploads...');
            UploadManager.setUploadStatus('idle');
            
            // Check queue size
            try {
                const db = await new Promise((resolve, reject) => {
                    const req = indexedDB.open('WaveForgeDB_V4', 3);
                    req.onsuccess = e => resolve(e.target.result);
                    req.onerror = e => reject(e);
                });
                
                if(db.objectStoreNames.contains('upload_queue')) {
                    const countReq = db.transaction('upload_queue', 'readonly').objectStore('upload_queue').count();
                    countReq.onsuccess = () => {
                        console.log(`üì¶ Found ${countReq.result} chunks waiting to upload`);
                        if (countReq.result > 0 && navigator.serviceWorker && navigator.serviceWorker.controller) {
                            navigator.serviceWorker.controller.postMessage('TRIGGER_UPLOAD');
                        }
                    };
                }
            } catch (err) {
                console.error('Error checking queue:', err);
            }
        });
        
        window.addEventListener('offline', () => {
            console.log('üì¥ Connection lost, uploads will resume when online');
            UploadManager.setUploadStatus('pending');
        });

        // --- 2. CRASH GUARD RAID SYSTEM ---
        const DB_NAME = 'WaveForgeDB_V4';
        const DB_VERSION = 3; 
        const STORE_RECORDINGS = 'recordings';
        const STORE_RECOVERY = 'recovery_chunks';
        const STORE_UPLOAD_QUEUE = 'upload_queue'; 

        let db = null;
        let currentSessionId = null;

        const CrashGuard = {
            init: async function() {
                const count = await this.checkOrphans();
                if (count > 0) this.showRecoveryUI();
            },
            generateSessionId: () => 'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            logChunk: function(blob) {
                if (!db || !currentSessionId) return;
                
                // Get current chunk index
                if (!this.chunkCounter) this.chunkCounter = {};
                if (!this.chunkCounter[currentSessionId]) this.chunkCounter[currentSessionId] = 0;
                const chunkIndex = this.chunkCounter[currentSessionId]++;
                
                // Save to IndexedDB for crash recovery
                const transaction = db.transaction([STORE_RECOVERY], 'readwrite');
                transaction.objectStore(STORE_RECOVERY).add({
                    sessionId: currentSessionId,
                    timestamp: Date.now(),
                    blob: blob,
                    chunkIndex: chunkIndex
                });
                
                // AUTO UPLOAD: Upload chunk immediately to server in background
                this.uploadChunkLive(blob, currentSessionId, chunkIndex);
            },
            uploadChunkLive: async function(blob, sessionId, chunkIndex) {
                try {
                    const db = await new Promise((resolve, reject) => {
                        const req = indexedDB.open('WaveForgeDB_V4', 3);
                        req.onsuccess = e => resolve(e.target.result);
                        req.onerror = e => reject(e);
                    });
                    
                    const chunkId = `${sessionId}_chunk_${chunkIndex}`;
                    
                    // Check if chunk already exists in queue
                    const checkTx = db.transaction(['upload_queue'], 'readonly');
                    const existingChunk = await new Promise((resolve) => {
                        const req = checkTx.objectStore('upload_queue').get(chunkId);
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => resolve(null);
                    });
                    
                    if (existingChunk) {
                        console.log(`‚è© Chunk ${chunkIndex} already in queue (session: ${sessionId}), skipping`);
                        return;
                    }
                    
                    const tx = db.transaction(['upload_queue'], 'readwrite');
                    const store = tx.objectStore('upload_queue');
                    
                    // Add chunk to upload queue with session-based structure
                    // Note: We don't have totalChunks yet - will be determined when recording completes
                    store.add({
                        id: chunkId,
                        sessionId: sessionId,
                        chunkIndex: chunkIndex,
                        blob: blob,
                        timestamp: Date.now(),
                        isLiveChunk: true,
                        retryCount: 0,
                        nextRetryAt: 0
                    });
                    
                    tx.oncomplete = () => {
                        console.log(`üíæ Chunk ${chunkIndex} saved to IndexedDB (session: ${sessionId})`);
                        
                        // Trigger upload immediately for live chunks
                        // This ensures chunks are uploaded during recording, not just at the end
                        if (navigator.serviceWorker && navigator.serviceWorker.controller) {
                            navigator.serviceWorker.controller.postMessage('TRIGGER_UPLOAD');
                        }
                    };
                } catch (err) {
                    console.warn('Live upload queuing failed:', err);
                }
            },
            waitForAllChunksUploaded: async function(sessionId, maxWaitMs = 120000) {
                const startTime = Date.now();
                
                while (Date.now() - startTime < maxWaitMs) {
                    try {
                        const db = await new Promise((resolve, reject) => {
                            const req = indexedDB.open('WaveForgeDB_V4', 3);
                            req.onsuccess = e => resolve(e.target.result);
                            req.onerror = e => reject(e);
                        });
                        
                        if (!db.objectStoreNames.contains('upload_queue')) {
                            console.log('‚úÖ No upload queue - all chunks uploaded');
                            return true;
                        }
                        
                        const tx = db.transaction('upload_queue', 'readonly');
                        const store = tx.objectStore('upload_queue');
                        const allItems = await new Promise((resolve) => {
                            const req = store.getAll();
                            req.onsuccess = () => resolve(req.result);
                        });
                        
                        const sessionChunks = allItems.filter(item => item.sessionId === sessionId);
                        
                        if (sessionChunks.length === 0) {
                            console.log(`‚úÖ All chunks uploaded for session ${sessionId}`);
                            return true;
                        }
                        
                        console.log(`‚è≥ Waiting for ${sessionChunks.length} chunks to upload...`);
                        
                        // Trigger upload in case it's stuck
                        if (navigator.serviceWorker && navigator.serviceWorker.controller) {
                            navigator.serviceWorker.controller.postMessage('TRIGGER_UPLOAD');
                        }
                        
                        // Wait 2 seconds before checking again
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        
                    } catch (err) {
                        console.error('Error checking upload queue:', err);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                }
                
                console.warn('‚ö†Ô∏è Timeout waiting for chunks to upload');
                return false;
            },
            signalRecordingComplete: async function(sessionId, fileName, metadata) {
                console.log(`üì¢ Signaling recording complete for session ${sessionId}`);
                
                // CRITICAL: Wait for all chunks to upload first
                console.log('‚è≥ Waiting for all chunks to upload before signaling server...');
                const allUploaded = await this.waitForAllChunksUploaded(sessionId);
                
                if (!allUploaded) {
                    console.error('‚ö†Ô∏è Not all chunks uploaded, but proceeding with assembly anyway');
                }
                
                try {
                    const formData = new FormData();
                    formData.append('session_id', sessionId);
                    formData.append('file_name', fileName);
                    formData.append('metadata', JSON.stringify(metadata));
                    
                    const response = await fetch('/recording/complete', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('‚úì Server acknowledged recording complete:', result);
                        showToast(`Upload complete: ${fileName}`);
                    } else {
                        console.error('Server error:', response.status);
                    }
                } catch (error) {
                    console.error('Error signaling recording complete:', error);
                }
            },
            checkOrphans: function() {
                return new Promise((resolve) => {
                    if (!db) { resolve(0); return; }
                    const req = db.transaction([STORE_RECOVERY], 'readonly').objectStore(STORE_RECOVERY).count();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => resolve(0);
                });
            },
            showRecoveryUI: function() {
                const store = db.transaction([STORE_RECOVERY], 'readonly').objectStore(STORE_RECOVERY);
                const cursorReq = store.openCursor();
                let chunks = 0, size = 0, foundId = null;
                cursorReq.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                        chunks++; size += cursor.value.blob.size; foundId = cursor.value.sessionId; cursor.continue();
                    } else if (chunks > 0) {
                        document.getElementById('recoveryId').textContent = foundId;
                        document.getElementById('recoveryChunks').textContent = chunks;
                        document.getElementById('recoverySize').textContent = (size / 1024 / 1024).toFixed(2) + ' MB';
                        const modal = document.getElementById('recoveryModal');
                        modal.style.display = 'flex'; setTimeout(() => modal.classList.add('modal-open'), 10);
                    }
                };
            },
            assembleSession: async function(targetSessionId = null, isRecovery = false) {
                if (!db) { showToast("Database not initialized", true); return; }
                const req = db.transaction([STORE_RECOVERY], 'readonly').objectStore(STORE_RECOVERY).getAll();
                req.onsuccess = () => {
                    let chunks = req.result.sort((a,b) => a.timestamp - b.timestamp);
                    if (targetSessionId) chunks = chunks.filter(c => c.sessionId === targetSessionId);
                    
                    if (chunks.length > 0) {
                        const blobParts = chunks.map(c => c.blob);
                        tempBlob = new Blob(blobParts, { type: preferredMimeType });
                        
                        // CRITICAL: Set currentSessionId from recovered chunks
                        currentSessionId = chunks[0].sessionId;
                        console.log(`üì¶ Assembled ${chunks.length} chunks from recovery (session: ${currentSessionId})`);
                        
                        // Close recovery modal immediately
                        if (isRecovery) {
                            document.getElementById('recoveryModal').classList.remove('modal-open');
                            setTimeout(() => document.getElementById('recoveryModal').style.display = 'none', 200);
                        }
                        
                        // Open save modal first
                        openSaveModal(isRecovery);
                        
                        // Disable save button during recovery upload
                        if (isRecovery) {
                            const saveBtn = document.querySelector('#saveModal button[onclick="confirmSave()"]');
                            if (saveBtn) {
                                saveBtn.disabled = true;
                                saveBtn.style.opacity = '0.5';
                                saveBtn.style.cursor = 'not-allowed';
                            }
                            document.getElementById('processingIndicator').classList.remove('hidden');
                            document.getElementById('processingIndicator').textContent = 'UPLOADING RECOVERY DATA...';
                        }
                        
                        // Upload and assemble in background (non-blocking)
                        this.uploadAndAssembleRecoveredChunks(chunks, currentSessionId).catch(err => {
                            console.error('Error uploading recovered chunks:', err);
                            showToast('Upload error: ' + err.message, true);
                        });
                    } else {
                        showToast("Error: No data found to assemble", true);
                    }
                };
                req.onerror = () => {
                    showToast("Error reading recovery data", true);
                };
            },
            uploadAndAssembleRecoveredChunks: async function(chunks, sessionId) {
                try {
                    // Upload all recovered chunks to server
                    console.log('‚¨ÜÔ∏è Uploading recovered chunks to server...');
                    for (let i = 0; i < chunks.length; i++) {
                        await this.uploadChunkLive(chunks[i].blob, sessionId, i);
                    }
                    console.log('‚úì All recovered chunks queued for upload');
                    
                    // Wait for all chunks to upload, then signal server to assemble
                    console.log('‚è≥ Waiting for all recovered chunks to upload...');
                    await this.waitForAllChunksUploaded(sessionId, 120000);
                    
                    // Generate filename for recovered session
                    const recoveredFileName = `recovered_${sessionId}.webm`;
                    const recoveredMetadata = {
                        name: `recovered_${sessionId}`,
                        mimeType: preferredMimeType,
                        extension: preferredExt,
                        recordingCompletedAt: new Date().toISOString(),
                        fileSize: tempBlob.size,
                        isRecovery: true
                    };
                    
                    // Signal server to assemble the recovered chunks
                    console.log('üì° Signaling server to assemble recovered chunks...');
                    await this.signalRecordingComplete(sessionId, recoveredFileName, recoveredMetadata);
                    
                    console.log('‚úÖ Recovery upload and assembly complete!');
                    showToast('Recovery upload complete!');
                    
                    // Re-enable save button
                    const saveBtn = document.querySelector('#saveModal button[onclick="confirmSave()"]');
                    if (saveBtn) {
                        saveBtn.disabled = false;
                        saveBtn.style.opacity = '1';
                        saveBtn.style.cursor = 'pointer';
                    }
                    document.getElementById('processingIndicator').classList.add('hidden');
                    document.getElementById('processingIndicator').textContent = 'PROCESSING AUDIO... PLEASE WAIT';
                    
                    // Clean up recovery chunks after successful upload
                    this.clearSession(sessionId);
                } catch (err) {
                    console.error('Recovery upload failed:', err);
                    throw err;
                }
            },
            discardSession: function() {
                if(!confirm("Are you sure? This data will be lost forever.")) return;
                this.clearAllRecoveryData();
                document.getElementById('recoveryModal').classList.remove('modal-open');
                setTimeout(() => document.getElementById('recoveryModal').style.display = 'none', 200);
            },
            clearSession: function(sessionId) {
                if (!db) return;
                try {
                    const tx = db.transaction([STORE_RECOVERY], 'readwrite');
                    const store = tx.objectStore(STORE_RECOVERY);
                    
                    // Check if index exists before using it
                    if (store.indexNames.contains('sessionId')) {
                        const index = store.index('sessionId');
                        index.openKeyCursor(IDBKeyRange.only(sessionId)).onsuccess = (e) => {
                            const cursor = e.target.result;
                            if(cursor) { store.delete(cursor.primaryKey); cursor.continue(); }
                        };
                    } else {
                        // Silently clear all recovery data if index doesn't exist
                        // This happens when database was cleared or is newly created
                        store.clear();
                    }
                } catch (e) {
                    console.error('Error clearing session:', e);
                }
            },
            clearAllRecoveryData: function() {
                 if (!db) return;
                 db.transaction([STORE_RECOVERY], 'readwrite').objectStore(STORE_RECOVERY).clear();
            }
        };

        // --- 3. INDEXED DB ---
        let preferredMimeType = 'audio/webm';
        let preferredExt = 'webm';
        let tempBlob = null;

        function detectMimeType() {
            const types = [
                { mime: 'audio/webm;codecs=opus', ext: 'webm' },
                { mime: 'audio/webm', ext: 'webm' },
                { mime: 'audio/mp4', ext: 'mp4' },
                { mime: 'audio/ogg', ext: 'ogg' }
            ];
            for (let t of types) {
                if (MediaRecorder.isTypeSupported(t.mime)) {
                    preferredMimeType = t.mime; preferredExt = t.ext; break;
                }
            }
            document.getElementById('formatInfo').textContent = `SYSTEM: ${preferredExt.toUpperCase()}`;
        }

        function initDB() {
            detectMimeType();
            return new Promise((resolve, reject) => {
                console.log('‚Üí Opening IndexedDB:', DB_NAME, 'version:', DB_VERSION);
                
                // Check if IndexedDB is available
                if (!window.indexedDB) {
                    console.error('‚ùå IndexedDB not supported');
                    showToast("IndexedDB not supported in this browser", true);
                    reject(new Error('IndexedDB not supported'));
                    return;
                }
                
                try {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    console.log('‚Üí Request created:', request);
                    
                    request.onerror = (e) => {
                        console.error('‚ùå IndexedDB error event:', e);
                        console.error('‚ùå Error details:', e.target.error);
                        showToast("Database error: " + (e.target.error?.message || 'Unknown error'), true);
                        reject(e.target.error);
                    };
                    
                    request.onblocked = (e) => {
                        console.warn('‚ö† IndexedDB blocked - close other tabs!');
                        showToast("Database blocked - close other tabs and reload", true);
                    };
                    
                    request.onupgradeneeded = (e) => {
                        console.log('‚Üí Database upgrade needed from version', e.oldVersion, 'to', e.newVersion);
                        const dbUpgrade = e.target.result;
                        console.log('‚Üí Existing stores:', Array.from(dbUpgrade.objectStoreNames));
                        
                        if (!dbUpgrade.objectStoreNames.contains(STORE_RECORDINGS)) {
                            console.log('‚Üí Creating store:', STORE_RECORDINGS);
                            dbUpgrade.createObjectStore(STORE_RECORDINGS, { keyPath: 'id', autoIncrement: true });
                        }
                        if (!dbUpgrade.objectStoreNames.contains(STORE_RECOVERY)) {
                            console.log('‚Üí Creating store:', STORE_RECOVERY);
                            const rec = dbUpgrade.createObjectStore(STORE_RECOVERY, { autoIncrement: true });
                            rec.createIndex('sessionId', 'sessionId', { unique: false });
                        }
                        if (!dbUpgrade.objectStoreNames.contains(STORE_UPLOAD_QUEUE)) {
                            console.log('‚Üí Creating store:', STORE_UPLOAD_QUEUE);
                            dbUpgrade.createObjectStore(STORE_UPLOAD_QUEUE, { keyPath: 'id' }); 
                        }
                        console.log('‚úì Database upgrade complete');
                    };
                    
                    request.onsuccess = (e) => {
                        db = e.target.result;
                        console.log('‚úì IndexedDB opened successfully');
                        console.log('‚Üí Available stores:', Array.from(db.objectStoreNames));
                        console.log('‚Üí DB version:', db.version);
                        CrashGuard.init();
                        loadTracksFromDB();
                        UploadManager.register(); 
                        resolve(db);
                    };
                    
                    // Timeout fallback
                    setTimeout(() => {
                        if (!db) {
                            console.error('‚ùå IndexedDB open timeout after 10s');
                            showToast("Database timeout - please reload", true);
                            reject(new Error('Database open timeout'));
                        }
                    }, 10000);
                    
                } catch (err) {
                    console.error('‚ùå Exception opening IndexedDB:', err);
                    showToast("Database exception: " + err.message, true);
                    reject(err);
                }
            });
        }

        function saveTrackToDB(blob, name, mimeType, ext) {
            if (!db) {
                showToast("Database not initialized", true);
                document.getElementById('processingIndicator').classList.add('hidden');
                return;
            }
            
            const tx = db.transaction([STORE_RECORDINGS], 'readwrite');
            tx.objectStore(STORE_RECORDINGS).add({
                name: name, 
                blob: blob, 
                date: new Date().toISOString(), 
                mimeType: mimeType, 
                extension: ext,
                sessionId: currentSessionId // Store sessionId with recording
            });
            
            tx.oncomplete = () => {
                showToast(`Saved as .${ext.toUpperCase()}`);
                
                // Signal server that recording is complete and should be assembled
                if (currentSessionId) {
                    const fileName = `${name}.${ext}`;
                    const metadata = {
                        name: name,
                        mimeType: mimeType,
                        extension: ext,
                        recordingCompletedAt: new Date().toISOString(),
                        fileSize: blob.size
                    };
                    CrashGuard.signalRecordingComplete(currentSessionId, fileName, metadata);
                }
                
                // Clear recovery data after successful save
                try {
                    if (currentSessionId) {
                        CrashGuard.clearSession(currentSessionId);
                    } else {
                        CrashGuard.clearAllRecoveryData();
                    }
                } catch (e) {
                    console.warn('Could not clear recovery data:', e);
                }
                
                tempBlob = null; // Clear tempBlob after successful save
                currentSessionId = null; // Reset session ID
                loadTracksFromDB();
                closeSaveModal();
            };
            
            tx.onerror = (e) => {
                console.error("DB Save Error:", e);
                showToast("Failed to save to database", true);
                document.getElementById('processingIndicator').classList.add('hidden');
            };
        }

        function loadTracksFromDB() {
            if (!db) return;
            const req = db.transaction([STORE_RECORDINGS], 'readonly').objectStore(STORE_RECORDINGS).getAll();
            req.onsuccess = () => renderPlaylist(req.result);
        }

        function deleteTrackFromDB(id) {
            db.transaction([STORE_RECORDINGS], 'readwrite').objectStore(STORE_RECORDINGS).delete(id).onsuccess = () => {
                showToast("Track deleted"); loadTracksFromDB();
            };
        }

        // --- 4. AUDIO ENGINE ---
        let audioContext, analyser, dataArray, canvas, canvasCtx;
        let inputSource, mediaRecorder, recordingNodes = {}, isRecording = false, startTime, timerInterval;
        let currentAudioBuffer = null, playbackSource = null, outputNodes = {}, isPlaying = false, playbackStartTime = 0, playbackOffset = 0, playbackRafId = null;
        let audioElement = null, mediaElementSource = null, currentBlobUrl = null;

        function initAudioEngine() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                initVisualizer();
            }
            if (audioContext.state === 'suspended') audioContext.resume();
        }

        function initVisualizer() {
            canvas = document.getElementById('visualizer');
            if(!canvas) return;
            canvasCtx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvas.getBoundingClientRect().width * dpr;
            canvas.height = canvas.getBoundingClientRect().height * dpr;
            canvasCtx.scale(dpr, dpr);
            drawVisualizer();
        }

        function drawVisualizer() {
            requestAnimationFrame(drawVisualizer);
            if (!canvas || !canvasCtx || !analyser) return;
            canvasCtx.clearRect(0, 0, canvas.width/window.devicePixelRatio, canvas.height/window.devicePixelRatio);
            analyser.getByteFrequencyData(dataArray);
            const w = (canvas.width/window.devicePixelRatio) / dataArray.length * 2.5;
            let x = 0;
            for(let i = 0; i < dataArray.length; i++) {
                const h = (dataArray[i] / 255) * (canvas.height/window.devicePixelRatio);
                canvasCtx.fillStyle = `rgb(${0 + 255*(h/(canvas.height/window.devicePixelRatio))}, ${243 - 100*(h/(canvas.height/window.devicePixelRatio))}, 255)`;
                canvasCtx.fillRect(x, (canvas.height/window.devicePixelRatio) - h, w - 2, h);
                x += w + 1;
            }
        }

        function encodeWAV(samples, sampleRate) {
            const buffer = new ArrayBuffer(44 + samples.length * 2);
            const view = new DataView(buffer);
            const writeString = (view, offset, string) => { for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i)); };
            writeString(view, 0, 'RIFF'); view.setUint32(4, 36 + samples.length * 2, true); writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * 2, true); view.setUint16(32, 2, true); view.setUint16(34, 16, true);
            writeString(view, 36, 'data'); view.setUint32(40, samples.length * 2, true);
            let offset = 44;
            for (let i = 0; i < samples.length; i++, offset += 2) {
                let s = Math.max(-1, Math.min(1, samples[i]));
                view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
            return view;
        }

        async function convertBlobToWav(blob) {
            const ab = await blob.arrayBuffer();
            const abuff = await audioContext.decodeAudioData(ab);
            const wavView = encodeWAV(abuff.getChannelData(0), abuff.sampleRate);
            return new Blob([wavView], { type: 'audio/wav' });
        }

        // Recording
        async function startRecording() {
            initAudioEngine();
            // FIXED: Disable Playback UI & Stop Audio
            document.getElementById('playerDock').classList.remove('active');
            if (isPlaying) stopAudio(); 
            
            // FIXED: Prevent Echo/Feedback
            // Disconnect analyser from destination if it was connected during playback
            try { analyser.disconnect(); } catch(e) {}

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                inputSource = audioContext.createMediaStreamSource(stream);
                currentSessionId = CrashGuard.generateSessionId();

                ['low', 'mid', 'high', 'gain'].forEach(k => { recordingNodes[k] = audioContext.createBiquadFilter(); });
                recordingNodes.low.type = "lowshelf"; recordingNodes.low.frequency.value = 320;
                recordingNodes.mid.type = "peaking"; recordingNodes.mid.frequency.value = 1000;
                recordingNodes.high.type = "highshelf"; recordingNodes.high.frequency.value = 3200;
                recordingNodes.gain = audioContext.createGain();

                inputSource.connect(recordingNodes.low);
                recordingNodes.low.connect(recordingNodes.mid); recordingNodes.mid.connect(recordingNodes.high);
                recordingNodes.high.connect(recordingNodes.gain); 
                
                // Connect to Analyser for visualizer, BUT NOT DESTINATION
                recordingNodes.gain.connect(analyser);

                const dest = audioContext.createMediaStreamDestination();
                recordingNodes.gain.connect(dest);
                
                try { mediaRecorder = new MediaRecorder(dest.stream, { mimeType: preferredMimeType }); } catch (e) { mediaRecorder = new MediaRecorder(dest.stream); }

                mediaRecorder.ondataavailable = e => { 
                    if (e.data.size > 0) { 
                        CrashGuard.logChunk(e.data); 
                    }
                };
                
                mediaRecorder.onstop = () => { 
                    CrashGuard.assembleSession(currentSessionId);
                };

                mediaRecorder.start(1000); 
                
                isRecording = true;
                document.getElementById('recordButton').classList.add('recording-active');
                document.getElementById('recordButton').disabled = true;
                document.getElementById('stopButton').disabled = false;
                startTimer();
                applyInputEQ();
            } catch (err) { console.error(err); showToast("Mic Error", true); }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                if(inputSource) {
                    inputSource.disconnect();
                    // Close the microphone stream
                    const tracks = inputSource.mediaStream.getTracks();
                    tracks.forEach(track => track.stop());
                }
                isRecording = false;
                document.getElementById('recordButton').classList.remove('recording-active');
                document.getElementById('recordButton').disabled = false;
                document.getElementById('stopButton').disabled = true;
                stopTimer();
            }
        }

        // Save Modal
        const modal = document.getElementById('saveModal');
        const nameInput = document.getElementById('saveNameInput');
        function openSaveModal(isRecovery = false) {
            if (!tempBlob || tempBlob.size === 0) return;
            nameInput.value = isRecovery ? `RECOVERED ${new Date().toLocaleTimeString()}` : `Sequence ${new Date().toLocaleTimeString()}`;
            nameInput.style.borderColor = isRecovery ? 'var(--neon-red)' : '#374151';
            
            const fmt = document.getElementById('recordingFormat').value;
            const w = document.getElementById('processingWarning');
            if(fmt !== 'webm') w.classList.remove('hidden'); else w.classList.add('hidden');
            
            // Update format display
            document.getElementById('saveFormatDisplay').textContent = fmt.toUpperCase();

            modal.style.display = 'flex'; 
            modal.setAttribute('aria-hidden', 'false');
            setTimeout(() => {
                modal.classList.add('modal-open');
                nameInput.focus();
            }, 10);
        }
        function closeSaveModal() {
            modal.classList.remove('modal-open');
            modal.setAttribute('aria-hidden', 'true');
            setTimeout(() => { modal.style.display = 'none'; document.getElementById('processingIndicator').classList.add('hidden'); }, 200);
        }
        
        async function confirmSave() {
            const name = nameInput.value || "Untitled";
            const fmt = document.getElementById('recordingFormat').value;
            
            // VALIDATION: Check if tempBlob exists
            if (!tempBlob || tempBlob.size === 0) {
                showToast("Error: No audio data to save", true);
                closeSaveModal();
                return;
            }
            
            console.log("Starting save process...", {name, fmt, blobSize: tempBlob.size});
            document.getElementById('processingIndicator').classList.remove('hidden');
            
            // Use immediate async execution instead of setTimeout
            try {
                let blobToSave;
                let mimeType;
                let extension;
                
                if (fmt === 'wav') {
                    console.log("Converting to WAV...");
                    blobToSave = await convertBlobToWav(tempBlob);
                    mimeType = 'audio/wav';
                    extension = 'wav';
                } else if (fmt === 'mp3') {
                    blobToSave = tempBlob;
                    mimeType = 'audio/mpeg';
                    extension = 'mp3';
                } else {
                    // WebM format
                    blobToSave = tempBlob;
                    mimeType = preferredMimeType;
                    extension = preferredExt;
                }
                
                console.log("Saving to DB...", {size: blobToSave.size, mimeType, extension});
                saveTrackToDB(blobToSave, name, mimeType, extension);
                
            } catch (e) { 
                console.error("Save error:", e);
                showToast("Save Failed: " + e.message, true); 
                document.getElementById('processingIndicator').classList.add('hidden');
                closeSaveModal();
            }
        }

        // --- 5. PLAYER LOGIC & DOCK BEHAVIOR ---
        
        async function loadTrack(id, name, blob) {
            // FIXED: Disable Playback if Recording
            if(isRecording) { showToast("Recording Active!", true); return; }
            
            initAudioEngine();
            stopAudio();
            showToast("Loading audio...");
            try {
                // Clean up old blob URL
                if (currentBlobUrl) {
                    URL.revokeObjectURL(currentBlobUrl);
                }
                
                // Create NEW Audio Element for each track (MediaElementSource can only be created once per element)
                currentBlobUrl = URL.createObjectURL(blob);
                
                // Clean up old audio element
                if (audioElement) {
                    audioElement.pause();
                    audioElement.src = '';
                }
                
                // Create fresh audio element
                audioElement = new Audio();
                audioElement.preservesPitch = true; // CRITICAL: Prevents Mickey Mouse effect
                audioElement.crossOrigin = 'anonymous';
                audioElement.playbackRate = currentPlaybackRate; // Restore speed setting
                
                // Reset MediaElementSource so it gets recreated in playAudio()
                if (mediaElementSource) {
                    mediaElementSource.disconnect();
                    mediaElementSource = null;
                }
                
                audioElement.src = currentBlobUrl;
                audioElement.preload = 'auto'; // Force full preload
                
                // Wait for audio to be fully loaded
                await new Promise((resolve, reject) => {
                    // Use canplaythrough for complete loading
                    audioElement.oncanplaythrough = resolve;
                    audioElement.onerror = reject;
                    audioElement.load(); // Explicitly trigger load
                });
                
                // Extra safety: Wait until duration is actually available and valid
                let retries = 0;
                while ((!audioElement.duration || !isFinite(audioElement.duration)) && retries < 100) {
                    await new Promise(resolve => setTimeout(resolve, 20));
                    retries++;
                }
                
                console.log('Audio loaded, duration:', audioElement.duration, 'readyState:', audioElement.readyState);
                
                audioElement.currentTime = 0;
                
                const dock = document.getElementById('playerDock');
                dock.classList.add('active');
                
                document.getElementById('nowPlayingText').textContent = name;
                playbackOffset = 0;
                updateDurationDisplay(audioElement.duration);
                updateCurrentTimeDisplay(0);
                document.getElementById('seekSlider').value = 0;
                await playAudio(0);
            } catch (e) { console.error(e); showToast("Error loading audio", true); }
        }

        async function playAudio(offset) {
            // FIXED: Disable Playback if Recording
            if(isRecording) return;
            
            if (!audioElement) return;
            
            // Create MediaElementSource if not exists
            if (!mediaElementSource) {
                mediaElementSource = audioContext.createMediaElementSource(audioElement);
                
                // Setup EQ chain
                ['low', 'mid', 'high', 'gain'].forEach(k => { outputNodes[k] = audioContext.createBiquadFilter(); });
                outputNodes.low.type = "lowshelf"; outputNodes.low.frequency.value = 320;
                outputNodes.mid.type = "peaking"; outputNodes.mid.frequency.value = 1000;
                outputNodes.high.type = "highshelf"; outputNodes.high.frequency.value = 3200;
                outputNodes.gain = audioContext.createGain();
                
                // Create crossfade gain node
                crossfadeGainNode = audioContext.createGain();
                crossfadeGainNode.gain.value = 1;
                
                // Connect audio chain
                mediaElementSource.connect(outputNodes.low);
                outputNodes.low.connect(outputNodes.mid);
                outputNodes.mid.connect(outputNodes.high);
                outputNodes.high.connect(outputNodes.gain);
                outputNodes.gain.connect(crossfadeGainNode);
                crossfadeGainNode.connect(analyser);
                analyser.connect(audioContext.destination);
                
                applyOutputEQ();
            }
            
            // Set playback position and speed
            audioElement.currentTime = offset || 0;
            audioElement.playbackRate = currentPlaybackRate;
            audioElement.preservesPitch = true; // Always preserve pitch!
            
            // Set state BEFORE starting playback
            playbackStartTime = audioContext.currentTime;
            playbackOffset = offset || 0;
            isPlaying = true;
            updatePlayPauseButtonUI();
            
            // Start playback and seek loop
            try {
                await audioElement.play();
                startSeekLoop();
            } catch (e) {
                console.error('Play error:', e);
                isPlaying = false;
                updatePlayPauseButtonUI();
            }
        }

        function stopAudio(reachedEnd = false, skipFade = false) {
            if (audioElement) {
                // Smooth fade-out to prevent clicks (10ms) unless skipping
                if (crossfadeGainNode && !skipFade) {
                    const now = audioContext.currentTime;
                    crossfadeGainNode.gain.cancelScheduledValues(now);
                    crossfadeGainNode.gain.setValueAtTime(crossfadeGainNode.gain.value, now);
                    crossfadeGainNode.gain.linearRampToValueAtTime(0.01, now + 0.01);
                    
                    setTimeout(() => {
                        audioElement.pause();
                        crossfadeGainNode.gain.setValueAtTime(1, audioContext.currentTime);
                    }, 15);
                } else {
                    audioElement.pause();
                }
            }
            isPlaying = false;
            cancelAnimationFrame(playbackRafId);
            updatePlayPauseButtonUI();
            if (reachedEnd) { 
                if (audioElement) audioElement.currentTime = 0;
                playbackOffset = 0; 
                document.getElementById('seekSlider').value = 0; 
                updateCurrentTimeDisplay(0); 
            }
        }

        function togglePlayPause() {
            if(isRecording) return; // Guard
            if (!audioElement) return;
            
            if (isPlaying) {
                stopAudio(); 
            } else {
                // Start from current position or beginning if at end
                const currentPos = audioElement.currentTime;
                if (currentPos >= audioElement.duration - 0.1) {
                    playAudio(0);
                } else {
                    playAudio(currentPos);
                }
            }
        }

        function playerSeek(percentage) {
            if (!audioElement) return;
            // Convert percentage (0-100) to actual time
            const time = (percentage / 100) * audioElement.duration;
            if (isPlaying) {
                audioElement.currentTime = time;
            } else {
                audioElement.currentTime = time;
                updateCurrentTimeDisplay(time);
                document.getElementById('seekSlider').value = percentage;
            }
        }
        function playerSkip(s) { 
            if(audioElement && audioElement.duration && isFinite(audioElement.duration)) {
                const newTime = audioElement.currentTime + s;
                const clampedTime = Math.max(0, Math.min(newTime, audioElement.duration));
                const percentage = (clampedTime / audioElement.duration) * 100;
                playerSeek(percentage);
            }
        }
        function playerSeekStart() { playerSeek(0); }
        function playerSeekEnd() { if(audioElement) { audioElement.currentTime = audioElement.duration; updateCurrentTimeDisplay(audioElement.duration); document.getElementById('seekSlider').value = 100; } }

        function startSeekLoop() {
            cancelAnimationFrame(playbackRafId);
            let durationDiscovered = false;
            
            function loop() {
                if (isPlaying && audioElement) {
                    const pos = audioElement.currentTime;
                    const dur = audioElement.duration;
                    
                    // Always update current time display
                    updateCurrentTimeDisplay(pos);
                    
                    // Check if we got a valid duration
                    if (dur && isFinite(dur) && dur > 0) {
                        if (!durationDiscovered) {
                            durationDiscovered = true;
                            updateDurationDisplay(dur);
                        }
                        
                        // Convert time to percentage (0-100)
                        const percentage = (pos / dur) * 100;
                        // Only update slider if user is not dragging it
                        if (!window.isSeekDragging) {
                            document.getElementById('seekSlider').value = percentage;
                        }
                    }
                    // If duration not available yet, slider stays at 0 (no confusing estimates)
                    
                    // Continue loop if not at end
                    if (!audioElement.ended && !audioElement.paused) {
                        playbackRafId = requestAnimationFrame(loop);
                    } else if (audioElement.ended) {
                        // Audio zu Ende
                        stopAudio(true);
                    }
                }
            }
            loop();
        }

        function updateDurationDisplay(d) { 
            if (!d || !isFinite(d)) { document.getElementById('totalTime').textContent = '00:00'; return; }
            document.getElementById('totalTime').textContent = `${Math.floor(d/60).toString().padStart(2,'0')}:${Math.floor(d%60).toString().padStart(2,'0')}`; 
        }
        function updateCurrentTimeDisplay(t) { 
            if (!t || !isFinite(t)) { document.getElementById('currentTime').textContent = '00:00'; return; }
            document.getElementById('currentTime').textContent = `${Math.floor(t/60).toString().padStart(2,'0')}:${Math.floor(t%60).toString().padStart(2,'0')}`; 
        }
        function updatePlayPauseButtonUI() { document.getElementById('dockPlayBtn').innerHTML = isPlaying ? '‚ùö‚ùö' : '‚ñ∂'; }
        document.getElementById('seekSlider').addEventListener('change', (e) => playerSeek(parseFloat(e.target.value)));

        document.addEventListener('click', (e) => {
            const dock = document.getElementById('playerDock');
            const clickedInsideDock = dock.contains(e.target);
            const clickedPlayBtn = e.target.closest('button') && e.target.closest('button').className.includes('play-btn-');
            if (dock.classList.contains('active') && !clickedInsideDock && !clickedPlayBtn) {
                dock.classList.remove('active');
                // Stop playback when dock closes
                if (isPlaying) {
                    stopAudio();
                    playbackOffset = 0;
                }
            }
        });

        // EQ Updates
        function applyInputEQ() { if (!recordingNodes.gain) return; applyEQ(recordingNodes, 'input'); }
        function applyOutputEQ() { if (!outputNodes.gain) return; applyEQ(outputNodes, 'output'); }
        function applyEQ(nodes, prefix) {
            const v = getSliderValues(prefix);
            nodes.low.gain.setTargetAtTime(v.low, audioContext.currentTime, 0.1);
            nodes.mid.gain.setTargetAtTime(v.mid, audioContext.currentTime, 0.1);
            nodes.high.gain.setTargetAtTime(v.high, audioContext.currentTime, 0.1);
            nodes.gain.gain.setTargetAtTime(v.gain, audioContext.currentTime, 0.1);
        }
        function getSliderValues(prefix) {
            const low = parseFloat(document.getElementById(`${prefix}LowShelf`).value);
            const mid = parseFloat(document.getElementById(`${prefix}Peaking`).value);
            const high = parseFloat(document.getElementById(`${prefix}HighShelf`).value);
            const gain = parseFloat(document.getElementById(`${prefix}Gain`).value);
            document.getElementById(`val-${prefix}Low`).textContent = (low > 0 ? `+${low}` : low) + 'dB';
            document.getElementById(`val-${prefix}Mid`).textContent = (mid > 0 ? `+${mid}` : mid) + 'dB';
            document.getElementById(`val-${prefix}High`).textContent = (high > 0 ? `+${high}` : high) + 'dB';
            document.getElementById(`val-${prefix}Gain`).textContent = Math.round(gain * 100) + '%';
            return { low, mid, high, gain };
        }

        // Playlist & Timer
        function renderPlaylist(tracks) {
            const c = document.getElementById('playlist');
            document.getElementById('trackCount').textContent = `${tracks ? tracks.length : 0} ${t('playlist.trackCount')}`;
            c.innerHTML = '';
            if (!tracks || tracks.length === 0) { c.innerHTML = `<div class="text-center text-gray-600 mt-10 digital-text">${t('playlist.noData')}</div>`; return; }
            tracks.reverse().forEach(t => {
                const el = document.createElement('div');
                el.className = 'group flex flex-col p-3 rounded hover:bg-white/5 border border-transparent hover:border-white/10 transition-all';
                const date = new Date(t.date).toLocaleDateString();
                const ext = t.extension || 'webm';
                let col = 'text-gray-500'; if(ext==='wav') col='text-cyan-400'; if(ext==='mp3') col='text-pink-400';
                
                const sessionAttr = t.sessionId ? ` data-session-id="${t.sessionId}"` : '';
                el.innerHTML = `
                    <div class="flex justify-between items-center w-full">
                        <div><div class="font-bold text-gray-200 group-hover:text-cyan-400 transition-colors">${t.name}</div><div class="text-[10px] ${col} font-mono">${date} | ${ext.toUpperCase()}</div></div>
                        <div class="flex gap-2 opacity-60 group-hover:opacity-100 transition-opacity">
                            <button class="play-btn-${t.id} w-8 h-8 rounded-full border border-gray-600 flex items-center justify-center hover:border-cyan-400 hover:text-cyan-400 hover:shadow-[0_0_10px_rgba(0,243,255,0.3)] transition-all" aria-label="Abspielen: ${t.name}" type="button"><span aria-hidden="true">‚ñ∂</span></button>
                            <button class="up-btn-${t.id} w-8 h-8 rounded-full border border-gray-600 flex items-center justify-center hover:border-cyan-400 hover:text-cyan-400 upload-icon transition-all" title="Upload to Cloud" aria-label="In Cloud hochladen: ${t.name}"${sessionAttr} type="button"><span aria-hidden="true">‚òÅ</span></button>
                            <button class="dl-btn-${t.id} px-2 h-8 rounded border border-gray-600 flex items-center justify-center hover:border-green-400 hover:text-green-400 text-[10px] font-mono transition-all" aria-label="Herunterladen: ${t.name}" type="button">DL</button>
                            <button class="del-btn-${t.id} w-8 h-8 rounded-full border border-gray-600 flex items-center justify-center hover:border-red-500 hover:text-red-500 transition-all" aria-label="L√∂schen: ${t.name}" type="button"><span aria-hidden="true">√ó</span></button>
                        </div>
                    </div>
                    <div class="upload-status-bar" id="progress-bar-${t.id}"><div class="upload-status-fill" id="progress-${t.id}"></div></div>
                `;
                c.appendChild(el);
                el.querySelector(`.play-btn-${t.id}`).onclick = () => loadTrack(t.id, t.name, t.blob);
                el.querySelector(`.dl-btn-${t.id}`).onclick = () => { const u = URL.createObjectURL(t.blob); const a=document.createElement('a'); a.href=u; a.download=`${t.name}.${ext}`; a.click(); URL.revokeObjectURL(u); };
                el.querySelector(`.del-btn-${t.id}`).onclick = () => openDeleteModal(t.id, t.name);
                el.querySelector(`.up-btn-${t.id}`).onclick = () => { 
                    document.getElementById(`progress-bar-${t.id}`).style.display = 'block';
                    const metadata = {
                        name: t.name,
                        mimeType: t.mimeType || preferredMimeType,
                        extension: ext,
                        savedAt: t.date,
                        fileSize: t.blob.size
                    };
                    UploadManager.queueUpload(t.id, t.blob, `${t.name}.${ext}`, metadata, t.sessionId); 
                };
            });
        }

        function startTimer() { startTime = Date.now(); timerInterval = setInterval(() => { document.getElementById('timerDisplay').textContent = new Date(Date.now() - startTime).toISOString().substr(11, 8); }, 100); }
        function stopTimer() { clearInterval(timerInterval); }

        // DELETE MODAL FUNCTIONS
        function openDeleteModal(trackId, trackName) {
            deleteModal = document.getElementById('deleteModal');
            trackToDelete = trackId;
            document.getElementById('deleteRecordingName').textContent = trackName;
            deleteModal.style.display = 'flex';
            deleteModal.classList.add('modal-open');
            deleteModal.setAttribute('aria-hidden', 'false');
        }

        function closeDeleteModal() {
            if (deleteModal) {
                deleteModal.style.display = 'none';
                deleteModal.classList.remove('modal-open');
                deleteModal.setAttribute('aria-hidden', 'true');
                trackToDelete = null;
            }
        }

        function confirmDelete() {
            if (trackToDelete) {
                deleteTrackFromDB(trackToDelete);
                closeDeleteModal();
            }
        }

        // PLAYBACK SPEED CONTROL - Native HTML5 Audio mit Pitch Preservation!
        function changePlaybackSpeed(speed) {
            const newRate = parseFloat(speed);
            currentPlaybackRate = newRate;
            
            if (audioElement) {
                // HTML5 Audio Element unterst√ºtzt native Pitch Preservation!
                audioElement.playbackRate = newRate;
                audioElement.preservesPitch = true; // Verhindert Mickey Mouse Effekt
            }
        }

        // CLOSE DOCK FUNCTION
        function closeDock() {
            const dock = document.getElementById('playerDock');
            dock.classList.remove('active');
            // Stop playback when dock closes
            if (isPlaying) {
                stopAudio();
                playbackOffset = 0;
            }
            // Reset playback speed
            currentPlaybackRate = 1.0;
            document.getElementById('playbackSpeed').value = '1';
        }

        document.addEventListener('DOMContentLoaded', () => {
            initDB().catch(err => {
                console.error('Failed to initialize database:', err);
                showToast('Database initialization failed!', true);
            });
            document.getElementById('recordButton').addEventListener('click', startRecording);
            document.getElementById('stopButton').addEventListener('click', stopRecording);
            ['LowShelf', 'Peaking', 'HighShelf', 'Gain'].forEach(t => {
                document.getElementById(`input${t}`).addEventListener('input', (e) => { 
                    getSliderValues('input'); 
                    applyInputEQ();
                    // Update ARIA attributes dynamically for screen readers
                    const val = e.target.value;
                    e.target.setAttribute('aria-valuenow', val);
                    e.target.setAttribute('aria-valuetext', `${val} Dezibel`);
                });
                document.getElementById(`output${t}`).addEventListener('input', (e) => { 
                    getSliderValues('output'); 
                    applyOutputEQ();
                    // Update ARIA attributes dynamically for screen readers
                    const val = e.target.value;
                    e.target.setAttribute('aria-valuenow', val);
                    e.target.setAttribute('aria-valuetext', `${val} Dezibel`);
                });
            });
            getSliderValues('input'); getSliderValues('output');
            updateFormatWarning();
            
            // BITV 2.0: Keyboard accessibility - Escape key closes modals
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (modal.style.display === 'flex') closeSaveModal();
                    else if (infoModal.style.display === 'flex') closeInfoModal();
                    else if (document.getElementById('deleteModal')?.style.display === 'flex') closeDeleteModal();
                    else if (document.getElementById('recoveryModal').style.display === 'flex') {
                        // Recovery modal doesn't have close function, but we can discard
                        CrashGuard.discardSession();
                    }
                }
            });
            
            // Initialize language
            initLanguage();
        });

        // ============================================
        // MULTI-LANGUAGE SUPPORT SYSTEM
        // ============================================
        
        const translations = {
            de: {
                // UI Elements
                'ui.info': 'INFO',
                'ui.skipToContent': 'Zum Hauptinhalt springen',
                'ui.crashguard': 'CRASHGUARD // RAID PROTECTED SYSTEM',
                'ui.format': 'FORMAT:',
                'ui.rec': 'REC',
                'ui.stop': 'STOP',
                'ui.input': 'INPUT',
                'ui.output': 'OUTPUT',
                'ui.inputStage': 'INPUT STAGE',
                'ui.outputStage': 'OUTPUT STAGE',
                'ui.low': 'LOW',
                'ui.mid': 'MID',
                'ui.high': 'HIGH',
                'ui.gain': 'GAIN',
                'ui.save': 'SAVE',
                'ui.close': 'CLOSE',
                'ui.yes': 'JA',
                'ui.no': 'NEIN',
                'ui.delete': 'L√∂schen',
                'ui.download': 'DL',
                'ui.play': 'Abspielen',
                'ui.upload': 'Upload',
                
                // Status Messages
                'status.ready': 'SYSTEM READY',
                'status.recording': 'RECORDING',
                'status.stopped': 'GESTOPPT',
                'status.playing': 'ABSPIELEN',
                'status.paused': 'ANGEHALTEN',
                'status.error': 'ERROR',
                'status.uploading': 'HOCHLADEN',
                'status.uploaded': 'HOCHGELADEN',
                
                // Format Options
                'format.webm': 'WEBM (Opus Codec)',
                'format.wav': 'WAV (Hoher Speicherverbrauch!)',
                'format.mp3': 'MP3',
                'format.detecting': 'FORMAT: ERKENNUNG...',
                'format.ramWarning': '‚úì F√ºr Aufnahmen auch √ºber 8h!',
                'format.ramWarningWav': '‚ö† Nur 30-60 Minuten sicher! ',
                
                // Recording Info
                'recording.sessionStarted': 'Session gestartet',
                'recording.crashDetected': 'CRASH DETECTED! Session wird wiederhergestellt...',
                'recording.recoveryAvailable': 'Wiederherstellung verf√ºgbar',
                'recording.sessionRecovered': 'Session erfolgreich wiederhergestellt',
                'recording.chunksSaved': 'Chunks gespeichert',
                'recording.duration': 'Dauer',
                
                // Playlist
                'playlist.title': 'AUFNAHMEN',
                'playlist.noData': 'KEINE DATEN GEFUNDEN',
                'playlist.trackCount': 'TRACKS',
                
                // Modal Titles
                'modal.save': 'Aufnahme speichern',
                'modal.info': 'WAVEFORGE PRO - INFO',
                'modal.recovery': 'Session Wiederherstellung',
                
                // Save Modal
                'save.enterName': 'Dateinamen eingeben',
                'save.placeholder': 'Meine Aufnahme',
                'save.saveButton': 'Speichern',
                'save.closeButton': 'Verwerfen',
                
                // Recovery Modal
                'recovery.title': 'CRASH RECOVERY',
                'recovery.detected': 'Unterbrochene Session erkannt!',
                'recovery.message': 'Eine vorherige Aufnahme wurde unterbrochen. M√∂chten Sie diese wiederherstellen?',
                'recovery.chunkInfo': 'Verf√ºgbare Chunks',
                'recovery.restore': 'Wiederherstellen',
                'recovery.discard': 'Verwerfen',
                
                // Info Modal Sections
                'info.title': 'WAVEFORGE PRO - INFO',
                'info.close': 'Schlie√üen',
                'info.introduction': 'Professionelle Offline Audio-Workstation im Browser',
                'info.introText': 'WaveForge Pro ist eine hochmoderne Digital Audio Workstation (DAW) f√ºr den Browser, optimiert f√ºr lange Aufnahmen (8+ Stunden) mit intelligentem CrashGuard-System, Cloud-Synchronisation und vollst√§ndiger BITV 2.0 Barrierefreiheit.',
                'info.offlineCapable': 'Offline-f√§hig',
                'info.multiBrowser': 'Multi-Browser',
                'info.storageOptimized': 'Speicheroptimiert',
                'info.localDownload': 'Lokaler Download',
                
                // Compliance
                'compliance.title': 'Compliance & Zertifizierungen',
                'compliance.wcag': 'WCAG 2.1 Level AA',
                'compliance.wcagDesc': 'Web Content Accessibility Guidelines',
                'compliance.bitv': 'BITV 2.0 Compliant',
                'compliance.bitvDesc': 'Barrierefreie IT-Verordnung',
                'compliance.en': 'EN 301 549 Compliant',
                'compliance.enDesc': 'EU Accessibility Standard',
                
                // Features
                'features.title': 'Hauptfunktionen',
                'features.recording': 'Aufnahme & Produktion',
                'features.crashguard': 'CrashGuard System',
                'features.cloud': 'Cloud-Synchronisation',
                'features.accessibility': 'Barrierefreiheit',
                'features.offline': 'Offline & Multi-Browser',
                'features.performance': 'Performance & Speicher',
                
                // Technical Specs
                'tech.title': 'Technische Spezifikationen',
                'tech.frontend': 'Frontend:',
                'tech.backend': 'Backend:',
                'tech.storage': 'Storage:',
                'tech.audio': 'Audio API:',
                'tech.serviceWorker': 'Service Worker:',
                'tech.recorder': 'Recorder:',
                
                // Planned Features
                'planned.title': 'Geplante Features (Roadmap)',
                'planned.webcomponent': 'WebComponent-Integration',
                'planned.webcomponentDesc': 'Standalone Component f√ºr Angular, React, Vue.js',
                'planned.multilang': 'Multi-Language Support',
                'planned.multilangDesc': 'Deutsch, English, Fran√ßais, Espa√±ol, Italiano',
                'planned.auth': 'Authentifizierung & Sicherheit',
                'planned.authDesc': 'OAuth2, SAML, JWT, End-to-End Encryption',
                'planned.collab': 'Collaborative Recording',
                'planned.collabDesc': 'Multi-User Sessions, Real-Time Collaboration',
                'planned.theme': 'Theme Engine',
                'planned.themeDesc': 'Light/Dark Mode, Custom Color Schemes, Skins',
                'planned.effects': 'Advanced Effects',
                'planned.effectsDesc': 'Reverb, Delay, Compressor, Limiter, Noise Gate',
                'planned.multitrack': 'Multi-Track Recording',
                'planned.multitrackDesc': 'Parallele Aufnahme mehrerer Spuren',
                
                // Preview Warning
                'preview.title': 'Preview Version - Einschr√§nkungen',
                'preview.intro': 'Dies ist eine Preview-Version zur Demonstration der Kernfunktionalit√§t. Folgende Features sind aktuell nicht implementiert:',
                'preview.noAuth': 'Authentifizierung',
                'preview.noAuthDesc': 'Kein Login-System, keine Benutzerkonten',
                'preview.noAuthz': 'Autorisierung',
                'preview.noAuthzDesc': 'Keine Rollen- oder Rechteverwaltung',
                'preview.noEncrypt': 'Inhaltsverschl√ºsselung',
                'preview.noEncryptDesc': 'Daten√ºbertragung ist per TLS/SSL verschl√ºsselt, jedoch nicht die DB-Inhalte in lokalen Browser-Datenbanken',
                'preview.noIntegration': 'Framework-Integration',
                'preview.noIntegrationDesc': 'WebComponent f√ºr Angular/React noch nicht verf√ºgbar',
                'preview.disclaimer': '‚ö† Diese Version ist ausschlie√ülich f√ºr Test- und Demonstrationszwecke bestimmt und nicht f√ºr den Produktivbetrieb geeignet.',
                
                // ARIA Labels
                'aria.selectLanguage': 'Sprache ausw√§hlen',
                'aria.info': 'Informationen und Compliance anzeigen',
                'aria.recordingDuration': 'Aufnahmedauer',
                'aria.startRecording': 'Aufnahme starten',
                'aria.stopRecording': 'Aufnahme stoppen',
                'aria.inputLowShelf': 'Eingangs-Low-Shelf EQ',
                'aria.inputPeaking': 'Eingangs-Peaking EQ',
                'aria.inputHighShelf': 'Eingangs-High-Shelf EQ',
                'aria.inputGain': 'Eingangs-Verst√§rkung',
                'aria.outputLowShelf': 'Ausgangs-Low-Shelf EQ',
                'aria.outputPeaking': 'Ausgangs-Peaking EQ',
                'aria.outputHighShelf': 'Ausgangs-High-Shelf EQ',
                'aria.outputGain': 'Ausgangslautst√§rke',
                'aria.selectFormat': 'Aufnahmeformat ausw√§hlen',
                'aria.visualizer': 'Audio-Visualisierung',
                'aria.inputSection': 'Eingangsstufe',
                'aria.outputSection': 'Ausgangsstufe',
                'aria.playlistSection': 'Aufnahmeliste',
            },
            en: {
                // UI Elements
                'ui.info': 'INFO',
                'ui.skipToContent': 'Skip to main content',
                'ui.crashguard': 'CRASHGUARD // RAID PROTECTED SYSTEM',
                'ui.format': 'FORMAT:',
                'ui.rec': 'REC',
                'ui.stop': 'STOP',
                'ui.input': 'INPUT',
                'ui.output': 'OUTPUT',
                'ui.inputStage': 'INPUT STAGE',
                'ui.outputStage': 'OUTPUT STAGE',
                'ui.low': 'LOW',
                'ui.mid': 'MID',
                'ui.high': 'HIGH',
                'ui.gain': 'GAIN',
                'ui.save': 'SAVE',
                'ui.close': 'CLOSE',
                'ui.yes': 'YES',
                'ui.no': 'NO',
                'ui.delete': 'Delete',
                'ui.download': 'DL',
                'ui.play': 'Play',
                'ui.upload': 'Upload',
                
                // Status Messages
                'status.ready': 'SYSTEM READY',
                'status.recording': 'RECORDING',
                'status.stopped': 'STOPPED',
                'status.playing': 'PLAYING',
                'status.paused': 'PAUSED',
                'status.error': 'ERROR',
                'status.uploading': 'UPLOADING',
                'status.uploaded': 'UPLOADED',
                
                // Format Options
                'format.webm': 'WEBM (Opus Codec)',
                'format.wav': 'WAV (Lossless)',
                'format.mp3': 'MP3',
                'format.detecting': 'FORMAT: DETECTING...',
                'format.ramWarning': '‚úì LOW RAM MODE (Safe for 8h+)',
                'format.ramWarningWav': '‚ö† HIGH RAM! Only 30min safe with 8GB',
                
                // Recording Info
                'recording.sessionStarted': 'Session started',
                'recording.crashDetected': 'CRASH DETECTED! Restoring session...',
                'recording.recoveryAvailable': 'Recovery available',
                'recording.sessionRecovered': 'Session successfully recovered',
                'recording.chunksSaved': 'Chunks saved',
                'recording.duration': 'Duration',
                
                // Playlist
                'playlist.title': 'RECORDINGS',
                'playlist.noData': 'NO DATA FOUND',
                'playlist.trackCount': 'TRACKS',
                
                // Modal Titles
                'modal.save': 'Save Recording',
                'modal.info': 'WAVEFORGE PRO - INFO',
                'modal.recovery': 'Session Recovery',
                
                // Save Modal
                'save.enterName': 'Enter filename',
                'save.placeholder': 'My Recording',
                'save.saveButton': 'Save',
                'save.closeButton': 'Discard',
                
                // Recovery Modal
                'recovery.title': 'CRASH RECOVERY',
                'recovery.detected': 'Interrupted session detected!',
                'recovery.message': 'A previous recording was interrupted. Would you like to restore it?',
                'recovery.chunkInfo': 'Available chunks',
                'recovery.restore': 'Restore',
                'recovery.discard': 'Discard',
                
                // Info Modal Sections
                'info.title': 'WAVEFORGE PRO - INFO',
                'info.close': 'Close',
                'info.introduction': 'Professional Browser-Based Offline Audio Workstation',
                'info.introText': 'WaveForge Pro is a cutting-edge Digital Audio Workstation (DAW) for browsers, optimized for long recordings (8+ hours) with intelligent CrashGuard system, cloud synchronization, and full BITV 2.0 accessibility compliance.',
                'info.offlineCapable': 'Offline-Capable',
                'info.multiBrowser': 'Multi-Browser',
                'info.storageOptimized': 'Storage-Optimized',
                'info.localDownload': 'Local Download',
                
                // Compliance
                'compliance.title': 'Compliance & Certifications',
                'compliance.wcag': 'WCAG 2.1 Level AA',
                'compliance.wcagDesc': 'Web Content Accessibility Guidelines',
                'compliance.bitv': 'BITV 2.0 Compliant',
                'compliance.bitvDesc': 'Barrier-Free IT Ordinance',
                'compliance.en': 'EN 301 549 Compliant',
                'compliance.enDesc': 'EU Accessibility Standard',
                
                // Features
                'features.title': 'Main Features',
                'features.recording': 'Recording & Production',
                'features.crashguard': 'CrashGuard System',
                'features.cloud': 'Cloud Synchronization',
                'features.accessibility': 'Accessibility',
                'features.offline': 'Offline & Multi-Browser',
                'features.performance': 'Performance & Storage',
                
                // Technical Specs
                'tech.title': 'Technical Specifications',
                'tech.frontend': 'Frontend:',
                'tech.backend': 'Backend:',
                'tech.storage': 'Storage:',
                'tech.audio': 'Audio API:',
                'tech.serviceWorker': 'Service Worker:',
                'tech.recorder': 'Recorder:',
                
                // Planned Features
                'planned.title': 'Planned Features (Roadmap)',
                'planned.webcomponent': 'WebComponent Integration',
                'planned.webcomponentDesc': 'Standalone component for Angular, React, Vue.js',
                'planned.multilang': 'Multi-Language Support',
                'planned.multilangDesc': 'German, English, French, Spanish, Italian',
                'planned.auth': 'Authentication & Security',
                'planned.authDesc': 'OAuth2, SAML, JWT, End-to-End Encryption',
                'planned.collab': 'Collaborative Recording',
                'planned.collabDesc': 'Multi-User Sessions, Real-Time Collaboration',
                'planned.theme': 'Theme Engine',
                'planned.themeDesc': 'Light/Dark Mode, Custom Color Schemes, Skins',
                'planned.effects': 'Advanced Effects',
                'planned.effectsDesc': 'Reverb, Delay, Compressor, Limiter, Noise Gate',
                'planned.multitrack': 'Multi-Track Recording',
                'planned.multitrackDesc': 'Parallel recording of multiple tracks',
                
                // Preview Warning
                'preview.title': 'Preview Version - Limitations',
                'preview.intro': 'This is a preview version to demonstrate core functionality. The following features are currently not implemented:',
                'preview.noAuth': 'Authentication',
                'preview.noAuthDesc': 'No login system, no user accounts',
                'preview.noAuthz': 'Authorization',
                'preview.noAuthzDesc': 'No role or permission management',
                'preview.noEncrypt': 'Encryption',
                'preview.noEncryptDesc': 'Encrypted data transmission is per TLS/SSL implemented, however no encrypted contents in local browser databases',
                'preview.noIntegration': 'Framework Integration',
                'preview.noIntegrationDesc': 'WebComponent for Angular/React not yet available',
                'preview.disclaimer': '‚ö† This version is exclusively for testing and demonstration purposes and not suitable for production use.',
                
                // ARIA Labels
                'aria.selectLanguage': 'Select language',
                'aria.info': 'Show information and compliance',
                'aria.recordingDuration': 'Recording duration',
                'aria.startRecording': 'Start recording',
                'aria.stopRecording': 'Stop recording',
                'aria.inputLowShelf': 'Input Low-Shelf EQ',
                'aria.inputPeaking': 'Input Peaking EQ',
                'aria.inputHighShelf': 'Input High-Shelf EQ',
                'aria.inputGain': 'Input Gain',
                'aria.outputLowShelf': 'Output Low-Shelf EQ',
                'aria.outputPeaking': 'Output Peaking EQ',
                'aria.outputHighShelf': 'Output High-Shelf EQ',
                'aria.outputGain': 'Output Volume',
                'aria.selectFormat': 'Select recording format',
                'aria.visualizer': 'Audio Visualization',
                'aria.inputSection': 'Input Stage',
                'aria.outputSection': 'Output Stage',
                'aria.playlistSection': 'Recording List',
            }
        };

        let currentLanguage = 'de';

        function initLanguage() {
            // Check if user has saved preference
            const savedLang = localStorage.getItem('waveforge_language');
            if (savedLang && translations[savedLang]) {
                currentLanguage = savedLang;
                document.getElementById('languageSelector').value = savedLang;
            } else {
                // Detect browser language
                const browserLang = navigator.language.split('-')[0];
                if (translations[browserLang]) {
                    currentLanguage = browserLang;
                    document.getElementById('languageSelector').value = browserLang;
                }
            }
            
            // Update HTML lang attribute
            document.documentElement.lang = currentLanguage;
            
            // Apply translations
            translatePage();
        }

        function switchLanguage(lang) {
            if (!translations[lang]) return;
            currentLanguage = lang;
            localStorage.setItem('waveforge_language', lang);
            document.documentElement.lang = lang;
            translatePage();
        }

        function translatePage() {
            const t = translations[currentLanguage];
            
            // Translate elements with data-i18n attribute
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (t[key]) {
                    el.textContent = t[key];
                }
            });
            
            // Translate attributes (aria-label, placeholder, title, etc.)
            document.querySelectorAll('[data-i18n-attr]').forEach(el => {
                const attrs = el.getAttribute('data-i18n-attr').split(',');
                attrs.forEach(attr => {
                    const [attrName, key] = attr.trim().split(':');
                    if (t[key]) {
                        el.setAttribute(attrName, t[key]);
                    }
                });
            });
            
            // Update dynamic content that uses t() function
            updateFormatWarning();
            loadTracksFromDB(); // Refresh playlist with new language
        }

        function t(key) {
            return translations[currentLanguage][key] || key;
        }
    </script>
</body>
</html>